Bandit Algorithms
Tor Lattimore and Csaba Szepesv´ari
This is the (free) online edition. The content is the same as the print edition, published by Cambridge University Press, except that minor typos are corrected here. There are also font and other typographical differences that mean the page numbers do not match between the versions.

Contents

Contents

Part I Bandits, Probability and Concentration

1

Introduction

1.1 The Language of Bandits

1.2 Applications

1.3 Notes

1.4 Bibliographic Remarks

2

Foundations of Probability ( )

2.1 Probability Spaces and Random Elements

2.2 -Algebras and Knowledge

2.3 Conditional Probabilities

2.4 Independence

2.5 Integration and Expectation

2.6 Conditional Expectation

2.7 Notes

2.8 Bibliographic Remarks

2.9 Exercises

3

Stochastic Processes and Markov Chains ( )

3.1 Stochastic Processes

3.2 Markov Chains

3.3 Martingales and Stopping Times

3.4 Notes

3.5 Bibliographic Remarks

3.6 Exercises

4

Stochastic Bandits

4.1 Core Assumptions

4.2 The Learning Objective

4.3 Knowledge and Environment Classes

page ii
7
8 10 13 16 16
18 18 26 28 29 30 33 37 41 42
46 47 48 49 52 53 54
56 56 57 57

CONTENTS

iii

4.4 The Regret

60

4.5 Decomposing the Regret

62

4.6 The Canonical Bandit Model ( )

63

4.7 The Canonical Bandit Model for Uncountable Action Sets ( )

66

4.8 Notes

66

4.9 Bibliographical Remarks

68

4.10 Exercises

69

5

Concentration of Measure

73

5.1 Tail Probabilities

73

5.2 The Inequalities of Markov and Chebyshev

74

5.3 The Cram´er-Chernoff Method and Subgaussian Random Variables 76

5.4 Notes

78

5.5 Bibliographical Remarks

80

5.6 Exercises

80

Part II Stochastic Bandits with Finitely Many Arms

88

6

The Explore-Then-Commit Algorithm

90

6.1 Algorithm and Regret Analysis

90

6.2 Notes

94

6.3 Bibliographical Remarks

94

6.4 Exercises

95

7

The Upper Confidence Bound Algorithm

101

7.1 The Optimism Principle

101

7.2 Notes

109

7.3 Bibliographical Remarks

110

7.4 Exercises

110

8

The Upper Confidence Bound Algorithm: Asymptotic Optimality

116

8.1 Asymptotically Optimal UCB

116

8.2 Notes

119

8.3 Bibliographic Remarks

119

8.4 Exercises

120

9

The Upper Confidence Bound Algorithm: Minimax Optimality ( )

122

9.1 The MOSS Algorithm

122

9.2 Two Problems

126

9.3 Notes

127

9.4 Bibliographic Remarks

128

9.5 Exercises

128

10

The Upper Confidence Bound Algorithm: Bernoulli Noise ( )

132

CONTENTS

iv

10.1 Concentration for Sums of Bernoulli Random Variables

132

10.2 The KL-UCB Algorithm

136

10.3 Notes

139

10.4 Bibliographic Remarks

140

10.5 Exercises

140

Part III Adversarial Bandits with Finitely Many Arms

143

11

The Exp3 Algorithm

147

11.1 Adversarial Bandit Environments

147

11.2 Importance-Weighted Estimators

149

11.3 The Exp3 Algorithm

151

11.4 Regret Analysis

152

11.5 Notes

156

11.6 Bibliographic Remarks

159

11.7 Exercises

159

12

The Exp3-IX Algorithm

164

12.1 The Exp3-IX Algorithm

164

12.2 Regret Analysis

166

12.3 Notes

170

12.4 Bibliographic Remarks

171

12.5 Exercises

171

Part IV Lower Bounds for Bandits with Finitely Many Arms

176

13

Lower Bounds: Basic Ideas

179

13.1 Main Ideas Underlying Minimax Lower Bounds

180

13.2 Notes

182

13.3 Bibliographic Remarks

183

13.4 Exercises

183

14

Foundations of Information Theory ( )

185

14.1 Entropy and Optimal Coding

185

14.2 Relative Entropy

187

14.3 Notes

190

14.4 Bibliographic Remarks

193

14.5 Exercises

193

15

Minimax Lower Bounds

196

15.1 Relative Entropy Between Bandits

196

15.2 Minimax Lower Bounds

197

15.3 Notes

199

15.4 Bibliographic Remarks

201

CONTENTS

v

15.5 Exercises

201

16

Instance-Dependent Lower Bounds

204

16.1 Asymptotic Bounds

205

16.2 Finite-Time Bounds

207

16.3 Notes

208

16.4 Bibliographic Remarks

209

16.5 Exercises

209

17

High-Probability Lower Bounds

213

17.1 Stochastic Bandits

214

17.2 Adversarial Bandits

216

17.3 Notes

218

17.4 Bibliographic Remarks

218

17.5 Exercises

219

Part V Contextual and Linear Bandits

220

18

Contextual Bandits

222

18.1 Contextual Bandits: One Bandit per Context

222

18.2 Bandits with Expert Advice

224

18.3 Exp4

227

18.4 Regret Analysis

227

18.5 Notes

229

18.6 Bibliographic Remarks

231

18.7 Exercises

232

19

Stochastic Linear Bandits

236

19.1 Stochastic Contextual Bandits

236

19.2 Stochastic Linear Bandits

238

19.3 Regret Analysis

241

19.4 Notes

243

19.5 Bibliographic Remarks

245

19.6 Exercises

246

20

Confidence Bounds for Least Squares Estimators

252

20.1 Martingales and the Method of Mixtures

254

20.2 Notes

259

20.3 Bibliographic Remarks

260

20.4 Exercises

260

21

Optimal Design for Least Squares Estimators

265

21.1 The Kiefer­Wolfowitz Theorem

265

21.2 Notes

268

CONTENTS

vi

21.3 Bibliographic Remarks

269

21.4 Exercises

269

22

Stochastic Linear Bandits with Finitely Many Arms

271

22.1 Notes

272

22.2 Bibliographic Remarks

273

22.3 Exercises

273

23

Stochastic Linear Bandits with Sparsity

275

23.1 Sparse Linear Stochastic Bandits

275

23.2 Elimination on the Hypercube

276

23.3 Online to Confidence Set Conversion

280

23.4 Sparse Online Linear Prediction

283

23.5 Notes

284

23.6 Bibliographical Remarks

285

23.7 Exercises

285

24

Minimax Lower Bounds for Stochastic Linear Bandits

286

24.1 Hypercube

287

24.2 Unit Ball

288

24.3 Sparse Parameter Vectors

290

24.4 Misspecified Models

291

24.5 Notes

293

24.6 Bibliographic Remarks

293

24.7 Exercises

293

25

Asymptotic Lower Bounds for Stochastic Linear Bandits

294

25.1 An Asymptotic Lower Bound for Fixed Action Sets

294

25.2 Clouds Looming for Optimism

298

25.3 Notes

300

25.4 Bibliographic Remarks

300

25.5 Exercises

300

Part VI Adversarial Linear Bandits

302

26

Foundations of Convex Analysis ( )

304

26.1 Convex Sets and Functions

304

26.2 Jensen's Inequality

306

26.3 Bregman Divergence

306

26.4 Legendre Functions

308

26.5 Optimisation

310

26.6 Projections

311

26.7 Notes

312

26.8 Bibliographic Remarks

312

CONTENTS

vii

26.9 Exercises

312

27

Exp3 for Adversarial Linear Bandits

316

27.1 Exponential Weights for Linear Bandits

316

27.2 Regret Analysis

318

27.3 Continuous Exponential Weights

319

27.4 Notes

321

27.5 Bibliographic Remarks

322

27.6 Exercises

323

28

Follow-the-Regularised-Leader and Mirror Descent

325

28.1 Online Linear Optimisation

325

28.2 Regret Analysis

329

28.3 Application to Linear Bandits

333

28.4 Linear Bandits on the Unit Ball

335

28.5 Notes

338

28.6 Bibliographic Remarks

341

28.7 Exercises

342

29

The Relation between Adversarial and Stochastic Linear Bandits

348

29.1 Unified View

348

29.2 Reducing Stochastic Linear Bandits to Adversarial Linear Bandits 349

29.3 Stochastic Linear Bandits with Parameter Noise

350

29.4 Contextual Linear Bandits

352

29.5 Notes

353

29.6 Bibliographic Remarks

354

29.7 Exercises

354

Part VII Other Topics

356

30

Combinatorial Bandits

360

30.1 Notation and Assumptions

361

30.2 Applications

361

30.3 Bandit Feedback

362

30.4 Semi-bandit Feedback and Mirror Descent

363

30.5 Follow-the-Perturbed-Leader

365

30.6 Notes

370

30.7 Bibliographic Remarks

372

30.8 Exercises

373

31

Non-stationary Bandits

376

31.1 Adversarial Bandits

376

31.2 Stochastic Bandits

379

31.3 Notes

381

CONTENTS

viii

31.4 Bibliographic Remarks

383

31.5 Exercises

384

32

Ranking

386

32.1 Click Models

387

32.2 Policy

390

32.3 Regret Analysis

392

32.4 Notes

396

32.5 Bibliographic Remarks

398

32.6 Exercises

399

33

Pure Exploration

401

33.1 Simple Regret

401

33.2 Best-Arm Identification with a Fixed Confidence

403

33.3 Best-Arm Identification with a Budget

410

33.4 Notes

411

33.5 Bibliographical Remarks

413

33.6 Exercises

415

34

Foundations of Bayesian Learning

419

34.1 Statistical Decision Theory and Bayesian Learning

419

34.2 Bayesian Learning and the Posterior Distribution

420

34.3 Conjugate Pairs, Conjugate Priors and the Exponential Family

424

34.4 The Bayesian Bandit Environment

428

34.5 Posterior Distributions in Bandits

429

34.6 Bayesian Regret

430

34.7 Notes

431

34.8 Bibliographic Remarks

434

34.9 Exercises

434

35

Bayesian Bandits

438

35.1 Bayesian Optimal Regret for k-Armed Stochastic Bandits

438

35.2 Optimal Stopping ( )

439

35.3 One-armed Bayesian Bandits

441

35.4 Gittins Index

445

35.5 Computing the Gittins Index

451

35.6 Notes

452

35.7 Bibliographical Remarks

454

35.8 Exercises

455

36

Thompson Sampling

458

36.1 Finite-Armed Bandits

459

36.2 Frequentist Analysis

460

36.3 Linear Bandits

464

CONTENTS

ix

36.4 Information Theoretic Analysis

466

36.5 Notes

469

36.6 Bibliographic Remarks

472

36.7 Exercises

473

Part VIII Beyond Bandits

476

37

Partial Monitoring

477

37.1 Finite Adversarial Partial Monitoring Problems

478

37.2 The Structure of Partial Monitoring

481

37.3 Classification of Finite Adversarial Partial Monitoring

485

37.4 Lower Bounds

486

37.5 Policy and Upper Bounds

490

37.6 Proof of Theorem 37.16

495

37.7 Proof of Theorem 37.17

496

37.8 Proof of the Classification Theorem

501

37.9 Notes

501

37.10 Bibliographical Remarks

505

37.11 Exercises

506

38

Markov Decision Processes

510

38.1 Problem Set-Up

510

38.2 Optimal Policies and the Bellman Optimality Equation

514

38.3 Finding an Optimal Policy ( )

517

38.4 Learning in Markov Decision Processes

520

38.5 Upper Confidence Bounds for Reinforcement Learning

521

38.6 Proof of Upper Bound

524

38.7 Proof of Lower Bound

527

38.8 Notes

530

38.9 Bibliographical Remarks

534

38.10 Exercises

536

Bibliography

547

Index

581

Preface
Multi-armed bandits have now been studied for nearly a century. While research in the beginning was quite meandering, there is now a large community publishing hundreds of articles every year. Bandit algorithms are also finding their way into practical applications in industry, especially in on-line platforms where data is readily available and automation is the only way to scale.
We had hoped to write a comprehensive book, but the literature is now so vast that many topics have been excluded. In the end we settled on the more modest goal of equipping our readers with enough expertise to explore the specialised literature by themselves, and to adapt existing algorithms to their applications. This latter point is important. Problems in theory are all alike; every application is different. A practitioner seeking to apply a bandit algorithm needs to understand which assumptions in the theory are important and how to modify the algorithm when the assumptions change. We hope this book can provide that understanding.
What is covered in the book is covered in some depth. The focus is on the mathematical analysis of algorithms for bandit problems, but this is not a traditional mathematics book, where lemmas are followed by proofs, theorems and more lemmas. We worked hard to include guiding principles for designing algorithms and intuition for their analysis. Many algorithms are accompanied by empirical demonstrations that further aid intuition.
We expect our readers to be familiar with basic analysis and calculus and some linear algebra. The book uses the notation of measure-theoretic probability theory, but does not rely on any deep results. A dedicated chapter is included to introduce the notation and provide intuitions for the basic results we need. This chapter is unusual for an introduction to measure theory in that it emphasises the reasons to use -algebras beyond the standard technical justifications. We hope this will convince the reader that measure theory is an important and intuitive tool. Some chapters use techniques from information theory and convex analysis, and we devote a short chapter to each.
Most chapters are short and should be readable in an afternoon or presented in a single lecture. Some components of the book contain content that is not really about bandits. These can be skipped by knowledgeable readers, or otherwise referred to when necessary. They are marked with a ( ) because `Skippy the

Preface

2

Kangaroo' skips things.1 The same mark is used for those parts that contain useful, but perhaps overly specific information for the first-time reader. Later parts will not build on these chapters in any substantial way. Most chapters end with a list of notes and exercises. These are intended to deepen intuition and highlight the connections between various subsections and the literature. There is a table of notation at the end of this preface.
Thanks We're indebted to our many collaborators and feel privileged that there are too many of you to name. The University of Alberta, Indiana University and DeepMind have all provided outstanding work environments and supported the completion of this book. The book has benefited enormously from the proofreading efforts of a large number of our friends and colleagues. We're sorry for all the mistakes introduced after your hard work. Alphabetically, they are: Aaditya Ramdas, Abbas Mehrabian, Aditya Gopalan, Ambuj Tewari, Andr´as Gy¨orgy, Arnoud den Boer, Branislav Kveton, Brendan Patch, Chao Tao, Christoph Dann, Claire Vernade, Emilie Kaufmann, Eugene Ji, Gell´ert Weisz, Gergely Neu, Johannes Kirschner, Julian Zimmert, Kwang-Sung Jun, Lalit Jain, Laurent Orseau, Marcus Hutter, Michal Valko, Omar Rivasplata, Pierre Menard, Ramana Kumar, Roman Pogodin, Ronald Ortner, Ronan Fruit, Ruihao Zhu, Shuai Li, Toshiyuki Tanaka, Wei Chen, Yoan Russac, Yufei Yi and Zhu Xiaohu. We are especially grateful to G´abor Bal´azs and Wouter Koolen, who both read almost the entire book. Thanks to Lauren Cowels and Cambridge University Press for providing free books for our proofreaders, tolerating the delays and for supporting a freely available PDF version. R´eka Szepesva´ri is responsible for converting some of our primary school figures to their current glory. Last of all, our families have endured endless weekends of editing and multiple false promises of `done by Christmas'. Rosina and Bea´ta, it really is done now!

1 Taking inspiration from Tor's grandfather-in-law, John Dillon [Anderson et al., 1977].

Notation
Some sections are marked with special symbols, which are listed and described below.
This symbol is a note. Usually this is a remark that is slightly tangential to the topic at hand.
A warning to the reader.
Something important.
An experiment.
Nomenclature and Conventions A sequence (an)n=1 is increasing if an+1  an for all n  1 and decreasing if an+1  an. When the inequalities are strict, we say strictly increasing/decreasing. The same terminology holds for functions. We will not be dogmatic about what is the range of argmin/argmax. Sometimes they return sets, sometimes arbitrary elements of those sets and, where stated, specific elements of those sets. We will be specific when it is non-obvious/matters. The infimum of the empty set is inf  =  and the supremum is sup  = -. The empty sum is i ai = 0 and the empty product is i ai = 1.
Landau Notation We make frequent use of the Bachmann­Landau notation. Both were nineteenth century mathematicians who could have never expected their notation to be adopted so enthusiastically by computer scientists. Given functions f, g : N 

Notation

4

[0, ), define

f (n)

=

O(g(n))



lim sup
n

f (n) g(n)

<

,

f (n)

=

o(g(n))



lim
n

f (n) g(n)

=

0,

f (n)

=

(g(n))



lim inf
n

f (n) g(n)

>

0,

f (n)

=

(g(n))



lim inf
n

f (n) g(n)

=

,

f (n) = (g(n))  f (n) = O(g(n)) and f (n) = (g(n)) .

We make use of the (Bachmann­)Landau notation in two contexts. First, in proofs where limiting arguments are made, we sometimes write lower-order terms using Landau notation. For example, we might write that f (n) = n + o( n), by which we mean that limn f (n)/ n = 1. In this case we use the mathematical definitions as envisaged by Bachmann and Landau. The second usage is to informally describe a result without the clutter of uninteresting constants. For better or worse, this usage is often a little imprecise. For example, we will often write expressions of the form: Rn = O(m dn). Almost always what is meant by this is that there exists a universal constant c > 0 (a constantthat does not depend on either of the quantities involved) such that Rn  cm dn for all (reasonable) choices of m, d and n. In this context we are careful not to use Landau notation to hide large lower-order terms. For example, if f (x) = x2 + 10100x, we will not write f (x) = O(x2), although this would be true.

Bandits
At k
n
Xt Yt 

µi
Sets
 N, N+ R R¯ [n] 2A A B2d Pd

action in round t number of arms/actions time horizon reward in round t loss in round t a policy a bandit mean reward of arm i

empty set

natural numbers, N = {0, 1, 2, . . .} and N+ = N \ {0}

real numbers

R  {-, }

{1, 2, 3, . . . , n - 1, n}

the power set of set A (the set of all subsets of A)

set of finite sequences over A, A =

 i=0

Ai

d-dimensional unit ball, {x  Rd : x 2  1}

probability simplex, {x  [0, 1]d+1 : x 1 = 1}

Notation

5

P (A) B(A) [x, y]

set of distributions over set A Borel -algebra on A convex hull of vectors or real values x and y

Functions, Operators and Operations

|A|

the cardinality (number of elements) of the finite set A

(x)+

max(x, 0)

a mod b

remainder when natural number a is divided by b

x, x

floor and ceiling functions of x

dom(f )

domain of function f

E

expectation

V

variance

Supp

support of distribution or random variable

f (x)

gradient of f at x

vf (x) 2f (x)

directional derivative of f at x in direction v Hessian of f at x

, 
erf (x)
erfc(x)
(z)
A(x) f (y)
n k
argmaxx f (x) argminx f (x) I

maximum and minimum, ab = max(a, b) and ab = min(a, b)

2

x 0

exp(-y2)dy

1 - erf(x)

Gamma function, (z) =

 0

xz-1

exp(-x)dx

support function A(x) = supyA x, y

convex conjugate, f (y) = supxA x, y - f (x)

binomial coefficient

maximiser or maximisers of f

minimiser or minimisers of f

indicator function: converts Boolean  into binary

IB

indicator of set B

D(P, Q)

Relative entropy between probability distributions P and Q

d(p, q)

Relative entropy between B(p) and B(q)

Linear Algebra

e1, . . . , ed 0, 1

standard basis vectors of the d-dimensional Euclidean space vectors whose elements are all zeros and all ones, respectively

det(A)

determinant of matrix A

trace(A)

trace of matrix A

im(A)

image of matrix A

ker(A)

kernel of matrix A

span(v1, . . . , vd) min(G) x, y

xp

x

2 G

span of vectors v1, . . . , vd
minimum eigenvalue of matrix G
inner product, x, y = i xiyi p-norm of vector x x Gx for positive definite G  Rd×d and x  Rd

Notation

6

,
Distributions N (µ, 2) B(p) U(a, b) Beta(, ) x
Topological cl(A) int(A) A co(A) aff (A) ri(A)

Loewner partial order of positive semidefinite matrices: A B (A  B) if B - A is positive semidefinite (respectively, definite).
Normal distribution with mean µ and variance 2 Bernoulli distribution with mean p uniform distribution supported on [a, b] Beta distribution with parameters ,  > 0 Dirac distribution with point mass at x
closure of set A interior of set A boundary of a set A, A = cl(A) \ int(A) convex hull of A affine hull of A relative interior of A

Part I
Bandits, Probability and Concentration

1 Introduction
Bandit problems were introduced by William R. Thompson in an article published in 1933 in Biometrika. Thompson was interested in medical trials and the cruelty of running a trial blindly, without adapting the treatment allocations on the fly as the drug appears more or less effective. The name comes from the 1950s, when Frederick Mosteller and Robert Bush decided to study animal learning and ran trials on mice and then on humans. The mice faced the dilemma of choosing to go left or right after starting in the bottom of a T-shaped maze, not knowing each time at which end they would find food. To study a similar learning setting in humans, a `two-armed bandit' machine was commissioned where humans could choose to pull either the left or the right arm of the machine, each giving a Figure 1.1 Mouse learning a T-maze. random pay-off with the distribution of payoffs for each arm unknown to the human player. The machine was called a `two-armed bandit' in homage to the one-armed bandit, an old-fashioned name for a lever-operated slot machine (`bandit' because they steal your money).
There are many reasons to care about bandit problems. Decision-making with uncertainty is a challenge we all face, and bandits provide a simple model of this dilemma. Bandit problems also have practical applications. We already mentioned clinical trial design, which researchers have used to motivate their work for 80 years. We can't point to an example where bandits have actually been used in clinical trials, but adaptive experimental design is gaining popularity and is actively encouraged by the US Food and Drug Administration, with the justification that not doing so can lead to the withholding of effective drugs until long after a positive effect has been established.
While clinical trials are an important application for the future, there are applications where bandit algorithms are already in use. Major tech companies use bandit algorithms for configuring web interfaces, where applications include news recommendation, dynamic pricing and ad placement. A bandit algorithm

Introduction

9

plays a role in Monte Carlo Tree Search, an algorithm made famous by the recent success of AlphaGo.
Finally, the mathematical formulation of bandit problems leads to a rich structure with connections to other branches of mathematics. In writing this book (and previous papers), we have read books on convex analysis/optimisation, Brownian motion, probability theory, concentration analysis, statistics, differential geometry, information theory, Markov chains, computational complexity and more. What fun!
A combination of all these factors has led to an enormous growth in research over the last two decades. Google Scholar reports less than 1000, then 2700 and 7000 papers when searching for the phrase `bandit algorithm' for the periods of 2001­5, 2006­10, and 2011­15, respectively, and the trend just seems to have strengthened since then, with 5600 papers coming up for the period of 2016 to the middle of 2018. Even if these numbers are somewhat overblown, they are indicative of a rapidly growing field. This could be a fashion, or maybe there is something interesting happening here. We think that the latter is true.

A Classical Dilemma
Imagine you are playing a two-armed bandit machine and you already pulled each lever five times, resulting in the following pay-offs (in dollars):

Round 1 2 3 4 5 6 7 8 9 10

left 0

10 0

0

10

right

10

0

000

The left arm appears to be doing slightly better. The

average pay-off for this arm is $4, while the average for the Figure

1.2 Two-

right arm is only $2. Let's say you have 10 more trials (pulls) armed bandit

altogether. What is your strategy? Will you keep pulling

the left arm, ignoring the right? Or would you attribute the poor performance of

the right arm to bad luck and try it a few more times? How many more times?

This illustrates one of the main interests in bandit problems. They capture the

fundamental dilemma a learner faces when choosing between uncertain options.

Should one explore an option that looks inferior or exploit by going with the

option that looks best currently? Finding the right balance between exploration

and exploitation is at the heart of all bandit problems.

1.1 The Language of Bandits

10

1.1 The Language of Bandits
A bandit problem is a sequential game between a learner and an environment. The game is played over n rounds, where n is a positive natural number called the horizon. In each round t  [n], the learner first chooses an action At from a given set A, and the environment then reveals a reward Xt  R.
In the literature, actions are often also called `arms'. We talk about k-armed bandits when the number of actions is k, and about multi-armed bandits when the number of arms is at least two and the actual number is immaterial to the discussion. If there are multi-armed bandits, there are also one-armed bandits, which are really two-armed bandits where the pay-off of one of the arms is a known fixed deterministic number.

Of course the learner cannot peek into the future when choosing their

actions, which means that At should only depend on the history Ht-1 =

(A1, X1, . . . , At-1, Xt-1). A policy is a mapping from histories to actions: A learner adopts a policy to interact with an environment. An environment is a

mapping from history sequences ending in actions to rewards. Both the learner

and the environment may randomise their decisions, but this detail is not so

important for now. The most common objective of the learner is to choose actions

that lead to the largest possible cumulative reward over all n rounds, which is

n t=1

Xt.

The fundamental challenge in bandit problems is that the environment is

unknown to the learner. All the learner knows is that the true environment

lies in some set E called the environment class. Most of this book is about

designing policies for different kinds of environment classes, though in some cases

the framework is extended to include side observations as well as actions and

rewards.

The next question is how to evaluate a learner. We discuss several performance

measures throughout the book, but most of our efforts are devoted to

understanding the regret. There are several ways to define this quantity. To avoid

getting bogged down in details, we start with a somewhat informal definition.

Definition 1.1. The regret of the learner relative to a policy  (not necessarily that followed by the learner) is the difference between the total expected reward using policy  for n rounds and the total expected reward collected by the learner over n rounds. The regret relative to a set of policies  is the maximum regret relative to any policy    in the set.

The set  is often called the competitor class. Another way of saying all this is that the regret measures the performance of the learner relative to the best policy in the competitor class. We usually measure the regret relative to a set of policies  that is large enough to include the optimal policy for all environments

1.1 The Language of Bandits

11

in E. In this case, the regret measures the loss suffered by the learner relative to the optimal policy.

Example 1.2. Suppose the action set is A = {1, 2, . . . , k}. An environment is
called a stochastic Bernoulli bandit if the reward Xt  {0, 1} is binary valued and there exists a vector µ  [0, 1]k such that the probability that Xt = 1 given
the learner chose action At = a is µa. The class of stochastic Bernoulli bandits is
the set of all such bandits, which are characterised by their mean vectors. If you
knew the mean vector associated with the environment, then the optimal policy is to play the fixed action a = argmaxaA µa. This means that for this problem the natural competitor class is the set of k constant polices  = {1, . . . , k}, where i chooses action i in every round. The regret over n rounds becomes

n

Rn

=

n

max
aA

µa

-

E

Xt ,

t=1

where the expectation is with respect to the randomness in the environment and policy. The first term in this expression is the maximum expected reward using any policy. The second term is the expected reward collected by the learner.

For a fixed policy and competitor class, the regret depends on the environment. The environments where the regret is large are those where the learner is behaving worse. Of course the ideal case is that the regret be small for all environments. The worst-case regret is the maximum regret over all possible environments.
One of the core questions in the study of bandits is to understand the growth rate of the regret as n grows. A good learner achieves sublinear regret. Letting Rn denote the regret over n rounds, this means that Rn = o(n) or equivalently that limn Rn/n = 0. Of course one can ask for more. Under what circumstances is Rn = O( n) or Rn = O(log(n))? And what are the leading constants? How does the regret depend on the specific environment in which the learner finds itself? We will discover eventually that for the environment class in Example 1.2, the worst-case regret for any policy is at least ( n) and that there exist policies for which Rn = O( n).

A large environment class corresponds to less knowledge by the learner. A large competitor class means the regret is a more demanding criteria. Some care is sometimes required to choose these sets appropriately so that (a) guarantees on the regret are meaningful and (b) there exist policies that make the regret small.

The framework is general enough to model almost anything by using a rich enough environment class. This cannot be bad, but with too much generality it becomes impossible to say much. For this reason, we usually restrict our attention to certain kinds of environment classes and competitor classes.
A simple problem setting is that of stochastic stationary bandits. In this

1.1 The Language of Bandits

12

case the environment is restricted to generate the reward in response to each action from a distribution that is specific to that action and independent of the previous action choices and rewards. The environment class in Example 1.2 satisfies these conditions, but there are many alternatives. For example, the rewards could follow a Gaussian distribution rather than Bernoulli. This relatively mild difference does not change the nature of the problem in a significant way. A more drastic change is to assume the action set A is a subset of Rd and that the mean reward for choosing some action a  A follows a linear model, Xt = a,  + t for   Rd and t a standard Gaussian (zero mean, unit variance). The unknown quantity in this case is , and the environment class corresponds to its possible values (E = Rd).
For some applications, the assumption that the rewards are stochastic and stationary may be too restrictive. The world mostly appears deterministic, even if it is hard to predict and often chaotic looking. Of course, stochasticity has been enormously successful in explaining patterns in data, and this may be sufficient reason to keep it as the modelling assumption. But what if the stochastic assumptions fail to hold? What if they are violated for a single round? Or just for one action, at some rounds? Will our best algorithms suddenly perform poorly? Or will the algorithms developed be robust to smaller or larger deviations from the modelling assumptions?
An extreme idea is to drop all assumptions on how the rewards are generated, except that they are chosen without knowledge of the learner's actions and lie in a bounded set. If these are the only assumptions, we get what is called the setting of adversarial bandits. The trick to say something meaningful in this setting is to restrict the competitor class. The learner is not expected to find the best sequence of actions, which may be like finding a needle in a haystack. Instead, we usually choose  to be the set of constant policies and demand that the learner is not much worse than any of these. By defining the regret in this way, the stationarity assumption is transported into the definition of regret rather than constraining the environment.
Of course there are all shades of grey between these two extremes. Sometimes we consider the case where the rewards are stochastic, but not stationary. Or one may analyse the robustness of an algorithm for stochastic bandits to small adversarial perturbations. Another idea is to isolate exactly which properties of the stochastic assumption are really exploited by a policy designed for stochastic bandits. This kind of inverse analysis can help explain the strong performance of policies when facing environments that clearly violate the assumptions they were designed for.

1.1.1

Other Learning Objectives
We already mentioned that the regret can be defined in several ways, each capturing slightly different aspects of the behaviour of a policy. Because the regret depends on the environment, it becomes a multi-objective criterion: ideally,

1.2 Applications

13

we want to keep the regret small across all possible environments. One way to convert a multi-objective criterion into a single number is to take averages. This corresponds to the Bayesian viewpoint where the objective is to minimise the average cumulative regret with respect to a prior on the environment class.
Maximising the sum of rewards is not always the objective. Sometimes the learner just wants to find a near-optimal policy after n rounds, but the actual rewards accumulated over those rounds are unimportant. We will see examples of this shortly.

1.1.2

Limitations of the Bandit Framework
One of the distinguishing features of all bandit problems studied in this book is that the learner never needs to plan for the future. More precisely, we will invariably make the assumption that the learner's available choices and rewards tomorrow are not affected by their decisions today. Problems that do require this kind of long-term planning fall into the realm of reinforcement learning, which is the topic of the final chapter. Another limitation of the bandit framework is the assumption that the learner observes the reward in every round. The setting where the reward is not observed is called partial monitoring and is the topic of Chapter 37. Finally, often, the environment itself consists of strategic agents, which the learner needs to take into account. This problem is studied in game theory and would need a book on its own.

1.2 Applications
After this short preview, and as an appetiser before the hard work, we briefly describe the formalisations of a variety of applications.
A/B Testing The designers of a company website are trying to decide whether the `buy it now' button should be placed at the top of the product page or at the bottom. In the old days, they would commit to a trial of each version by splitting incoming users into two groups of 10 000. Each group would be shown a different version of the site, and a statistician would examine the data at the end to decide which version was better. One problem with this approach is the non-adaptivity of the test. For example, if the effect size is large, then the trial could be stopped early.
One way to apply bandits to this problem is to view the two versions of the site as actions. Each time t a user makes a request, a bandit algorithm is used to choose an action At  A = {SiteA, SiteB}, and the reward is Xt = 1 if the user purchases the product and Xt = 0 otherwise.

1.2 Applications

14

In traditional A/B testing, the objective of the statistician is to decide which website is better. When using a bandit algorithm, there is no need to end the trial. The algorithm automatically decides when one version of the site should be shown more often than another. Even if the real objective is to identify the best site, then adaptivity or early stopping can be added to the A/B process using techniques from bandit theory. While this is not the focus of this book, some of the basic ideas are explained in Chapter 33.
Advert Placement In advert placement, each round corresponds to a user visiting a website, and the set of actions A is the set of all available adverts. One could treat this as a standard multi-armed bandit problem, where in each round a policy chooses At  A, and the reward is Xt = 1 if the user clicked on the advert and Xt = 0 otherwise. This might work for specialised websites where the adverts are all likely to be appropriate. But for a company like Amazon, the advertising should be targeted. A user that recently purchased rock-climbing shoes is much more likely to buy a harness than another user. Clearly an algorithm should take this into account.
The standard way to incorporate this additional knowledge is to use the information about the user as context. In its simplest formulation, this might mean clustering users and implementing a separate bandit algorithm for each cluster. Much of this book is devoted to the question of how to use side information to improve the performance of a learner.
This is a good place to emphasise that the world is messy. The set of available adverts is changing from round to round. The feedback from the user can be delayed for many rounds. Finally, the real objective is rarely just to maximise clicks. Other metrics such as user satisfaction, diversity, freshness and fairness, just to mention a few, are important too. These are the kinds of issues that make implementing bandit algorithms in the real world a challenge. This book will not address all these issues in detail. Instead we focus on the foundations and hope this provides enough understanding that you can invent solutions for whatever peculiar challenges arise in your problem.
Recommendation Services Netflix has to decide which movies to place most prominently in your `Browse' page. Like in advert placement, users arrive at the page sequentially, and the reward can be measured as some function of (a) whether or not you watched a movie and (b) whether or not you rated it positively. There are many challenges. First of all, Netflix shows a long list of movies, so the set of possible actions is combinatorially large. Second, each user watches relatively few movies, and individual users are different. This suggests approaches such as low-rank matrix factorisation (a popular approach in `collaborative filtering'). But notice this is

1.2 Applications

15

not an offline problem. The learning algorithm gets to choose what users see and this affects the data. If the users are never recommended the AlphaGo movie, then few users will watch it, and the amount of data about this film will be scarce.
Network Routing Another problem with an interesting structure is network routing, where the learner tries to direct internet traffic through the shortest path on a network. In each round the learner receives the start/end destinations for a packet of data. The set of actions is the set of all paths starting and ending at the appropriate points on some known graph. The feedback in this case is the time it takes for the packet to be received at its destination, and the reward is the negation of this value. Again the action set is combinatorially large. Even relatively small graphs have an enormous number of paths. The routing problem can obviously be applied to more physical networks such as transportation systems used in operations research.
Dynamic Pricing In dynamic pricing, a company is trying to automatically optimise the price of some product. Users arrive sequentially, and the learner sets the price. The user will only purchase the product if the price is lower than their valuation. What makes this problem interesting is (a) the learner never actually observes the valuation of the product, only the binary signal that the price was too low/too high, and (b) there is a monotonicity structure in the pricing. If a user purchased an item priced at $10, then they would surely purchase it for $5, but whether or not it would sell when priced at $11 is uncertain. Also, the set of possible actions is close to continuous.
Waiting Problems Every day you travel to work, either by bus or by walking. Once you get on the bus, the trip only takes 5 minutes, but the timetable is unreliable, and the bus arrival time is unknown and stochastic. Sometimes the bus doesn't come at all. Walking, on the other hand, takes 30 minutes along a beautiful river away from the road. The problem is to devise a policy for choosing how long to wait at the bus stop before giving up and walking to minimise the time to get to your workplace. Walk too soon, and you miss the bus and gain little information. But waiting too long also comes at a price.
While waiting for a bus is not a problem we all face, there are other applications of this setting. For example, deciding the amount of inactivity required before putting a hard drive into sleep mode or powering off a car engine at traffic lights. The statistical part of the waiting problem concerns estimating the cumulative distribution function of the bus arrival times from data. The twist is that the data is censored on the days you chose to walk before the bus arrived, which is a problem analysed in the subfield of statistics called survival analysis. The

1.3 Notes

16

interplay between the statistical estimation problem and the challenge of balancing exploration and exploitation is what makes this and the other problems studied in this book interesting.
Resource Allocation A large part of operations research is focussed on designing strategies for allocating scarce resources. When the dynamics of demand or supply are uncertain, the problem has elements reminiscent of a bandit problem. Allocating too few resources reveals only partial information about the true demand, but allocating too many resources is wasteful. Of course, resource allocation is broad, and many problems exhibit structure that is not typical of bandit problems, like the need for long-term planning.
Tree Search The UCT algorithm is a tree search algorithm commonly used in perfectinformation game-playing algorithms. The idea is to iteratively build a search tree where in each iteration the algorithm takes three steps: (1) chooses a path from the root to a leaf; (2) expands the leaf (if possible); (3) performs a Monte Carlo roll-out to the end of the game. The contribution of a bandit algorithm is in selecting the path from the root to the leaves. At each node in the tree, a bandit algorithm is used to select the child based on the series of rewards observed through that node so far. The resulting algorithm can be analysed theoretically, but more importantly has demonstrated outstanding empirical performance in game-playing problems.
1.3 Notes
1 The reader may find it odd that at one point we identified environments with maps from histories to rewards, while we used the language that a learner `adopts a policy' (a map from histories to actions). The reason is part historical and part because policies and their design are at the center of the book, while the environment strategies will mostly be kept fixed (and relatively simple). On this note, strategy is also a word that sometimes used interchangeably with policy.
1.4 Bibliographic Remarks
As we mentioned in the very beginning, the first paper on bandits was by Thompson [1933]. The experimentation on mice and humans that led to the name comes from the paper by Bush and Mosteller [1953]. Much credit for the popularisation of the field must go to famous mathematician and statistician, Herbert Robbins, whose name appears on many of the works that we reference,

1.4 Bibliographic Remarks

17

with the earliest being: [Robbins, 1952]. Another early pioneer is Herman Chernoff, who wrote papers with titles like `Sequential Decisions in the Control of a Spaceship' [Bather and Chernoff, 1967].
Besides these seminal papers, there are already a number of books on bandits that may serve as useful additional reading. The most recent (and also most related) is by Bubeck and Cesa-Bianchi [2012] and is freely available online. This is an excellent book and is warmly recommended. The main difference between their book and ours is that (a) we have the benefit of seven years of additional research in a fast-moving field and (b) our longer page limit permits more depth. Another relatively recent book is Prediction, Learning and Games by Cesa-Bianchi and Lugosi [2006]. This is a wonderful book, and quite comprehensive. But its scope is `all of' online learning, which is so broad that bandits are not covered in great depth. We should mention there is also a recent book on bandits by Slivkins [2019]. Conveniently it covers some topics not covered in this book (notably Lipschitz bandits and bandits with knapsacks). The reverse is also true, which should not be surprising since our book is currently 400 pages longer. There are also four books on sequential design and multi-armed bandits in the Bayesian setting, which we will address only a little. These are based on relatively old material, but are still useful references for this line of work and are well worth reading [Chernoff, 1959, Berry and Fristedt, 1985, Presman and Sonin, 1990, Gittins et al., 2011].
Without trying to be exhaustive, here are a few articles applying bandit algorithms; a recent survey is by Bouneffouf and Rish [2019]. The papers themselves will contain more useful pointers to the vast literature. We mentioned AlphaGo already [Silver et al., 2016]. The tree search algorithm that drives its search uses a bandit algorithm at each node [Kocsis and Szepesva´ri, 2006]. Le et al. [2014] apply bandits to wireless monitoring, where the problem is challenging due to the large action space. Lei et al. [2017] design specialised contextual bandit algorithms for just-in-time adaptive interventions in mobile health: in the typical application the user is prompted with the intention of inducing a long-term beneficial behavioural change. See also the article by Greenewald et al. [2017]. Rafferty et al. [2018] apply Thompson sampling to educational software and note the trade-off between knowledge and reward. Sadly, by 2015, bandit algorithms still have not been used in clinical trials, as explicitly mentioned by Villar et al. [2015]. Microsoft offers a `Decision Service' that uses bandit algorithms to automate decision-making [Agarwal et al., 2016].

2 Foundations of Probability ( )
This chapter covers the fundamental concepts of measure-theoretic probability, on which the remainder of this book relies. Readers familiar with this topic can safely skip the chapter, but perhaps a brief reading would yield some refreshing perspectives. Measure-theoretic probability is often viewed as a necessary evil, to be used when a demand for rigour combined with continuous spaces breaks the simple approach we know and love from high school. We claim that measuretheoretic probability offers more than annoying technical machinery. In this chapter we attempt to prove this by providing a non-standard introduction. Rather than a long list of definitions, we demonstrate the intuitive power of the notation and tools. For those readers with little prior experience in measure theory this chapter will no doubt be a challenging read. We think the investment is worth the effort, but a great deal of the book can be read without it, provided one is willing to take certain results on faith.
2.1 Probability Spaces and Random Elements
The thrill of gambling comes from the fact that the bet is placed on future outcomes that are uncertain at the time of the gamble. A central question in gambling is the fair value of a game. This can be difficult to answer for all but the simplest games. As an illustrative example, imagine the following moderately complex game: I throw a dice. If the result is four, I throw two more dice; otherwise I throw one dice only. Looking at each newly thrown dice (one or two), I repeat the same, for a total of three rounds. Afterwards, I pay you the sum of the values on the faces of the dice. How much are you willing to pay to play this game with me?
Many examples of practical interest exhibit a complex random interdependency between outcomes. The cornerstone of modern probability as proposed by Kolmogorov aims to remove this complexity by separating the randomness from the mechanism that produces the outcome.
Instead of rolling the dice one by one, imagine that sufficiently many dice were rolled before the game has even started. For our game we need to roll seven dice, because this is the maximum number that might be required (one in the first round, two in the second round and four in the third round. See Fig. 2.1).

2.1 Probability Spaces and Random Elements

19

X1 := throw()

No X1 = 4? Yes

X21 := throw()

X21 := throw()

X22 := throw()

Figure 2.1 The initial phase of a gambling game with a random number of dice rolls. Depending on the outcome of a dice roll, one or two dice are rolled for a total of three rounds. The number of dice used will then be random in the range of three to seven.
After all the dice are rolled, the game can be emulated by ordering the dice and revealing the outcomes sequentially. Then the value of the first dice in the chosen ordering is the outcome of the dice in the first round. If we see a four, we look at the next two dice in the ordering; otherwise we look at the single next dice.
By taking this approach, we get a simple calculus for the probabilities of all kinds of events. Rather than directly calculating the likelihood of each pay-off, we first consider the probability of any single outcome of the dice. Since there are seven dice, the set of all possible outcomes is  = {1, . . . , 6}7. Because all outcomes are equally probable, the probability of any    is (1/6)7. The probability of the game pay-off taking value v can then be evaluated by calculating the total probability assigned to all those outcomes    that would result in the value of v. In principle, this is trivial to do thanks to the separation of everything that is probabilistic from the rest. The set  is called the outcome space, and its elements are the outcomes. Fig. 2.2 illustrates this idea. Random outcomes are generated on the left, while on the right, various mechanisms are used to arrive at values; some of these values may be observed and some not.
There will be much benefit from being a little more formal about how we come up with the value of our artificial game. For this, note that the process by which the game gets its value is a function X that maps  to the reals (simply, X :   R). We find it ironic that functions of this type (from the outcome space to subsets of the reals) are called random variables. They are neither random nor variables in a programming language sense. The randomness is in the argument that X is acting on, producing randomly changing results. Later we will put a little more structure on random variables, but for now it suffices to think of them as maps from the outcome space to the reals.

2.1 Probability Spaces and Random Elements

20

Outcomes

Randomising device all randomness

Mechanisms

Figure 2.2 A key idea in probability theory is the separation of sources of randomness from game mechanisms. A mechanism creates values from the elementary random outcomes, some of which are visible for observers, while others may remain hidden.

We follow the standard convention in probability theory where random variables are denoted by capital letters. Be warned that capital letters are also used for other purposes as demanded by different conventions.
Pick some number v  N. What is the probability of seeing X = v? As described above, this probability is (1/6)7 times the size of the set X-1(v) = {   : X() = v}. The set X-1(v) is called the preimage of v under X. More generally, the probability that X takes its value in some set A  N is given by (1/6)7 times the cardinality of X-1(A) = {   : X()  A}, where we have overloaded the definition of X-1 to set-valued inputs.
Notice in the previous paragraph we only needed probabilities assigned to subsets of , regardless of the question asked. To make this a bit more general, let us introduce a map P that assigns probabilities to certain subsets of . The intuitive meaning of P is as follows. Random outcomes are generated in . The probability that an outcome falls into a set A   is P (A). If A is not in the domain of P, then there is no answer to the question of the probability of the outcome falling in A. But let's postpone the discussion of why P should be restricted to only certain subsets of  later. In the above example with the dice, the set of subsets in the domain of P is not restricted and, in particular, for any subset A  , P (A) = (1/6)7|A|.
The probability of seeing X taking the value of v is thus P X-1(v) . To minimise clutter, the more readable notation for this is P (X = v). But always keep in mind that this familiar form is just a shorthand for P X-1(v) . More generally, we also use
P (predicate(U, V, . . . )) = P ({   : predicate(U (), V (), . . . ) is true})

2.1 Probability Spaces and Random Elements

21

with any predicate (an expression evaluating to true or false) where U, V, . . . are
functions with domain . What properties should P satisfy? Since  is the set of all possible outcomes,
it seems reasonable to expect that P is defined for  and P() = 1 and since  contains no outcomes, P() = 0 is also expected to hold. Furthermore, probabilities should be non-negative so P(A)  0 for any A   on which P is defined. Let Ac =  \ A be the complement of A. Then we should expect that P is defined for A exactly when it is defined for Ac and P(Ac) = 1 - P(A) (negation rule). Finally, if A, B are disjoint so that A  B =  and P(A), P(B) and P(A  B) are all defined, then P(A  B) = P(A) + P(B). This is called the finite additivity property.
Let F be the set of subsets of  on which P is defined. It would seem silly if A  F and Ac / F , since P(Ac) could simply be defined by P(Ac) = 1 - P(A). Similarly, if P is defined on disjoint sets A and B, then it makes sense if AB  F. We will also require the additivity property to hold (i) regardless of whether the sets are disjoint and (ii) even for countably infinitely many sets. If {Ai}i is a collection of sets and Ai  F for all i  N, then iAi  F , and if these sets are pairwise disjoint, P(iAi) = i P(Ai). A set of subsets that satisfies all these properties is called a -algebra, which is pronounced `sigma-algebra' and
sometimes also called a -field (see Note 1).
Definition 2.1 (-algebra and probability measures). A set F  2 is a algebra if   F and Ac  F for all A  F and iAi  F for all {Ai}i with Ai  F for all i  N. That is, it should include the whole outcome space and be closed under complementation and countable unions. A function P : F  R is a probability measure if P() = 1 and for all A  F, P(A)  0 and P(Ac) = 1 - P(A) and P(iAi) = i P(Ai) for all countable collections of disjoint sets {Ai}i with Ai  F for all i. If F is a -algebra and G  F is also a -algebra, then we say G is a sub--algebra of F. If P is a measure defined on F, then the restriction of P to G is a measure P|G on G defined by P|G(A) = P(A) for all A  G.
At this stage, the reader may rightly wonder about why we introduced the notion
of sub--algebras. The answer should become clear quite soon. The elements of F are called measurable sets. They are measurable in the sense that P assigns values to them. The pair (, F) alone is called a measurable space, while the triplet (, F, P) is called a probability space. If the condition that P() = 1 is lifted, then P is called a measure. If the condition that P(A)  0 is also lifted, then P is called a signed measure. For measures and signed measures, it would be unusual to use the symbol P, which is mostly reserved for probabilities. Probability measures are also called probability distributions,
or just distributions.
Random variables lead to new probability measures. In particular, in the example above PX (A) = P X-1(A) is a probability measure defined for all the subsets A of R for which P X-1(A) is defined. More generally, for a random

2.1 Probability Spaces and Random Elements

22

variable X, the probability measure PX is called the law of X, or the pushforward measure of P under X.
The significance of the push-forward measure PX is that any probabilistic question concerning X can be answered from the knowledge of PX alone. Even  and the details of the map X are not needed. This is often used as an excuse to not even mention the underlying probability space (, F, P).
If we keep X fixed but change P (for example, by switching to loaded dice), then the measure induced by X changes. We will often use arguments that do exactly this, especially when proving lower bounds on the limits of how well bandit algorithms can perform.
The astute reader would have noticed that we skipped over some details. Measures are defined as functions from a -algebra to R, so if we want to call PX a measure, then its domain {A  R : X-1(A)  F } better be a -algebra. This holds in great generality. You will show in Exercise 2.3 that for functions X :   X with X arbitrary, the collection {A  X : X-1(A)  F } is a -algebra.
It will be useful to generalise our example a little by allowing X to take on values in sets other than the reals. For example, the range could be vectors or abstract objects like sequences. Let (, F) be a measurable space, X be an arbitrary set and G  2X . A function X :   X is called an F /G-measurable map if X-1(A)  F for all A  G. Note that G need not be a -algebra. When F and G are obvious from the context, X is called a measurable map. What are the typical choices for G? When X is real-valued, it is usual to let G = {(a, b) : a < b with a, b  R} be the set of all open intervals. The reader can verify that if X is F/G-measurable, then it is also F/(G)-measurable, where (G) is the smallest -algebra that contains G. This smallest -algebra can be shown to exist. Furthermore, it contains exactly those sets A that are in every -algebra that contains G (see Exercise 2.5). When G is the set of open intervals, (G) is usually denoted by B or B(R) and is called the Borel -algebra of R. This definition is extended to Rk by replacing open intervals with open rectangles of the form ik=1(ai, bi), where a < b  Rk. If G is the set of all such open rectangles, then (G) is the Borel -algebra: B(Rk). More generally, the Borel -algebra of a topological space X is the -algebra generated by the open sets of X.
Definition 2.2 (Random variables and elements). A random variable (random vector) on measurable space (, F) is a F/B(R)-measurable function X :   R (respectively F /B(Rk)-measurable function X :   Rk). A random element between measurable spaces (, F) and (X , G) is a F/G-measurable function X :   X .
Thus, random vectors are random elements where the range space is

2.1 Probability Spaces and Random Elements

23

(Rk, B(Rk)), and random vectors are random variables when k = 1. Random elements generalise random variables and vectors to functions that do not take values in Rk. The push-forward measure (or law) can be defined for any random element. Furthermore, random variables and vectors work nicely
together. If X1, . . . , Xk are k random variables on the same domain (, F ), then X() = (X1(), . . . , Xk()) is an Rk-valued random vector, and vice versa (Exercise 2.2). Multiple random variables X1, . . . , Xk from the same measurable space can thus be viewed as a random vector X = (X1, . . . , Xk).
Given a map X :   X between measurable spaces (, F) and (X , G), we let (X) = {X-1(A) : A  G} be the -algebra generated by X. The map X is
F/G-measurable if and only if (X)  F. By checking the definitions one can
show that (X) is a sub--algebra of F and in fact is the smallest sub--algebra
for which X is measurable. If G = (A) itself is generated by a set system A  2X , then to check the F/G-measurability of X, it suffices to check whether X-1(A) = {X-1(A) : A  A} is a subset of F . The reason this is sufficient is because (X-1(A)) = X-1((A)), and by definition the latter is (X). In fact,
to check whether a map is measurable, either one uses the composition rule or checks X-1(A)  F for a `generator' A of G.
Random elements can be combined to produce new random elements by
composition. One can show that if f is F/G-measurable and g is G/H-measurable
for -algebras F, G and H over appropriate spaces, then their composition g  f
is F/H-measurable (Exercise 2.1). This is used most often for Borel functions, which is a special name for B(Rm)/B(Rn)-measurable functions from Rm to Rn. These functions are also called Borel measurable. The reader will find it pleasing that all familiar functions are Borel. First and foremost, all continuous
functions are Borel, which includes elementary operations such as addition and
multiplication. Continuity is far from essential, however. In fact one is hard-
pressed to construct a function that is not Borel. This means the usual operations
are `safe' when working with random variables.

Indicator Functions
Given an arbitrary set  and A  , the indicator function of A is IA :   {0, 1} given by

IA() =

1, 0,

if   A ; otherwise .

Sometimes A has a complicated description, and it becomes convenient to abuse notation by writing I {  A} instead of IA(). Similarly, we will often write I {predicate(X, Y, . . .)} to mean the indicator function of the subset of  on which the predicate is true. It is easy to check that an indicator function IA is a random variable on (, F) if and only if A is measurable: A  F.

2.1 Probability Spaces and Random Elements

24

Why So Complicated? You may be wondering why we did not define P on the power set of , which is equivalent to declaring that all sets are measurable. In many cases this is a perfectly reasonable thing to do, including the example game where nothing prevents us from defining F = 2. However, beyond this example, there are two justifications not to have F = 2, the first technical and the second conceptual.
The technical reason is highlighted by the following surprising theorem according to which there does not exist a uniform probability distribution on  = [0, 1] if F is chosen to be the power set of  (a uniform probability distribution over [0, 1], if existed, would have the property of assigning its length to every interval). In other words, if you want to be able to define the uniform measure, then F cannot be too large. By contrast, the uniform measure can be defined over the Borel -algebra, though proving this is not elementary.
Theorem 2.3. Let  = [0, 1], and F be the power set of . Then there does not exist a measure P on (, F) such that P([a, b]) = b - a for all 0  a  b  1.
The main conceptual reason of why not to have F = 2 is because then we can use -algebras to represent information. This is especially useful in the study of bandits where the learner is interacting with an environment and is slowly gaining knowledge. One useful way to represent this is by using a sequence of nested -algebras, as we explain in the next section. One might also be worried that the Borel -algebra does not contain enough measurable sets. Rest assured that this is not a problem and you will not easily find a non-measurable set. For completeness, an example of a non-measurable set will still be given in the notes, along with a little more discussion on this topic.
A second technical reason to prefer the measure-theoretic approach to probabilities is that this approach allows for the unification of distributions on discrete spaces and densities on continuous ones (the uninitiated reader will find the definitions of these later). This unification can be necessary when dealing with random variables that combine elements of both, e.g. a random variable that is zero with probability 1/2 and otherwise behaves like a standard Gaussian. Random variables like this give rise to so-called "mixed continuous and discrete distributions", which seem to require special treatment in a naive approach to probabilities, yet dealing with random variables like these are nothing but ordinary under the measure-theoretic approach.

From Laws to Probability Spaces and Random Variables

A big `conspiracy' in probability theory is that probability spaces are seldom

mentioned in theorem statements, despite the fact that a measure cannot be

defined without one. Statements are instead given in terms of random elements

and constraints on their joint probabilities. For example, suppose that X and Y

are random variables such that

P (X



A, Y

 B)

=

|A  [6]| 6

·

|B  [2]| 2

for all A, B  B(R) , (2.1)

2.1 Probability Spaces and Random Elements

25

which represents the joint distribution for the values of a dice (X  [6]) and coin (Y  [2]). The formula describes some constraints on the probabilistic interactions between the outputs of X and Y , but says nothing about their domain. In a way, the domain is an unimportant detail. Nevertheless, one must ask whether or not an appropriate domain exists at all. More generally, one may ask whether an appropriate probability space exists given some constraints on the joint law of a collection X1, . . . , Xk of random variables. For this to make sense, the constraints should not contradict each other, which means there is a probability measure µ on B(Rk) such that µ satisfies the postulated constraints. But then we can choose  = Rk, F = B(Rk), P = µ and Xi :   R to be the ith coordinate map: Xi() = i. The push-forward of P under X = (X1, . . . , Xk) is µ, which by definition is compatible with the constraints.
A more specific question is whether for a particular set of constraints on the joint law there exists a measure µ compatible with the constraints. Very often the constraints are specified for elements of the cartesian product of finitely many -algebras, like in Eq. (2.1). If (1, F1), . . . , (n, Fn) are measurable spaces, then the cartesian product of F1, . . . Fn is
F1 × · · · × Fn = {A1 × · · · × An : A1  F1, . . . , An  Fn}  21×···×n .

Elements of this set are known as measurable rectangles in 1 × · · · × n.

Theorem 2.4 (Carath´eodory's extension theorem). Let (1, F1), . . . , (n, Fn) be measurable spaces and µ¯ : F1 × · · · × Fn  [0, 1] be a function such that

(a) µ¯(1 × · · · × n) = 1; and

(b) µ¯( k=1Ak) =

 k=1

µ¯(Ak )

for

al l

sequences

of

disjoint

sets

with

Ak



F1 × · · · × Fn.

Let  = 1 × · · · × n and F = (F1 × · · · × Fn). Then there exists a unique probability measure µ on (, F ) such that µ agrees with µ¯ on F1 × · · · × Fn.

The theorem is applied by letting k = R and Fk = B(R). Then the values of a measure on all cartesian products uniquely determines its value everywhere.

It is not true that F1 ×F2 = (F1 ×F2). Take, for example, F1 = F2 = 2{1,2}. Then, |F1 × F2| = 1 + 3 × 3 = 10 (because  × X = ), while, since F1 × F2 includes the singletons of 2{1,2}×{1,2}, (F1 × F2) = 2{1,2}×{1,2}. Hence, six sets are missing from F1 × F2. For example, {(1, 1), (2, 2)}  (F1 × F2) \ F1 × F2.

The -algebra (F1 × · · · × Fn) is called the product -algebra of (Fk)k[n] and is also denoted by F1  · · ·  Fn. The product operation turns out to be
associative: (F1  F2)  F3 = F1  (F2  F3), which justifies writing F1  F2  F3. As it turns out, things work out well again with Borel -algebras: for p, q  N+, B(Rp+q) = B(Rp)  B(Rq). Needless to say, the same holds when there are more

2.2 -Algebras and Knowledge

26

than two terms in the product. The n-fold product -algebra of F is denoted by F n.

2.2 -algebras and knowledge

One of the conceptual advantages of measure-theoretic probability is the relationship between -algebras and the intuitive idea of `knowledge'. Although the relationship is useful and intuitive, it is regrettably not quite perfect. Let (, F), (X , G) and (Y, H) be measurable spaces and X :   X and Y :   Y be random elements. Having observed the value of X (`knowing X'), one might wonder what this entails about the value of Y . Even more simplistically, under what circumstances can the value of Y be determined exactly having observed X? The situation is illustrated in Fig. 2.3. As it turns out, with some restrictions, the answer can be given in terms of the -algebras generated by X and Y . Except

(, F)

X

(X , G)

f Y
(Y, H)

Figure 2.3 The factorisation problem asks whether there exists a (measurable) function f that makes the diagram commute.
for a technical assumption on (Y, H), the following result shows that Y is a measurable function of X if and only if Y is (X)/H-measurable. The technical assumption mentioned requires (Y, H) to be a Borel space, which is true of all probability spaces considered in this book, including (Rk, B(Rk)). We leave the exact definition of Borel spaces to the next chapter.
Lemma 2.5 (Factorisation lemma). Assume that (Y, H) is a Borel space. Then Y is (X)-measurable ((Y )  (X)) if and only if there exists a G/H-measurable map f : X  Y such that Y = f  X.
In this sense (X) contains all the information that can be extracted from X via measurable functions. This is not the same as saying that Y can be deduced from X if and only if Y is (X)-measurable because the set of X  Y maps can be much larger than the set of G/H-measurable functions. When G is coarse, there are not many G/H-measurable functions with the extreme case occurring when G = {X , }. In cases like this, the intuition that (X) captures all there is to know about X is not true anymore (Exercise 2.6). The issue is that (X) does not only depend on X, but also on the -algebra of (X , G) and that if G is coarse-grained, then (X) can also be coarse-grained and not many functions will be (X)-measurable. If X is a random variable, then by definition X = R

2.2 -Algebras and Knowledge

27

and G = B(R), which is relatively fine-grained, and the requirement that f be measurable is less restrictive. Nevertheless, even in the nicest setting where  = X = Y = R and F = G = H = B(R), it can still occur that Y = f  X for some non-measurable f . In other words, all the information about Y exists in X
but cannot be extracted in a measurable way. These problems only occur when X maps measurable sets in  to non-measurable sets in X . Fortunately, while
such random variables exist, they are never encountered in applications, which
provides the final justification for thinking of (X) as containing all that there is
to know about any random variable X that one may ever expect to encounter.

Filtrations

In the study of bandits and other online settings, information is revealed to the

learner sequentially. Let X1, . . . , Xn be a collection of random variables on a common measurable space (, F). We imagine a learner is sequentially observing

the values of these random variables. First X1, then X2 and so on. The learner

needs to make a prediction, or act, based on the available observations. Say, a

pXr1e:dt i=c.ti(oXn1o,r.

an ..,

act must produce a Xt), the set of maps

real-valued response. f  X1:t where f : Rt

Then, having  R is Borel,

observed captures

all the possible ways the learner can respond. By Lemma 2.5, this set contains

exactly the (X1:t)/B(R)-measurable maps. Thus, if we need to reason about the set of   R maps available after observing X1:t, it suffices to concentrate on the -algebra Ft = (X1:t). Conveniently, Ft is independent of the space of

possible responses, and being a subset of F, it also hides details about the range

space of X1:t. It is easy to check that F0  F1  F2  · · ·  Fn  F , which means that more and more functions are becoming Ft-measurable as t increases,

which corresponds to increasing knowledge (note that F0 = {, }, and the set of F0-measurable functions is the set of constant functions on ).

Bringing these a little further, we will often find it useful to talk about increasing

sequences of -algebras without constructing them in terms of random variables

as above. Given a measurable space (, F ), a filtration is a sequence (Ft)tn=0 of sub--algebras of F where Ft  Ft+1 for all t < n. We also allow n = , and in

this case we define

F = 


Ft
t=0

to be the smallest -algebra containing the union of all Ft. Filtrations can also
be defined in continuous time, but we have no need for that here. A sequence of random variables (Xt)tn=1 is adapted to filtration F = (Ft)tn=0 if Xt is Ftmeasurable for each t. We also say in this case that (Xt)t is F-adapted. The same nomenclature applies if n is infinite. Finally, (Xt)t is F-predictable if Xt is Ft-1-measurable for each t  [n]. Intuitively we may think of an F-predictable process X = (Xt)t as one that has the property that Xt can be known (or `predicted') based on Ft-1, while a F-adapted process is one that has the property that Xt can be known based on Ft only. Since Ft-1  Ft, a predictable process

2.3 Conditional Probabilities

28

is also adapted. A filtered probability space is the tuple (, F, F, P), where (, F , P) is a probability space and F = (Ft)t is filtration of F .

2.3 Conditional Probabilities

Conditional probabilities are introduced so that we can talk about how

probabilities should be updated when one gains some partial knowledge about a random outcome. Let (, F, P) be a probability space, and let A, B  F be such that P (B) > 0. The conditional probability P (A | B) of A given B is defined

as

P (A | B)

=

P

(A  B) P (B)

.

We can think about the outcome    as the result of throwing a many-sided dice. The question asked is the probability that the dice landed so that   A given that it landed with   B. The meaning of the condition   B is that we focus on dice rolls when   B is true. All dice rolls when   B does not hold are discarded. Intuitively, what should matter in the conditional probability of A given B is how large the portion of A is that lies in B, and this is indeed what the definition means.

The importance of conditional probabilities is that they define a calculus of how probabilities are to be updated in the presence of extra information.

The probability P (A | B) is also called the a posteriori (`after the fact') probability of A given B. The a priori probability is P (A). Note that P (A | B) is defined for every A  F as long as P (B) > 0. In fact, A  P (A | B) is a probability measure over the measure space (, F) called the a posteriori probability measure given B (see Exercise 2.7). In a way the temporal characteristics attached to the words `a posteriori' and `a priori' can be a bit misleading. Probabilities are concerned with predictions. They express the degrees of uncertainty one assigns to future events. The conditional probability of A given B is a prediction of certain properties of the outcome of the random experiment that results in  given a certain condition. Everything is related to a future hypothetical outcome. Once the dice is rolled,  gets fixed, and either   A, B or not. There is no uncertainty left: predictions are trivial after an experiment is done.
Bayes rule states that provided events A, B  F both occur with positive probability,

P (A | B)

=

P (B | A) P P (B)

(A)

.

(2.2)

Bayes rule is useful because it allows one to obtain P (A | B) based on information about the quantities on the right-hand side. Remarkably, this happens to be

2.4 Independence

29

the case quite often, explaining why this simple formula has quite a status in probability and statistics. Exercise 2.8 asks the reader to verify this law.

2.4 Independence

Independence is another basic concept of probability that relates to
knowledge/information. In its simplest form, independence is a relation that holds between events on a probability space (, F, P). Two events A, B  F are independent if

P (A  B) = P (A) P (B) .

(2.3)

How is this related to knowledge? Assuming that P (B) > 0, dividing both sides by P (B) and using the definition of conditional probability, we get that the above is equivalent to

P (A | B) = P (A) .

(2.4)

Of course, we also have that if P (A) > 0, (2.3) is equivalent to P (B | A) = P (B). Both of the latter relations express that A and B are independent if the probability assigned to A (or B) remains the same regardless of whether it is known that B (respectively, A) occurred.
We hope our readers will find the definition of independence in terms of a `lack of influence' to be sensible. The reason not to use Eq. (2.4) as the definition is mostly for the sake of convenience. If we started with (2.4), we would need to separately discuss the case of P (B) = 0, which would be cumbersome. A second reason is that (2.4) suggests an asymmetric relationship, but intuitively we expect independence to be symmetric.
Uncertain outcomes are often generated part by part with no interaction between the processes, which naturally leads to an independence structure (think of rolling multiple dice with no interactions between the rolls). Once we discover some independence structure, calculations with probabilities can be immensely simplified. In fact, independence is often used as a way of constructing probability measures of interest (cf. Eq. (2.1), Theorem 2.4 and Exercise 2.9). Independence can also appear serendipitously in the sense that a probability space may hold many more independent events than its construction may suggest (Exercise 2.10).

You should always carefully judge whether assumptions about independence are really justified. This is part of the modelling and hence is not mathematical in nature. Instead you have to think about the physical process being modelled.

A collection of events G  F is said to be pairwise independent if any two distinct elements of G are independent of each other. The events in G are said

2.5 Integration and Expectation

30

to be mutually independent if for any n > 0 integer and A1, . . . , An distinct

elements of G, P (A1  · · ·  An) =

n i=1

P

(Ai).

This

is

a

stronger

restriction

than pairwise independence. In the case of mutually independent events, the

knowledge of joint occurrence of any finitely many events from the collection will

not change our prediction of whether some other event in the collection happens.

But this may not be the case when the events are only pairwise independent

(Exercise 2.10). Two collections of events G1, G2 are said to be independent of

each other if for any A  G1 and B  G2 it holds that A and B are independent.

This definition is often applied to -algebras.

When the -algebras are induced by random variables, this leads to the

definition of independence between random variables. Two random

variables X and Y are independent if (X) and (Y ) are independent of each

other. The notions of pairwise and mutual independence can also be naturally

extended to apply to collections of random variables. All these concepts can be

and are in fact extended to random elements.

The default meaning of independence when multiple events or random variables

are involved is mutual independence.

When we say that X1, . . . , Xn are independent random variables, we mean that they are mutually independent. Independence is always relative to some probability measure, even when a probability measure is not explicitly mentioned. In such cases the identity of the probability measure should be clear from the context.

2.5 Integration and Expectation
A key quantity in probability theory is the expectation of a random variable. Fix a probability space (, F, P) and random variable X :   R. The expectation X is often denoted by E [X]. This notation unfortunately obscures the dependence on the measure P. When the underlying measure is not obvious from context, we write EP to indicate the expectation with respect to P. Mathematically, we define the expected value of X as its Lebesgue integral with respect to P:
E [X] = X() dP() .

The right-hand side is also often abbreviated to X dP. The integral on the right-hand side is constructed to satisfy the following two key properties:
(a) The integral of indicators is the probability of the underlying event. If X() = I {  A} is an indicator function for some A  F, then XdP = P (A).
(b) Integrals are linear. For all random variables X1, X2 and reals 1, 2 such

2.5 Integration and Expectation

31

that X1dP and X2dP are defined, (1X1 + 2X2)dP is defined and satisfies

(1X1 + 2X2) dP = 1 X1 dP + 2 X2 dP .







(2.5)

These two properties together tell us that whenever X() =

n i=1

iI {



Ai}

for some n, i  R and Ai  F , i = 1, . . . , n, then

XdP = iP (Ai) .



i

(2.6)

Functions of the form X are called simple functions. In defining the Lebesgue integral of some random variable X, we use (2.6) as
the definition of the integral when X is a simple function. The next step is to extend the definition to non-negative random variables. Let X :   [0, ) be measurable. The idea is to approximate X from below using simple functions and take the largest value that can be obtained this way:

XdP = sup h dP : h is simple and 0  h  X .





(2.7)

The meaning of U  V for random variables U, V is that U ()  V () for all
  . The supremum on the right-hand side could be infinite, in which case we
say the integral of X is not defined. Whenever the integral of X is defined, we say that X is integrable or, if the identity of the measure P is unclear, that X is integrable with respect to P.
Integrals for arbitrary random variables are defined by decomposing the random variable into positive and negative parts. Let X :   R be any measurable function. Then define X+() = X()I {X() > 0} and X-() = -X()I {X() < 0} so that X() = X+() - X-(). Now X+ and X- are both non-negative random variables called the positive and negative parts of X. Provided that both X+ and X- are integrable, we define

XdP = X+dP - X-dP .







Note that X is integrable if and only if the non-negative-valued random variable |X| is integrable (Exercise 2.12).

None of what we have done depends on P being a probability measure. The definitions hold for any measure, though for signed measures it is necessary to split  into disjoint measurable sets on which the measure is positive/negative, an operation that is possible by the Hahn decomposition theorem. We will never need signed measures in this book, however.

A particularly interesting case is when  = R is the real line, F = B(R) is the Borel -algebra and the measure is the Lebesgue measure , which is the

2.5 Integration and Expectation

32

unique measure on B(R) such that ((a, b)) = b - a for any a  b. In this scenario, if f : R  R is a Borel-measurable function, then we can write the Lebesgue integral of f with respect to the Lebesgue measure as

f d .

R

Perhaps unsurprisingly, this almost always coincides with the improper Riemann

integral of f , which is normally written as

 -

f (x)dx.

Precisely,

if

|f |

is

both

Lebesgue integrable and Riemann integrable, then the integrals are equal.

There exist functions that are Riemann integrable and not Lebesgue integrable, and also the other way around (although examples of the former are more exotic than the latter).

The Lebesgue measure and its relation to Riemann integration is mentioned because when it comes to actually calculating the value of an expectation or integral, this is often reduced to calculating integrals over the real line with respect to the Lebesgue measure. The calculation is then performed by evaluating the Riemann integral, thereby circumventing the need to rederive the integral of many elementary functions. Integrals (and thus expectations) have a number of important properties. By far the most important is their linearity, which was postulated above as the second property in (2.5). To practice using the notation with expectations, we restate the first half of this property. In fact, the statement is slightly more general than what we demanded for integrals above.
Proposition 2.6. Let (Xi)i be a (possibly infinite) sequence of random variables on the same probability space and assume that E [Xi] exists for all i and furthermore that X = i Xi and E [ i |Xi|] also exist. Then
E [X] = E [Xi] .
i
This exchange of expectations and summation is the source of much magic in probability theory because it holds even if Xi are not independent. This means that (unlike probabilities) we can very often decouple the expectations of dependent random variables, which often proves extremely useful (a collection of random variables is dependent if they are not independent). You will prove Proposition 2.6 in Exercise 2.14. The other requirement for linearity is that if c  R is a constant, then E [cX] = c E [X] (Exercise 2.15).
Another important statement is concerned with independent random variables.
Proposition 2.7. If X and Y are independent, then E [XY ] = E [X] E [Y ].
In general E [XY ] = E [X] E [Y ] (Exercise 2.18). Finally, an important simple result connects expectations of non-negative random variables to their tail probabilities.

2.6 Conditional Expectation

33

Proposition 2.8. If X  0 is a non-negative random variable, then

E [X] = P (X > x) dx .
0
The integrand in Proposition 2.8 is called the tail probability function x  P (X > x) of X. This is also known as the complementary cumulative distribution function of X. The cumulative distribution function (CDF) of X is defined as x  P (X  x) and is usually denoted by FX . These functions are defined for all random variables, not just non-negative ones. One can check that FX : R  [0, 1] is increasing, right continuous and limx- FX (x) = 0 and limx FX (x) = 1. The CDF of a random variable captures every aspect of the probability measure PX induced by X, while still being just a function on the real line, a property that makes it a little more human friendly than PX . One can also generalise CDFs to random vectors: if X is an Rk-valued random vector, then its CDF is defined as the FX : Rk  [0, 1] function that satisfies FX (x) = P (X  x), where, in line with our conventions, X  x means that all components of X are less than or equal to the respective component of x. The pushforward PX of a random element is an alternative way to summarise the distribution of X. In particular, for any real-valued, f : X  R measurable function,
E [f (X)] = f (x)dPX (x)
X
provided that either the right-hand side, or the left-hand side exist.
2.6 Conditional Expectation
Conditional expectation allows us to talk about the expectation of a random variable given the value of another random variable, or more generally, given some -algebra.
Example 2.9. Let (, F, P) model the outcomes of an unloaded dice:  = [6], F = 2 and P(A) = |A|/6. Define two random variables X and Y by Y () = I { > 3} and X() = . Suppose we are interested in the expectation of X given a specific value of Y . Arguing intuitively, we might notice that Y = 1 means that the unobserved X must be either 4, 5 or 6, and that each of these outcomes is equally likely, and so the expectation of X given Y = 1 should be (4 + 5 + 6)/3 = 5. Similarly, the expectation of X given Y = 0 should be (1 + 2 + 3)/3 = 2. If we want a concise summary, we can just write that `the expectation of X given Y ' is 5Y + 2(1 - Y ). Notice how this is a random variable itself.
The notation for this conditional expectation is E [X | Y ]. Using this notation, in Example 2.9 we can concisely write E [X | Y ] = 5Y + 2(1 - Y ). A little more generally, if X :   X and Y :   Y with X , Y  R and |X |, |Y| < , then

2.6 Conditional Expectation

34

E[X | Y ] :   R is the random variable given by E[X | Y ]() = E[X | Y = Y ()], where

E[X | Y

= y] = x P (X
xX

= x|Y

= y) =
xX

x

P

(X = P (Y

x, =

Y= y)

y)

.

(2.8)

This is undefined when P(Y = y) = 0 so that E[X | Y ]() is undefined on the measure zero set { : P(Y = Y ()) = 0}.

Eq. (2.8) does not generalise to continuous random variables because P (Y = y)

in the denominator might be zero for all y. For example, let Y be a random

variable taking values on [0, 1] according to a uniform distribution and X  {0, 1}

be Bernoulli with bias Y . This means that the joint measure on X and Y is

P (X = 1, Y  [p, q]) =

q p

xdx

for

0



p

<

q



1.

Intuitively

it

seems

like

E[X

|

Y

]

should be equal to Y , but how to define it? The mean of a Bernoulli random

variable is equal to its bias so the definition of conditional probability shows that

for 0  p < q  1,

E[X = 1 | Y  [p, q]] = P (X = 1 | Y  [p, q])

=

P (X = 1, Y  [p, q]) P (Y  [p, q])

=

q2 - p2 2(q - p)

=

p+q 2

.

This calculation is not well defined when p = q because P (Y  [p, p]) = 0.

Nevertheless, letting q = p +  for  > 0 and taking the limit as  tends to zero seems like a reasonable way to argue that P (X = 1 | Y = p) = p. Unfortunately

this approach does not generalise to abstract spaces because there is no canonical

way of taking limits towards a set of measure zero, and different choices lead to

different answers.

Instead we use Eq. (2.8) as the starting point for an abstract definition of

conditional expectation as a random variable satisfying two requirements. First, from Eq. (2.8) we see that E[X | Y ]() should only depend on Y () and so

should be measurable with respect to (Y ). The second requirement is called the

`averaging property'. For measurable A  Y, Eq. (2.8) shows that

E[IY -1(A)E[X | Y ]] = P (Y = y) E[X | Y = y]
yA

=

x P (X = x, Y = y)

yA xX

= E[IY -1(A)X] .

This can be viewed as putting a set of linear constraints on E[X | Y ] with one constraint for each measurable A  Y. By treating E[X | Y ] as an unknown (Y )-measurable random variable, we can attempt to solve this linear system. As

2.6 Conditional Expectation

35

it turns out, this can always be done: the linear constraints and the measurability restriction on E [X | Y ] completely determine E[X | Y ] except for a set of measure zero. Notice that both conditions only depend on (Y )  F. The abstract definition of conditional expectation takes these properties as the definition and replaces the role of Y with a sub--algebra.
Definition 2.10 (Conditional expectation). Let (, F, P) be a probability space and X :   R be random variable and H be a sub--algebra of F. The conditional expectation of X given H is denoted by E[X | H] and defined to be any H-measurable random variable on  such that for all H  H,

E[X | H]dP = XdP .

H

H

(2.9)

Given a random variable Y , the conditional expectation of X given Y is E [X | Y ] = E [X | (Y )].

Theorem 2.11. Given any probability space (, F, P), a sub--algebra H of F and a P-integrable random variable X :   R, there exists an H-measurable function f :   R that satisfies (2.9). Further, any two H-measurable functions f1, f2 :   R that satisfy (2.9) are equal with probability one: P(f1 = f2) = 1.

When random variables X and Y agree with P-probability one, we say they are P-almost surely equal, which is often abbreviated to `X = Y P-a.s.', or `X = Y a.s.' when the measure is clear from context. A related useful notion is the concept of null sets: U  F is a null set of P, or a P-null set if P(U ) = 0. Thus, X = Y P-a.s. if and only if X = Y agree except on a P-null set.

The reader may find it odd that E[X | Y ] is a random variable on  rather than the range of Y . Lemma 2.5 and the fact that E[X | (Y )] is (Y )measurable shows there exists a measurable function f : (R, B(R))  (R, B(R)) such that E[X | (Y )]() = (f  Y )() (see Fig. 2.4). In this sense E[X | Y ]() only depends on Y (), and occasionally we write E[X | Y ](y).

(, F)

Y

E[X | Y ]

(R, B(R))

(R, B(R))

f

Figure 2.4 Factorisation of conditional expectation. When there is no confusion, we occasionally write E[X | Y ](y) in place of f (y).

Returning to Example 2.9, we see that E [X | Y ] = E [X | (Y )] and (Y ) =

2.6 Conditional Expectation

36

{{1, 2, 3}, {4, 5, 6}, , }. Denote this set-system by H for brevity. The condition that E[X | H] is H-measurable can only be satisfied if E[X | H]() is constant on {1, 2, 3} and {4, 5, 6}. Then (2.9) immediately implies that
E [X | H] () = 2, if   {1, 2, 3} ; 5, if   {4, 5, 6} .
While the definition of conditional expectations given above is non-constructive and E[X | H] is uniquely defined only up to events of P-measure zero, none of this should be of a significant concern. First, we will rarely need closed-form expressions for conditional expectations, but we rather need how they relate to other expectations, conditional or not. This is also the reason why it should not be concerning that they are only determined up to zero probability events: usually, conditional expectations appear in other expectations or in statements that are concerned with how probable some event is, making the difference between the different `versions' of conditional expectations disappear.
We close the section by summarising some additional important properties of conditional expectations. These follow from the definition directly, and the reader is invited to prove them in Exercise 2.20.
Theorem 2.12. Let (, F , P) be a probability space, G, G1, G2  F be sub-algebras of F and X, Y integrable random variables on (, F, P). The following hold true:
1 If X  0, then E [X | G]  0 almost surely. 2 E [1 | G] = 1 almost surely. 3 E [X + Y | G] = E [X | G] + E [Y | G] almost surely. 4 E [XY | G] = Y E [X | G] almost surely if E [XY ] exists and Y is G-measurable. 5 If G1  G2, then E [X | G1] = E [E [X | G2] | G1] almost surely. 6 If (X) is independent of G2 given G1, then E [X | (G1  G2)] = E [X | G1]
almost surely. 7 If G = {, } is the trivial -algebra, then E [X | G] = E [X] almost surely.
Properties 1 and 2 are self-explanatory. Property 3 generalises the linearity of expectation. Property 4 shows that a measurable quantity can be pulled outside of a conditional expectation and corresponds to the property that for constants c, E [cX] = cE [X]. Property 5 is called the tower rule or the law of total expectations. It says that the fineness of E[X | G2] is obliterated when taking the conditional expectation with respect to G1. Property 6 relates independence and conditional expectations, and it says that conditioning on independent quantities does not give further information on expectations. Here, the two event systems A and B are said to be conditionally independent of each other given a -algebra F if for all A  A and B  B, P (A  B | F) = P (A | F) P (B | F) holds almost surely. We also often say that A is conditionally independent of B given F, but of course, this relation is symmetric. This property is often applied with random variables: X is said to be conditionally independent of Y given Z, if (X) is

2.7 Notes

37

conditionally independent of (Y ) given (Z). In this case, E [X | Y, Z] = E [X | Z] holds almost surely. Property 7 states that conditioning on no information gives the same expectation as not conditioning at all.
The above list of abstract properties will be used over and over again. We encourage the reader to study the list carefully and convince yourself that all items are intuitive. Playing around with discrete random variables can be invaluable for this. Eventually it will all become second nature.

2.7 Notes
1 The Greek letter  is often used by mathematicians in association with countable infinities. Hence the term -algebra (and -field). Note that countable additivity is often called -additivity. The requirement that additivity should hold for systems of countably infinitely many sets is made so that probabilities of (interesting) limiting events are guaranteed to exist.
2 Measure theory is concerned with measurable spaces, measures and with their properties. An obvious distinction between probability theory and measure theory is that in probability theory, one is (mostly) concerned with probability measures. But the distinction does not stop here. In probability theory, the emphasis is on the probability measures and their relations to each other. The measurable spaces are there in the background, but are viewed as part of the technical toolkit rather than the topic of main interest. Also, in probability theory, independence is often at the center of attention, while independence is not a property measure-theorists care much about.
3 In our toy example, instead of  = [6]7, we could have chosen  = [6]8 (considering rolling eight dice instead of seven, one dice never used). There are many other possibilities. We can consider coin flips instead of dice rolls (think about how this could be done). To make this easy, we could use weighted coins (for example, a coin that lands on heads with probability 1/6), but we don't actually need weighted coins (this may be a little tricky to see). The main point is that there are many ways to emulate one randomisation device by using another. The difference between these is the set . What makes a choice of  viable is if we can emulate the game mechanism on the top of  so that in the end the probability of seeing any particular value remains the same. But the main point is that the choice of  is far from unique. The same is true for the way we calculate the value of the game! For example, the dice could be reordered, if we stay with the first construction. This was noted already, but it cannot be repeated frequently enough: the biggest conspiracy in all probability theory is that we first make a big fuss about introducing , and then it turns out that the actual construction of  does not matter.

2.7 Notes

38

4 All Riemann-integrable functions on a bounded domain are Lebesgue integrable.

Difficulties only arise when taking improper integrals. A standard example

is

 0

sin(x)dx x

,

which

is

an

improper

Riemann

integrable

function,

but

is

not Lebesgue integrable because (0,) | sin(x)/x|dx = . The situation is

analogous to the difference between conditionally and absolutely convergent

series, with the Lebesgue integral only defined in the latter case.

5 Can you think of a set that is not Borel measurable? Such sets exist, but do not
arise naturally in applications. The classic example is the Vitali set, which is formed by taking the quotient group G = R/Q and then applying the axiom of choice to choose a representative in [0, 1] from each equivalence class in G.
Non-measurable functions are so unusual that you do not have to worry much about whether or not functions X : R  R are measurable. With only a few exceptions, questions of measurability arising in this book are not related to
the fine details of the Borel -algebra. Much more frequently they are related
to filtrations and the notion of knowledge available having observed certain
random elements.

6 There is a lot to say about why the sum, or the product of random variables are also random variables. Or why infn Xn, supn Xn, lim infn Xn, lim supn Xn are measurable when Xn are. The key point is to show that the composition of measurable maps is a measurable map and that continuous maps are measurable and then apply these results (Exercise 2.1). For lim supn Xn, just rewrite it as limm supnm Xn; note that supnm Xn is decreasing (we take suprema of smaller sets as m increases), hence lim supn Xn = infm supnm Xn, reducing the question to studying infn Xn and supn Xn. Finally, for infn Xn note that it suffices if { : infn Xn  t} is measurable for any t real. Now, infn Xn  t if and only if Xn  t for all n. Hence, { : infn Xn  t} = n{ : Xn  t}, which is a countable intersection of measurable sets, hence measurable (this latter follows by the elementary identity (iAi)c = iAic).
7 The factorisation lemma, Lemma 2.5, is attributed to Joseph Doob and Eugene Dynkin. The lemma sneakily uses the properties of real numbers (think about why), which is another reason why what we said about -algebras containing all information is not entirely true. The lemma has extensions to more general random elements [Taraldsen, 2018, for example]. The key requirement in a way is that the -algebra associated with the range space of Y should be rich enough.

8 We did not talk about basic results like Lebesgue's dominated/monotone convergence theorems, Fatou's lemma or Jensen's inequality. We will definitely use the last of these, which is explained in a dedicated chapter on convexity (Chapter 26). The other results can be found in the texts we cite. They are concerned with infinite sequences of random variables and conditions under which their limits can be interchanged with Lebesgue integrals. In this book we rarely encounter problems related to such sequences and hope you forgive us on the few occasions they are necessary (the reason is simply because we

2.7 Notes

39

mostly focus on finite time results or take expectations before taking limits when dealing with asymptotics). 9 You might be surprised that we have not mentioned densities. For most of us, our first exposure to probability on continuous spaces was by studying the normal distribution and its density

p(x) = 1 exp(-x2/2) , 2

(2.10)

which can be integrated over intervals to obtain the probability that a Gaussian
random variable will take a value in that interval. The reader should notice that p : R  R is Borel measurable and that the Gaussian measure associated with this density is P on (R, B(R)) defined by

P(A) = p d .

A

Here the integral is with respect to the Lebesgue measure  on (R, B(R)). The

notion of a density can be generalised beyond this simple setup. Let P and Q

be measures (not necessarily probability measures) on arbitrary measurable

space (, F). The Radon­Nikodym derivative of P with respect to Q is

an

F -measurable

random

variable

dP dQ

:





[0, )

such

that

P (A) =

A

dP dQ

dQ

for all A  F .

(2.11)

We can also write this in the form

IAdP =

IA

dP dQ

dQ,

A



F,

from

which

we

may realise that for any X P -integrable random variable,

XdP =

X

dP dQ

dQ

must also hold. This is often called the change-of-measure formula. Another

word

for

the

Radon­Nikodym

derivative

dP dQ

is

the

density

of

P

with

respect

to

Q. It is not hard to find examples where the density does not exist. We say that

P is absolutely continuous with respect to Q if Q(A) = 0 = P (A) = 0

for

all

A



F.

When

dP dQ

exists,

it

follows

immediately

that

P

is

absolutely

continuous with respect to Q by Eq. (2.11). Except for some pathological cases,

it turns out that this is both necessary and sufficient for the existence of dP/dQ.

The measure Q is -finite if there exists a countable covering {Ai} of  with

F -measurable sets such that Q(Ai) <  for each i.

Theorem 2.13. Let P, Q be measures on a common measurable space (, F)

and

assume

that

Q

is

-finite.

Then

the

density

of

P

with

respect

to

Q,

dP dQ

,

exists if and only if P is absolutely continuous with respect to Q. Furthermore,

dP dQ

is

uniquely

defined

up

to

a

Q-nul l

set

so

that

for

any

f1, f2

satisfying

(2.11),

f1 = f2 holds Q-almost surely.

Densities work as expected. Suppose that Z is a standard Gaussian random variable. We usually write its density as in Eq. (2.10), which we now know is the Radon­Nikodym derivative of the Gaussian measure with respect to the Lebesgue measure. The densities of `classical' continuous distributions are almost always defined with respect to the Lebesgue measure.

2.7 Notes

40

10 In line with the literature, we will use P Q to denote that P is absolutely

continuous with respect to Q. When P is absolutely continuous with respect

to Q, we also say that Q dominates P .

11 A useful result for Radon­Nikodym derivatives is the chain rule, which states

that if P

Q

S,

then

dP dQ

dQ dS

=

dP dS

.

The

proof

of

this

result

follows

from

our

earlier observation that

f dQ =

f

dQ dS

dS

for

any

Q-integrable

f.

Indeed,

the

chain

rule

is

obtained

from

this

by

taking

f

=

IA

dP dQ

with

A



F

and

noting

that this is indeed Q-integrable and

IA

dP dQ

dQ

=

IAdQ. The chain rule is

often used to reduce the calculation of densities to calculation with known

densities.

12 The Radon­Nikodym derivative unifies the notions of distribution (for discrete

spaces) and density (for continuous spaces). Let  be discrete (finite or countable) and let  be the counting measure on (, 2), which is defined

by (A) = |A|. For any P on (, F), it is easy to see that P  and

dP d

(i)

=

P ({i}),

which

is

sometimes

called

the

distribution

function

of

P.

13 The Radon­Nikodym derivative provides another way to define the conditional

expectation. Let X be an integrable random variable on (, F, P) and H  F

be a sub--algebra and P|H be the restriction of P to (, H). Define measure

µ on that

(, H) by µ(A)

E[X | H]

=

dµ dP|H

= A XdP|H. satisfies Eq.

It is easy (2.9). We

to check that µ P|H note that the proof of

and the

Radon­Nikodym theorem is nontrivial and that the existence of conditional

expectations are more easily guaranteed via an `elementary' but abstract

argument using functional analysis.

14 The Fubini­Tonelli theorem is a powerful result that allows one to exchange

the order of integrations. This result is needed for example for proving

Proposition 2.8 (Exercise 2.19). To state it, we need to introduce product measures. These work as expected: given two probability spaces, (1, F1, P1) and (2, F2, P2), the product measure P of P1 and P2 is defined as any measure on (1 × 2, F1  F2) that satisfies P(A1, A2) = P1(A1)P2(A2) for all (A1, A2)  F1 × F2 (recall that F1  F2 = (F1 × F2) is the product
-algebra of F1 and F2). Theorem 2.4 implies that this product measure, which is often denoted by P1 × P2 (or P1  P2) is uniquely defined. (Think
about what this product measure has to do with independence.) The Fubini­ Tonelli theorem (often just `Fubini') states the following: let (1, F1, P1) and (2, F2, P2) be two probability spaces and consider a random variable X on the product probability space (, F , P) = (1 × 2, F1  F2, P1 × P2). If any of the three integrals |X()| dP(), ( |X(1, 2)| dP1(1)) dP2(2),
( |X(1, 2)| dP2(2)) dP1(1) is finite, then

X() dP() =

X(1, 2) dP1(1) dP2(2)

=

X(1, 2) dP2(2) dP1(1) .

2.8 Bibliographic Remarks

41

15 For topological space X, the support of a measure µ on (X, B(X)) is
Supp(µ) = {x  X : µ(U ) > 0 for all neighborhoods U of x} .
When X is discrete, this reduces to Supp(µ) = {x : µ({x}) > 0}. 16 Let X be a topological space. The weak* topology on the space of probability
measures P(X) on (X, B(X)) is the coarsest topology such that µ  f dµ is continuous for all bounded continuous functions f : X  R. In particular, a sequence of probability measures (µn)n=1 converges to µ in this topology if and only if limn f dµn = f dµ for all bounded continuous functions f : X  R.
Theorem 2.14. When X is compact and Hausdorff and P(X) is the space of regular probability measures on (X, B(X)) with the weak* topology, then P(X) is compact.
17 Mathematical terminology can be a bit confusing sometimes. Since E maps (certain) functions to real values, it is also called the expectation operator. `Operator' is just a fancy name for a function. In operator theory, the study of operators, the focus is on operators whose domain is infinite dimensional, hence the distinct name. However, most results of operator theory do not hinge upon this property. If the image space is the set of reals, we talk about functionals. The properties of functionals are studied in yet another subfield of mathematics, functional analysis. The expectation operator is a functional that maps the set of P-integrable functions (often denoted by L1(, P) or L1(P)) to reals. Its most important property is linearity, which was stated as a requirement for integrals that define the expectation operator (Eq. (2.5)). In line with the previous comment, when we use E, more often than not, the probability space remains hidden. As such, the symbol E is further abused.
2.8 Bibliographic Remarks
Much of this chapter draws inspiration from David Pollard's A user's guide to measure theoretic probability [Pollard, 2002]. We like this book because the author takes a rigourous approach, but still explains the `why' and `how' with great care. The book gets quite advanced quite fast, concentrating on the big picture rather than getting lost in the details. Other useful references include the book by Billingsley [2008], which has many good exercises and is quite comprehensive in terms of its coverage of the `basics'. These books are both quite detailed. For an outstanding shorter introduction to measure-theoretic probability, see the book by Williams [1991], which has an enthusiastic style and a pleasant bias towards martingales. We also like the book by Kallenberg [2002], which is recommended for the mathematically inclined readers who already have a good understanding of the basics. The author has put a major effort into organising the material so that redundancy is minimised and generality is maximised. This reorganisation resulted

2.9 Exercises

42

in quite a few original proofs, and the book is comprehensive. The factorisation lemma (Lemma 2.5) is stated in the book by Kallenberg [2002] (Lemma 1.13 there). Kallenberg calls this lemma the `functional representation' lemma and attributes it to Joseph Doob. Theorem 2.4 is a corollary of Carath´eodory's extension theorem, which says that probability measures defined on semi-rings of sets have a unique extension to the generated -algebra. The remaining results can be found in either of the three books mentioned above. Theorem 2.14 appears as theorem 8.9.3 in the two-volume book by Bogachev [2007]. Finally, for something older and less technical, we recommend the philosophical essays on probability by Pierre Laplace, which was recently reprinted [Laplace, 2012].
2.9 Exercises
2.1 (Composing random elements) Show that if f is F/G-measurable and g is G/H-measurable for sigma algebras F, G and H over appropriate spaces, then their composition, g  f (defined the usual way: (g  f )() = g(f ()),   ), is F /H-measurable.
2.2 Let X1, . . . , Xn be random variables on (, F ). Prove that (X1, . . . , Xn) is a random vector.
2.3 (Random variable induced -algebra) Let U be an arbitrary set and (V, ) a measurable space and X : U  V an arbitrary function. Show that X = {X-1(A) : A  } is a -algebra over U .
2.4 Let (, F ) be a measurable space and A   and F|A = {A  B : B  F }.
(a) Show that (A, F|A) is a measurable space. (b) Show that if A  F , then F|A = {B : B  F , B  A}.
2.5 Let G  2 be a non-empty collection of sets and define (G) as the smallest -algebra that contains G. By `smallest' we mean that F  2 is smaller than F  2 if F  F .
(a) Show that (G) exists and contains exactly those sets A that are in every -algebra that contains G.
(b) Suppose ( , F) is a measurable space and X :    be F/G-measurable. Show that X is also F/(G)-measurable. (We often use this result to simplify the job of checking whether a random variable satisfies some measurability property).
(c) Prove that if A  F where F is a -algebra, then I {A} is F-measurable.
2.6 (Knowledge and -algebras: a pathological example) In the context of Lemma 2.5, show an example where Y = X and yet Y is not (X) measurable.
Hint As suggested after the lemma, this can be arranged by choosing

2.9 Exercises

43

 = Y = X = R, X() = Y () = , F = H = B(R) and G = {, R} to be the trivial -algebra.
2.7 Let (, F, P) be a probability space, B  F be such that P (B) > 0. Prove that A  P (A | B) is a probability measure over (, F).
2.8 (Bayes law) Verify (2.2).
2.9 Consider the standard probability space (, F, P) generated by two standard, unbiased, six-sided dice that are thrown independently of each other. Thus,  = {1, . . . , 6}2, F = 2 and P(A) = |A|/62 for any A  F so that Xi() = i represents the outcome of throwing dice i  {1, 2}.
(a) Show that the events `X1 < 2' and `X2 is even' are independent of each other.
(b) More generally, show that for any two events, A  (X1) and B  (X2), are independent of each other.
2.10 (Serendipitous independence) The point of this exercise is to understand independence more deeply. Solve the following problems:
(a) Let (, F, P) be a probability space. Show that  and  (which are events) are independent of any other event. What is the intuitive meaning of this?
(b) Continuing the previous part, show that any event A  F with P (A)  {0, 1} is independent of any other event.
(c) What can we conclude about an event A  F that is independent of its complement, Ac =  \ A? Does your conclusion make intuitive sense?
(d) What can we conclude about an event A  F that is independent of itself? Does your conclusion make intuitive sense?
(e) Consider the probability space generated by two independent flips of unbiased coins with the smallest possible -algebra. Enumerate all pairs of events A, B such that A and B are independent of each other.
(f) Consider the probability space generated by the independent rolls of two unbiased three-sided dice. Call the possible outcomes of the individual dice rolls 1, 2 and 3. Let Xi be the random variable that corresponds to the outcome of the ith dice roll (i  {1, 2}). Show that the events {X1  2} and {X1 = X2} are independent of each other.
(g) The probability space of the previous example is an example when the probability measure is uniform on a finite outcome space (which happens to have a product structure). Now consider any n-element, finite outcome space with the uniform measure. Show that A and B are independent of each other if and only if the cardinalities |A|, |B|, |A  B| satisfy n|A  B| = |A| · |B|.
(h) Continuing with the previous problem, show that if n is prime, then no non-trivial events are independent (an event A is trivial if P (A)  {0, 1}).
(i) Construct an example showing that pairwise independence does not imply mutual independence.

2.9 Exercises

44

(j) Is it true or not that A, B, C are mutually independent if and only if P (A  B  C) = P (A) P (B) P (C)? Prove your claim.
2.11 (Independence and random elements) Solve the following problems:
(a) Let X be a constant random element (that is, X() = x for any    over the outcome space over which X is defined). Show that X is independent of any other random variable.
(b) Show that the above continues to hold if X is almost surely constant (that is, P (X = x) = 1 for an appropriate value x).
(c) Show that two events are independent if and only if their indicator random variables are independent (that is, A, B are independent if and only if X() = I {  A} and Y () = I {  B} are independent of each other).
(d) Generalise the result of the previous item to pairwise and mutual independence for collections of events and their indicator random variables.
2.12 Our goal in this exercise is to show that X is integrable if and only if |X| is integrable. This is broken down into multiple steps. The first issue is to deal with the measurability of |X|. While a direct calculation can also show this, it may be worthwhile to follow a more general path:
(a) Any f : R  R continuous function is Borel measurable. (b) Conclude that for any random variable X, |X| is also a random variable. (c) Prove that for any random variable X, X is integrable if and only if |X|
is integrable. (The statement makes sense since |X| is a random variable whenever X is).
Hint For (b) recall Exercise 2.1. For (c) examine the relationship between |X| and (X)+ and (X)-.
2.13 (Infinite-valued integrals) Can we consistently extend the definition of integrals so that for non-negative random variables, the integral is always defined (it may be infinite)? Defend your view by either constructing an example (if you are arguing against) or by proving that your definition is consistent with the requirements we have for integrals.
2.14 Prove Proposition 2.6.
Hint You may find it useful to use Lebesgue's dominated/monotone convergence theorems.
2.15 Prove that if c  R is a constant, then E [cX] = cE [X] (as long as X is integrable).
2.16 Prove Proposition 2.7.
Hint Follow the `inductive' definition of Lebesgue integrals, starting with

2.9 Exercises

45

simple functions, then non-negative functions and finally arbitrary independent random variables. 2.17 Suppose that G1  G2 and prove that E[X | G1] = E[E[X | G1] | G2] almost surely.
2.18 Demonstrate using an example that in general, for dependent random variables, E [XY ] = E [X] E [Y ] does not hold.
2.19 Prove Proposition 2.8.
Hint Argue that X() = [0,) I {[0, X()]} (x) dx and exchange the integrals. Use the Fubini­Tonelli theorem to justify the exchange of integrals.
2.20 Prove Theorem 2.12.

3 Stochastic Processes and Markov Chains ( )
The measure-theoretic probability in the previous chapter covers almost all the definitions required. Occasionally, however, infinite sequences of random variables arise, and for these a little more machinery is needed. We expect most readers will skip this chapter on the first reading, perhaps referring to it when necessary.
Before one can argue about the properties of infinite sequences of random variables, it must be demonstrated that such sequences exist under certain constraints on their joint distributions. For example, does there exist an infinite sequence of random variables such that any finite subset of the random variables are independent and distributed like a standard Gaussian? The first theorem provides conditions under which questions like this can be answered positively. This allows us to write, for example, `let (Xn) n=1 be an infinite sequence of independent standard Gaussian random variables' and be comfortable knowing there exists a probability space on which these random variables can be defined. To state the theorem, we need the concept of Borel spaces.
Two measurable spaces (X , F) and (Y, G) are said to be isomorphic if there exists a bijective function f : X  Y such that f is F /G-measurable and f -1 is G/F-measurable. A Borel space is a measurable space (X , F) that is isomorphic to (A, B(A)) with A  B(R) a Borel measurable subset of the reals. This is not a very strong assumption. For example, (Rn, B(Rn)) is a Borel space, along with all of its measurable subsets.
Theorem 3.1. Let µ be a probability measure on a Borel space S and  be the Lebesgue measure on ([0, 1], B([0, 1]). Then there exists a sequence of independent random elements X1, X2, . . . on ([0, 1], B([0, 1]), ) such that the law Xt = µ for all t.
We give a sketch of the proof because, although it is not really relevant for the material in this book, it illustrates the general picture and dispels some of the mystic about what is really going on. Exercise 3.1 asks you to provide the missing steps from the proof.
Proof sketch of Theorem 3.1 For simplicity we consider only the case that S = ([0, 1], B([0, 1])) and µ is the Lebesgue measure. For any x  [0, 1], let F1(x), F2(x), . . . be the binary expansion of x, which is the unique binary-valued

3.1 Stochastic Processes

47

infinite sequence such that

x = Ft(x)2-t .
t=1
We can view F1, F2, . . . as (binary-valued) random variables over the probability space ([0, 1], B([0, 1]), ). Viewed as such, a direct calculation shows that F1, F2, . . . are independent. From this we can create an infinite sequence of uniform random variables by reversing the process. To do this, we rearrange the (Ft) t=1 sequence into a grid. For example:
F1, F2, F4, F7, · · · F3, F5, F8, · · · F6, F9, · · · F10, · · · ...

Letting Xm,t be the tth entry in the mth row of this grid, we define Xm =

 t=1

2-tXm,t,

and

again

one

can

easily

check

that

with

this

choice

the

sequence

X1, X2, . . . is independent and Xt = µ is uniform for each t.

3.1 Stochastic Processes

Let T be an arbitrary set. A stochastic process on probability space (, F, P) is a collection of random variables {Xt : t  T }. In this book T will always be countable, and so in the following we restrict ourselves to T = N. The first theorem is not the most general, but suffices for our purposes and is more easily stated than more generic alternatives.
Theorem 3.2. For each n  N+, let (n, Fn) be a Borel space and µn be a measure on (1 × · · · × n, F1  · · ·  Fn) and assume that µn and µn+1 are related through

µn+1(A × n+1) = µn(A) for all A  1  · · ·  n .

(3.1)

Then there exists a probability space (, F , P) and random elements X1, X2, . . . with Xt :   t such that PX1,...,Xn = µn for all n.

Sequences of measures (µn)n satisfying Eq. (3.1) are called projective.

Theorem 3.1 follows immediately from Theorem 3.2. By assumption a random variable takes values in (R, B(R)), which is Borel. Then let µn = tn=1µ be the n-fold product measure of µ with itself. That this sequence of measures is
projective is clear, and the theorem does the rest.

3.2 Markov Chains

48

3.2 Markov Chains

A Markov chain is an infinite sequence of random elements (Xt)t=1 where the conditional distribution of Xt+1 given X1, . . . , Xt is the same as the conditional distribution of Xt+1 given Xt. The sequence has the property that given the last element, the history is irrelevant to `predict' the future. Such random sequences appear throughout probability theory and have many applications besides. The theory is too rich to explain in detail, so we give the basics and point towards the literature for more details at the end. The focus here is mostly on the definition and existence of Markov chains.
Let (X , F) and (Y, G) be measurable spaces. A probability kernel or Markov kernel from (X , F) to (Y, G) is a function K : X × G  [0, 1] such that
(a) K(x, ·) is a measure for all x  X ; and (b) K(·, A) is F-measurable for all A  G.
The idea here is that K describes a stochastic transition. Having arrived at x, a process's next state is sampled Y  K(x, ·). Occasionally, we will use the notation Kx(A) or K(A | x) rather than K(x, A).
If K1 is a (X , F )  (Y, G) probability kernel and K2 is a (Y, G)  (Z, H) probability kernel, then the product kernel K1  K2 is the probability kernel from (X , F)  (Y × Z, G  H) defined by

(K1  K2)(x, A) =

IA((y, z))K2(y, dz)K1(x, dy) .

YZ

When P is a measure on (X , F) and K is a kernel from X to Y, then P  K is a measure on (X × Y, F  G) defined by

(P  K)(A) =

IA((x, y))K(x, dy)dP (x) .

XY

There operations can be composed. When P is a probability measure on X and

K1 a kernel from X to Y and K2 a kernel from X × Y to Z, then P  K1  K2 is a probability measure on X × Y × Z. The following provides a counterpart of

Theorem 3.2.

Theorem 3.3 (Ionescu­Tulcea). Let (n, Fn) n=1 be a sequence of measurable

spaces and K1 be a probability measure on (1, F1). For n  2, let Kn

be a probability kernel from

n-1 t=1

t

to

n.

Then

there

exists

a

probability

space (, F , P) and random elements (Xt)t=1 with Xt :   t such that

PX1,...,Xn =

n t=1

Kt

for

al l

n



N+.

A homogeneous Markov chain is a sequence of random elements (Xt) t=1 taking values in state space S = (X , F) and with

P (Xt+1  · | X1, . . . , Xt) = P (Xt+1  · | Xt) = µ(Xt, ·) almost surely ,

where µ is a probability kernel from (X , F) to (X , F) and we assume that P (X1  ·) = µ0(·) for some measure µ0 on (X , F ).

3.3 Martingales and Stopping Times

49

The word `homogeneous' refers to the fact that the probability kernel does not change with time. Accordingly, sometimes one writes `time homogeneous' instead of homogeneous. The reader can no doubt see how to define a Markov chain where µ depends on t, though doing so is purely cosmetic since the state space can always be augmented to include a time component.
Note that if µ(x | ·) = µ0(·) for all x  X , then Theorem 3.3 is yet another way to prove the existence of an infinite sequence of independent and identically distributed random variables. The basic questions in Markov chains resolve around understanding the evolution of Xt in terms of the probability kernel. For example, assuming that t = 1 for all t  N+, does the law of Xt converge to some fixed distribution as t  , and if so, how fast is this convergence? For now we make do with the definitions, but in the special case that X is finite, we will discuss some of these topics much later in Chapters 37 and 38.

3.3 Martingales and Stopping Times
Let X1, X2, . . . be a sequence of random variables on (, F , P) and F = (Ft)tn=1 a filtration of F and where we allow n = . Recall that the sequence (Xt)tn=1 is F-adapted if Xt is Ft-measurable for all 1  t  n. Definition 3.4. A F-adapted sequence of random variables (Xt)tN+ is a Fadapted martingale if (a) E[Xt | Ft-1] = Xt-1 almost surely for all t  {2, 3, . . .}; and (b) Xt is integrable. If the equality is replaced with a less-than (greater-than), then we call (Xt)t a supermartingale (respectively, a submartingale).
The time index t need not run over N+. Very often t starts at zero instead.

Example 3.5. A gambler repeatedly throws a coin, winning a dollar for each

heads and losing a dollar for each tails. Their total winnings over time is a

martingale. To model this situation, let Y1, Y2, . . . be a sequence of independent

Rademacher distributions, which means that P (Yt = 1) = P (Yt = -1) = 1/2.

The winnings after t rounds is St =

t s=1

Ys,

which

is

a

martingale

adapted

to

the filtration (Ft) t=1 given by Ft = (Y1, . . . , Yt). The definition of super/sub-

martingales (the direction of inequality) can be remembered by remembering

that the definition favors the casino, not the gambler.

Can a gambler increase its expected winning by stopping cleverly? Precisely,

3.3 Martingales and Stopping Times

50

the gambler at the end of round t can decide to stop (t = 1) or continue (t = 0) based on the information available to them. Denoting by  = min{t : t = 1} the time when the gambler stops, the question is whether by a clever choice of (t)tN, E [S ] can be made positive. Here, (t)tN, a sequence of binary, F-adapted random variables, is called a stopping rule, while  is a stopping time with respect F.
Note that the stopping rule is not allowed to inject additional randomness beyond what is already there in F.
Definition 3.6. Let F = (Ft)tN be a filtration. A random variable  with values in N  {} is a stopping time with respect to F if I {  t} is Ft-measurable for all t  N. The -algebra at stopping time  is
F = {A  F : A  {  t}  Ft for all t} .
The filtration is usually indicated by writing ` is a F-stopping time'. When the underlying filtration is obvious from context, it may be omitted. This is also true for martingales.
Using the interpretation of -algebras encoding information, if (Ft)t is thought of as the knowledge available at time t, F is the information available at the random time  . Exercise 3.7 asks you to explore properties of stopped -algebras; amongst other things, it asks you to show that F is in fact a -algebra.
Example 3.7. In the gambler example, the first time when the gambler's winnings hits 100 is a stopping time:  = min{t : St = 100}. On the other hand,  = min{t : St+1 = -1} is not a stopping time because I { = t} is not Ft-measurable.
Whether or not E [S ] can be made positive by a clever choice of a stopping time  is answered in the negative by a fundamental theorem of Doob:
Theorem 3.8 (Doob's optional stopping). Let F = (Ft)tN be a filtration and (Xt)tN be an F-adapted martingale and  an F-stopping time such that at least one of the following holds:
(a) There exists an n  N such that P ( > n) = 0. (b) E[ ] < , and there exists a constant c  R such that for all t  N,
E[|Xt+1 - Xt| | Ft]  c almost surely on the event that  > t. (c) There exists a constant c such that |Xt |  c almost surely for all t  N. Then X is almost surely well defined, and E[X ] = E[X0]. Furthermore, when (Xt) is a super/sub-martingale rather than a martingale, then equality is replaced with less/greater-than, respectively.

3.3 Martingales and Stopping Times

51

The theorem implies that if S is almost-surely well defined then either E [ ] =  or E [S ] = 0. Gamblers trying to outsmart the casino would need to live a very long life! One application of Doob's optional stopping theorem is a
useful and a priori surprising generalisation of Markov's inequality to non-negative
supermartingales.

Theorem 3.9 (Maximal inequality). Let (Xt) t=0 be a supermartingale with Xt  0 almost surely for all t. Then for any  > 0,

P

sup Xt  
tN



E[X0] 

.

Proof Let An be the event that suptn Xt   and  = (n + 1)  min{t  n : Xt  }, where the minimum of an empty set is assumed to be infinite so
that  = n + 1 if Xt <  for all 0  t  n. Clearly  is a stopping time and P (  n + 1) = 1. Then by Theorem 3.8 and elementary calculation,

E[X0]  E[X ]  E[X I {  n}]  E[I {  n}] = P (  n) = P (An) ,

where the second inequality uses the definition of the stopping time and the nonnegativity of the supermartingale. Rearranging shows that P (An)  E[X0]/ for all n  N. Since A1  A2  . . ., it follows that P (suptN Xt  ) = P (nNAn)  E[X0]/.

Markov's inequality (which we will cover in the next chapter) combined with the definition of a supermartingale shows that

P (Xn



)



E[X0] 

.

(3.2)

In fact, in the above we have effectively applied Markov's inequality to the random variable X (the need for the proof arises when the conditions of Doob's optional sampling theorem are not met). The maximal inequality is a strict improvement over Eq. (3.2) by replacing Xn with suptN Xt at no cost whatsoever.

A similar theorem holds for submartingales. You will provide a proof in Exercise 3.8.

Theorem 3.10. Let (Xt)tn=0 be a submartingale with Xt  0 almost surely for all t. Then for any  > 0,

P

max Xt  
t{0,1,...,n}



E[Xn] 

.

3.4 Notes

52

3.4 Notes
1 Some authors include in the definition of a stopping time  that P ( < ) = 1 and call random times without this property Markov times. We do not adopt this convention and allow stopping times to be infinite with non-zero probability. Stopping times are also called optional times.
2 There are several notations for probability kernels depending on the application. The following are commonly seen and equivalent: K(x, A) = K(A | x) = Kx(A). For example, in statistics a parametric family is often given by {P :   }, where  is the parameter space and P is a measure on some measurable space (, F). This notation is often more convenient than writing P(, ·). In Bayesian statistics the posterior is a probability kernel from the observation space to the parameter space, and this is often written as P(· | x).
3 There is some disagreement about whether or not a Markov chain on an uncountable state space should instead be called a Markov process. In this book we use Markov chain for arbitrary state spaces and discrete time. When time is continuous (which it never is in this book), there is general agreement that `process' is more appropriate. For more history on this debate, see [Meyn and Tweedie, 2012, preface].
4 A topological space X is Polish if it is separable and there exists a metric d that is compatible with the topology that makes (X , d) a complete metric space. All Polish spaces are Borel spaces. We follow Kallenberg [2002], but many authors use standard Borel space rather than Borel space, and define it as the -algebra generated by the open sets of a Polish space.
5 In Theorem 3.2 it was assumed that each µn was defined on a Borel space. No such assumption was required for Theorem 3.3, however. One can derive Theorem 3.2 from Theorem 3.3 by using the existence of regular conditional probability measures when conditioning on random elements taking values in a Borel space (see the next note). Topological assumptions often creep into foundational questions relating to the existence of probability measures satisfying certain conditions, and pathological examples show these assumptions cannot be removed completely. Luckily, in this book we have no reason to consider random elements that do not take values in a Borel space.
6 The fact that conditional expectation is only unique almost surely can be problematic when you want a conditional distribution. Given random elements X and Y on the same probability space, it seems reasonable to hope that P (X  · | Y ) is a probability kernel from the space of Y to that of X. A version of the conditional distributions that satisfies this is called a regular version. In general, there is no guarantee that such a regular version exist. The basic properties of conditional expectation only guarantee that for any fixed measurable A, P (X  A | Y ) is unique up to a set of measure zero. The set of measure zero can depend on A, which causes problems when there are `too many' measurable sets in the space of X. Assuming X lives in a Borel space, the following theorem guarantees the existence of a conditional distribution.

3.5 Bibliographic Remarks

53

Theorem 3.11 (Regular conditional distributions). Let X and Y be random elements on the same probability space (, F, P) taking values in measurable spaces X and Y, and assume that X is Borel. Then there exists a probability kernel K from Y to X such that K(· | Y ) = P (X  · | Y ) P-almost surely. Furthermore, K is unique in the sense that for any kernels K1 and K2 satisfying this condition, it holds that K1(· | y) = K2(· | y) for all y in some set of PY measure one.
The theorem implies the useful relation that PX,Y = PY K (cf. Exercise 3.9) where recall that for a random variable Z, PZ denotes its pushforward under P. To make the origin K clear, we often write PX|Y instead of K. With this, the above equality becomes PX,Y = PY  PX|Y , which can be viewed as the converse of the Ionescu­Tulcea theorem (Theorem 3.3). Sometimes this is called the chain rule of probabilities measures.
You can also condition on a -algebra G  F, in which case K is a probability kernel from (, G) to X . The condition that X be Borel is sufficient, but not necessary. Some conditions are required, however. An example where no regular version exists can be found in [Halmos, 1976, p210]. Regular versions play a role in the following useful theorem for decomposing random variables on product spaces.
Theorem 3.12 (Disintegration). Let X and Y be random elements on the same probability space taking values in measurable spaces X and Y. Let f be a random variable on X × Y so that E[|f (X, Y )|] < . Suppose that K is a regular version of P (X  · | G) and Y is G-measurable. Then,
E[f (X, Y ) | G] = f (x, Y )K(dx | ·) almost surely .
X
In many applications G = (Y ), in which case the theorem says that E[f (X, Y ) | Y ] = X f (x, Y )K(dx | Y ) almost surely. Proofs of both theorems appear in chapter 6 of Kallenberg [2002].
3.5 Bibliographic Remarks
There are many places to find the construction of a stochastic process. Like before, we recommend Kallenberg [2002] for readers who want to refresh their memory and Billingsley [2008] for a more detailed account. For Markov chains the recent book by Levin and Peres [2017] provides a wonderful introduction. After reading that, you might like the tome by Meyn and Tweedie [2012]. Theorem 3.1 can be found as theorem 3.19 in the book by Kallenberg [2002], where the reader can also find its proof. Theorem 3.2 is credited to Percy John Daniell by Kallenberg [2002] (see Aldrich 2007). More general versions of this theorem exist. Readers looking for these should look up Kolmogorov's extension theorem [Kallenberg, 2002, theorem 6.16]. The theorem of Ionescu­Tulcea (Theorem 3.3) is attributed to him

3.6 Exercises

54

[Tulcea, 1949­50] with a modern proof in the book by Kallenberg [2002, theorem 6.17]. There are lots of minor variants of the optional stopping theorem, most of which can be found in any probability book featuring martingales. The most historically notable source is by the man himself [Doob, 1953]. A more modern book that also gives the maximal inequalities is the book on optimal stopping by Peskir and Shiryaev [2006].

3.6 Exercises

3.1 Fill in the details of Theorem 3.1:

(a) Prove that Ft  {0, 1} is a Bernoulli random variable for all t  1.

(b) In what follows, equip S with P = , the uniform probability measure. Show

that for any t  1, Ft is uniformly distributed: P (Ft = 0) = P (Ft = 1) = 1/2.

(c) Show that (Ft)t=1 are independent. (d) Show that (Xm,t)t=1 is an independent sequence of Bernoulli random

variables that are uniformly distributed.

(e) Show that Xt =

 t=1

Xm,t2-t

is

uniformly

distributed

on

[0, 1].

(f) Show that (Xt)t=1 are independent.

3.2 (Martingales and optional stopping) Let (Xt)t=1 be an infinite

sequence of independent Rademacher random variables and St =

t s=1

Xs

2s-1

.

(a) Show that (St) t=0 is a martingale. (b) Let  = min{t : St = 1} and show that P ( < ) = 1. (c) What is E[S ]? (d) Explain why this does not contradict Doob's optional stopping theorem.

3.3 (Martingales and optional stopping (ii)) Give an example of a martingale (Sn)n=0 and stopping time  such that

lim
n

E[S n ]

=

E[S

]

.

3.4 (Maximal inequality fails without non-negativity) Show that Theorem 3.9 does not hold in general for supermartingales if the assumption that it be non-negative is dropped.

3.5 Let (, F) and (X , G) be measurable spaces, X : X  R be a random variable and K :  × G  [0, 1] a probability kernel from (, F) to (X , G). Define function U :   R by U () = X X(x)K(, dx) and assume that U () exists for all . Prove that U is F-measurable.

3.6 (Limits of increasing stopping times are stopping times) Let (n) n=1 be an almost surely increasing sequence of F-stopping times on probability space (, F , P) with filtration F = (Fn) n=1, which means that n()  n+1() for all n  1 almost surely. Prove that  () = limn n() is a F-stopping time.

3.6 Exercises

55

3.7 (Properties of stopping times) Let F = (Ft)tN be a filtration, and , 1, 2 be stopping times with respect to F. Show the following:
(a) F is a -algebra. (b) If  = k for some k  1, then F = Fk. (c) If 1  2, then F1  F2 . (d)  is F -measurable. (e) If (Xt) is F-adapted, then X is F -measurable. (f) F is the smallest -algebra such that all F-adapted sequences (Xt) satisfy
X is F -measurable.
3.8 Prove Theorem 3.10.
3.9 (Decomposing joint distributions) Let X and Y be random elements on the same probability space (, F, P) taking values in measurable spaces X and Y respectively and assume that X is Borel. Show that P(X,Y ) = PY  PX|Y where PX|Y denotes a regular conditional distribution of X and Y (the existence of which is guaranteed by Theorem 3.11).

4 Stochastic Bandits
The goal of this chapter is to formally introduce stochastic bandits. The model introduced here provides the foundation for the remaining chapters that treat stochastic bandits. While the topic seems a bit mundane, it is important to be clear about the assumptions and definitions. The chapter also introduces and motivates the learning objectives, and especially the regret. Besides the definitions, the main result in this chapter is the regret decomposition, which is presented in Section 4.5.
4.1 Core Assumptions
A stochastic bandit is a collection of distributions  = (Pa : a  A), where A is the set of available actions. The learner and the environment interact sequentially over n rounds. In each round t  {1, . . . , n}, the learner chooses an action At  A, which is fed to the environment. The environment then samples a reward Xt  R from distribution PAt and reveals Xt to the learner. The interaction between the learner (or policy) and environment induces a probability measure on the sequence of outcomes A1, X1, A2, X2, . . . , An, Xn. Usually the horizon n is finite, but sometimes we allow the interaction to continue indefinitely (n = ). The sequence of outcomes should satisfy the following assumptions:
(a) The conditional distribution of reward Xt given A1, X1, . . . , At-1, Xt-1, At is PAt , which captures the intuition that the environment samples Xt from PAt in round t.
(b) The conditional law of action At given A1, X1, . . . , At-1, Xt-1 is t(· | A1, X1, . . . , At-1, Xt-1), where 1, 2, . . . is a sequence of probability kernels that characterise the learner. The most important element of this assumption is the intuitive fact that the learner cannot use the future observations in current decisions.
A mathematician might ask whether there even exists a probability space carrying these random elements such that (a) and (b) hold. Specific constructions showing this in the affirmative are given in Section 4.6. These constructions are also valuable because they teach us important lessons about equivalent models. For now, however, we move on.

4.2 The Learning Objective

57

4.2 The Learning Objective

The learner's goal is to maximise the total reward Sn =

n t=1

Xt,

which

is

a

random quantity that depends on the actions of the learner and the rewards

sampled by the environment. This is not an optimisation problem for three

reasons:

1 What is the value of n for which we are maximising? Occasionally prior knowledge of the horizon is reasonable, but very often the learner does not know ahead of time how many rounds are to be played.
2 The cumulative reward is a random quantity. Even if the reward distributions were known, then we require a measure of utility on distributions of Sn.
3 The learner does not know the distributions that govern the rewards for each arm.

Of these points, the last is fundamental to the bandit problem and is discussed

in the next section. The lack of knowledge of the horizon is usually not a serious

issue. Generally speaking it is possible to first design a policy assuming the

horizon is known and then adapt it to account for the unknown horizon while

proving that the loss in performance is minimal. This is almost always quite easy,

and there exist generic approaches for making the conversion.

Assigning a utility to distributions of Sn is more challenging. Suppose

that Sn is the revenue of your company. Fig. 4.1 shows the distribution of

Sn for two different learners; call them A and B. Suppose you can choose

between learners A and B. Which one would you choose? One choice is to

go with the learner whose reward distribution has the larger expected value.

This will be our default choice for

stochastic bandits, but it bears remem-

bering that there are other consider-

A

B

ations, including the variance or tail

Density

behaviour of the cumulative reward,

which we will discuss occasionally. In

particular, in the situation shown on

in Fig. 4.1, learner B achieves a higher

expected reward than A. However B

has a reasonable probability of earning less than the least amount that A can

Reward

earn, so a risk-sensitive user may prefer Figure 4.1 Alternative revenue distributions

learner A.

4.3 Knowledge and Environment Classes
Even if the horizon is known in advance and we commit to maximising the expected value of Sn, there is still the problem that the bandit instance  = (Pa : a  A) is

4.3 Knowledge and Environment Classes

58

unknown. A policy that maximises the expectation of Sn for one bandit instance may behave quite badly on another. The learner usually has partial information about , which we represent by defining a set of bandits E for which   E is guaranteed. The set E is called the environment class. We distinguish between structured and unstructured bandits.
Unstructured Bandits An environment class E is unstructured if A is finite and there exist sets of distributions Ma for each a  A such that
E = { = (Pa : a  A) : Pa  Ma for all a  A} ,
or, in short, E = ×aAMa. The product structure means that by playing action a the learner cannot deduce anything about the distributions of actions b = a.
Some typical choices of unstructured bandits are listed in Table 4.1. Of course, these are not the only choices, and the reader can no doubt find ways to construct more, e.g. by allowing some arms to be Bernoulli and some Gaussian, or have rewards being exponentially distributed, or Gumbel distributed, or belonging to your favourite (non-)parametric family.
The Bernoulli, Gaussian and uniform distributions are often used as examples for illustrating some specific property of learning in stochastic bandit problems. The Bernoulli distribution is actually a natural choice. Think of applications like maximising click-through rates in a web-based environment. A bandit problem is often called a `distribution bandit', where `distribution' is replaced by the underlying distribution from which the pay-offs are sampled. Some examples are: Gaussian bandit, Bernoulli bandit or subgaussian bandit. Similarly we say `bandits with X', where `X' is a property of the underlying distribution from which the pay-offs are sampled. For example, we can talk about bandits with finite variance, meaning the bandit environment where the a priori knowledge of the learner is that all pay-off distributions are such that their underlying variance is finite.
Some environment classes, like Bernoulli bandits, are parametric, while others, like subgaussian bandits, are non-parametric. The distinction is the number of degrees of freedom needed to describe an element of the environment class. When the number of degrees of freedom is finite, it is parametric, and otherwise it is non-parametric. Of course, if a learner is designed for a specific environment class E, then we might expect that it has good performance on all bandits   E. Some environment classes are subsets of other classes. For example, Bernoulli bandits are a special case of bandits with a finite variance, or bandits with bounded support. Something to keep in mind is that we expect that it will be harder to achieve a good performance in a larger class. In a way, the theory of finite-armed stochastic bandits tries to quantify this expectation in a rigourous fashion.

4.3 Knowledge and Environment Classes

59

Name

Symbol Definition

Bernoulli Uniform Gaussian (known var.) Gaussian (unknown var.) Finite variance Finite kurtosis Bounded support Subgaussian

EBk EUk ENk (2) ENk EVk ( 2 ) EKk urt() E[ka,b] ESkG(2)

{(B(µi))i : µ  [0, 1]k} {(U (ai, bi))i : a, b  Rk with ai  bi for all i} {(N (µi, 2))i : µ  Rk} {(N (µi, i2))i : µ  Rk and 2  [0, )k} {(Pi)i : VXPi [X]  2 for all i} {(Pi)i : KurtXPi [X]   for all i} {(Pi)i : Supp(Pi)  [a, b]} {(Pi)i : Pi is -subgaussian for all i}

Table 4.1 Typical environment classes for stochastic bandits. Supp(P ) is the (topological)
support of distribution P . The kurtosis of a random variable X is a measure of its tail behaviour and is defined by E[(X - E[X])4]/V[X]2. Subgaussian distributions have similar properties to the Gaussian and will be defined in Chapter 5.

Structured Bandits Environment classes that are not unstructured are called structured. Relaxing the requirement that the environment class is a product set makes structured bandit problems much richer than the unstructured set-up. The following examples illustrate the flexibility.

Example 4.1. Let A = {1, 2} and E = {(B(), B(1 - )) :   [0, 1]}. In this environment class, the learner does not know the mean of either arm, but can learn the mean of both arms by playing just one. The knowledge of this structure dramatically changes the difficulty of learning in this problem.

Example 4.2 (Stochastic linear bandit). Let A  Rd and   Rd and

 = (N ( a,  , 1) : a  A)

and E = { :   Rd} .

In this environment class, the reward of an action is Gaussian, and its mean is given
by the inner product between the action and some unknown parameter. Notice that even if A is extremely large, the learner can deduce the true environment by playing just d actions that span Rd.

Example 4.3. Consider an undirected graph G with vertices V = {1, . . . , |V |} and edges E = {1, . . . , |E|}. In each round the learner chooses a path from vertex 1 to vertex |V |. Then each edge e  [E] is removed from the graph with probability 1 - e for unknown   [0, 1]|E|. The learner succeeds in reaching their destination if all the edges in their chosen path are present. This problem

4.4 The Regret

60

can be formalised by letting A be the set of paths and

 = B

e : a  A

ea

and E = { :   [0, 1]|E|} .

An important feature of structured bandits is that the learner can often obtain information about some actions while never playing them.

4.4 The Regret

In Chapter 1 we informally defined the regret as being the deficit suffered by the learner relative to the optimal policy. Let  = (Pa : a  A) be a stochastic bandit and define



µa() =

x dPa(x) .

-

Then let µ() = maxaA µa() be the largest mean of all the arms.

We assume throughout that µa() exists and is finite for all actions and that argmaxaA µa() is non-empty. The latter assumption could be relaxed by carefully adapting all arguments using nearly optimal actions, but in
practice this is never required.

The regret of policy  on bandit instance  is

n

Rn(, ) = nµ() - E

Xt ,

t=1

(4.1)

where the expectation is taken with respect to the probability measure on outcomes induced by the interaction of  and . Minimising the regret is equivalent to maximising the expectation of Sn, but the normalisation inherent in the definition of the regret is useful when stating results, which would otherwise need to be stated relative to the optimal action.

If the context is clear, we will often drop the dependence on  and  in various

quantities. For example, by writing Rn = nµ - E[

n t=1

Xt].

Similarly,

the

limits in sums and maxima are abbreviated when we think you can work

out ranges of symbols in a unique way, e.g. µ = maxi µi.

The regret is always non-negative, and for every bandit , there exists a policy  for which the regret vanishes.

4.4 The Regret

61

Lemma 4.4. Let  be a stochastic bandit environment. Then,

(a) Rn(, )  0 for all policies ; (b) the policy  choosing At  argmaxa µa for all t satisfies Rn(, ) = 0; and (c) if Rn(, ) = 0 for some policy , then P (µAt = µ) = 1 for all t  [n].

We leave the proof for the reader (Exercise 4.1). Part (b) of Lemma 4.4 shows that for every bandit , there exists a policy for which the regret is zero (the best possible outcome). According to Part (c), achieving zero is possible if and only if the learner knows which bandit it is facing (or at least, what is the optimal arm). In general, however, the learner only knows that   E for some environment class E. So what can we hope for? A relatively weak objective is to find a policy  with sublinear regret on all   E. Formally, this objective is to find a policy  such that

for all   E ,

lim
n

Rn(, ) n

=

0.

If the above holds, then at least the learner is choosing the optimal action almost

all of the time as the horizon tends to infinity. One might hope for much more,

however, for example, that for some specific choice of C > 0 and p < 1 that

for all   E , Rn(, )  Cnp .

(4.2)

Yet another alternative is to find a function C : E  [0, ) and f : N  [0, ) such that

for all n  N,   E , Rn(, )  C()f (n) .

(4.3)

This factorisation of the regret into a function of the instance and a function of the horizon is not uncommon in learning theory and appears in particular in supervised learning.
We will spend a lot of time in the following chapters finding policies satisfying Eq. (4.2) and Eq. (4.3) for different choices of E. The form of Eq. (4.3) is quite general, so much time is also spent discovering what are the possibilities for f and C, both of which should be `as small as possible'. All of the policies are inspired by the simple observation that in order to make the regret small, the algorithm must discover the action/arm with the largest mean. Usually this means the algorithm should play each arm some number of times to form an estimate of the mean of that arm, and subsequently play the arm with the largest estimated mean. The question essentially boils down to discovering exactly how often the learner must play each arm in order to have reasonable statistical certainty that it has found the optimal arm.
There is another candidate objective called the Bayesian regret. If Q is a prior probability measure on E (which must be equipped with a -algebra F), then the Bayesian regret is the average of the regret with respect to the prior Q.

BRn(, Q) = Rn(, ) dQ() ,
E

(4.4)

4.5 Decomposing the Regret

62

which is only defined by assuming (or proving) that the regret is a measurable function with respect to F. An advantage of the Bayesian approach is that having settled on a prior and horizon, the problem of finding a policy that minimises the Bayesian regret is just an optimisation problem. Most of this book is devoted to analyzing the `frequentist' regret in Eq. (4.1), which does not integrate over all environments as Eq. (4.4) does. Bayesian methods are covered in Chapters 34 to 36, where we also discuss the strengths and weaknesses of the Bayesian approach.

4.5 Decomposing the Regret

We now present a lemma that forms the basis of almost every proof for stochastic bandits. Let  = (Pa : a  A) be a stochastic bandit and define a() = µ() - µa(), which is called the suboptimality gap or action gap or immediate regret of action a. Further, let
t
Ta(t) = I {As = a}
s=1
be the number of times action a was chosen by the learner after the end of round t. In general, Ta(n) is random, which may seem surprising if we think about a deterministic policy that chooses the same action for any fixed history. So why is Ta(n) random in this case? The reason is because for all rounds t except for the first, the action At depends on the rewards observed in rounds 1, 2, . . . , t - 1, which are random, hence At will also inherit their randomness. We are now ready to state the second and last lemmas of the chapter. In the statement of the lemma, we use our convention that the dependence of the various quantities involved on the policy  and the environment  is suppressed.

Lemma 4.5 (Regret decomposition lemma). For any policy  and stochastic bandit environment  with A finite or countable and horizon n  N, the regret Rn of policy  in  satisfies

Rn = aE [Ta(n)] .
aA

(4.5)

The lemma decomposes the regret in terms of the loss due to using each of the arms. It is useful because it tells us that to keep the regret small, the learner should try to minimise the weighted sum of expected action counts, where the weights are the respective suboptimality gaps, (a)aA.

Lemma 4.5 tells us that a learner should aim to use an arm with a larger suboptimality gap proportionally fewer times.

Note that the suboptimality gap for optimal arm(s) is zero.

4.6 The Canonical Bandit Model ( )

63

Proof of Lemma 4.5 Since Rn is based on summing over rounds, and the right-
hand side of the lemma statement is based on summing over actions, to convert one
sum into the other one, we introduce indicators. In particular, note that for any fixed t we have aA I {At = a} = 1. Hence Sn = t Xt = t a XtI {At = a}, and thus

Rn = nµ - E [Sn] =

n
E [(µ - Xt)I {At = a}] .

aA t=1

(4.6)

The expected reward in round t conditioned on At is µAt , which means that

E [(µ - Xt)I {At = a} | At] = I {At = a} E [µ - Xt | At] = I {At = a} (µ - µAt ) = I {At = a} (µ - µa) = I {At = a} a .

The result is completed by plugging this into Eq. (4.6) and using the definition of Ta(n).

The argument fails when A is uncountable because you cannot introduce the sum over actions. Of course the solution is to use an integral, but for this we need to assume (A, G) is a measurable space. Given a bandit  and policy  define measure G on (A, G) by

n

G(U ) = E

I {At  U } ,

t=1

where the expectation is taken with respect to the measure on outcomes induced by the interaction of  and .

Lemma 4.6. Provided that everything is well defined and appropriately measurable,

n

Rn = E

At = a dG(a) .

t=1

A

For those worried about how to ensure everything is well defined, see Section 4.7.

4.6 The Canonical Bandit Model ( )
In most cases the underlying probability space that supports the random rewards and actions is never mentioned. Occasionally, however, it becomes convenient to choose a specific probability space, which we call the canonical bandit model.

4.6 The Canonical Bandit Model ( )

64

Finite Horizon Let n  N be the horizon. A policy and bandit interact to produce the outcome, which is the tuple of random variables Hn = (A1, X1, . . . , An, Xn). The first step towards constructing a probability space that carries these random variables is to choose the measurable space. For each t  [n], let t = ([k] × R)t  R2t and Ft = B(t). The random variables A1, X1, . . . , An, Xn that make up the outcome are defined by their coordinate projections:
At(a1, x1, . . . , an, xn) = at and Xt(a1, x1, . . . , an, xn) = xt .
The probability measure on (n, Fn) depends on both the environment and the policy. Our informal definition of a policy is not quite sufficient now.
Definition 4.7. A policy  is a sequence (t)tn=1, where t is a probability kernel from (t-1, Ft-1) to ([k], 2[k]). Since [k] is discrete, we adopt the notational convention that for i  [k],
t(i | a1, x1, . . . , at-1, xt-1) = t({i} | a1, x1, . . . , at-1, xt-1) .
Let  = (Pi)ki=1 be a stochastic bandit where each Pi is a probability measure on (R, B(R)). We want to define a probability measure on (n, Fn) that respects our understanding of the sequential nature of the interaction between the learner and a stationary stochastic bandit. Since we only care about the law of the random variables (Xt) and (At), the easiest way to enforce this is to directly list our expectations, which are
(a) the conditional distribution of action At given A1, X1, . . . , At-1, Xt-1 is t( · | A1, X1, . . . , At-1, Xt-1) almost surely.
(b) the conditional distribution of reward Xt given A1, X1, . . . , At is PAt almost surely.
The sufficiency of these assumptions is asserted by the following proposition, which we ask you to prove in Exercise 4.2.
Proposition 4.8. Suppose that P and Q are probability measures on an arbitrary measurable space (, F ) and A1, X1, . . . , An, Xn are random variables on , where At  [k] and Xt  R. If both P and Q satisfy (a) and (b), then the law of the outcome under P is the same as under Q:
PA1,X1,...,An,Xn = QA1,X1,...,An,Xn .
Next we construct a probability measure on (n, Fn) that satisfies (a) and (b). To emphasise that what follows is intuitively not complicated, imagine that Xt  {0, 1} is Bernoulli, which means the set of possible outcomes is finite and we can define the measure in terms of a distribution. Let pi(0) = Pi({0}) and pi(1) = 1 - pi(0) and define
n
p(a1, x1, . . . , an, xn) = (at | a1, x1, . . . , at-1, xt-1)pat (xt) .
t=1

4.6 The Canonical Bandit Model ( )

65

The reader can check that p is a distribution on ([k] × {0, 1})n and that the
associated measure satisfies (a) and (b) above. Making this argument rigourous
when (Pi) are not discrete requires the use of Radon­Nikodym derivatives. Let  be a -finite measure on (R, B(R)) for which Pi is absolutely continuous with respect to  for all i. Next, let pi = dPi/d be the Radon­Nikodym derivative of Pi with respect to , which is a function pi : R  R such that B pi d = Pi(B) for all B  B(R). Letting  be the counting measure with (B) = |B|, the density p :   R can now be defined with respect to the product measure ( × )n by

n
p(a1, x1, . . . , an, xn) = (at | a1, x1, . . . , at-1, xt-1)pat (xt) .
t=1

(4.7)

The reader can again check (more abstractly) that (a) and (b) are satisfied by the probability measure P defined by

P(B) = p()( × )n(d)
B

for all B  Fn .

It is important to emphasise that this choice of (n, Fn, P) is not unique. Instead, all that this shows is that a suitable probability space does exist. Furthermore, if
some quantity of interest depends on the law of Hn, by Proposition 4.8, there is no loss in generality in choosing (n, Fn, P) as the probability space.

A choice of  such that Pi

 for all i always exists since  =

k i=1

Pi

satisfies this condition. For direct calculations, another choice is usually

more convenient, e.g. the counting measure when (Pi) are discrete and the

Lebesgue measure for continuous (Pi).

There is another way to define the probability space, which can be useful.
Define a collection of independent random variables (Xsi)s[n],i[k] such that the law of Xti is Pi. By Theorem 2.4 these random variables may be defined on (, F ), where  = Rnk and F = B(Rnk). Then let Xt = XtAt , where the actions At are Ft-1-measurable with Ft-1 = (A1, X1, . . . , At-1, Xt-1). We call this the random table model. Yet another way is to define (Xsi)s,i as above but let Xt = XTAt (t),At . This corresponds to sampling a stack of rewards for each arm at the beginning of the game, giving rise to the reward-stack model. Each time
the learner chooses an action, they receive the reward on top of the stack. All of
these models are convenient from time to time. The important thing is that it
does not matter which model we choose because the quantity of ultimate interest
(usually the regret) only depends on the law of A1, X1, . . . , An, Xn, and this is the same for all choices.

4.7 The Canonical Bandit Model for Uncountable Action Sets ( )

66

Infinite Horizon
We never need the canonical bandit model for the case that n = . It is comforting to know, however, that there does exist a probability space (, F , P) and infinite sequences of random variables X1, X2, . . . and A1, A2, . . . satisfying (a) and (b). The result follows directly from the theorem of Ionescu­Tulcea (Theorem 3.3).

4.7 The Canonical Bandit Model for Uncountable Action Sets ( )

For uncountable action sets, a little more machinery is necessary to make things
rigourous. The first requirement is that the action set must be a measurable
space (A, G) and the collection of distribution  = (Pa : a  A) that defines a bandit environment must be a probability kernel from (A, G) to (R, B(R)). A policy is a sequence (t)nt=1, where t is a probability kernel from (t-1, Ft-1) to (A, G) with

t

t

t = (A × R) and Ft = (G  B(R)) .

s=1

s=1

The canonical bandit model is the probability measure P on (n, Fn) obtained by taking the product of the probability kernels 1, P1, . . . n, Pn and
using Ionescu­Tulcea (Theorem 3.3), where Pt is the probability kernel from (t-1 × A, Ft  G) to (R, B(R)) given by Pt( · | a1, x1, . . . , at-1, xt-1, at) = Pat (·).

We did not define P in terms of a density because there may not exist a common dominating measure for either (Pa : a  A) or the policy. When such measures exist, as they usually do, then P may be defined in terms
of a density in the same manner as the previous section.

You will check in Exercise 4.5 that the assumptions on  and  in this section are sufficient to ensure the quantities in Lemma 4.6 are well defined and that Proposition 4.8 continues to hold in this setting without modification. Finally, in none of the definitions above do we require that n be finite.

4.8 Notes
1 It is not obvious why the expected value is a good summary of the reward distribution. Decision makers who base their decisions on expected values are called risk-neutral. In the example shown on the figure above, a risk-averse decision maker may actually prefer the distribution labelled as A because occasionally distribution B may incur a very small (even negative) reward. Risk-seeking decision makers, if they exist at all, would prefer distributions with occasional large rewards to distributions that give mediocre rewards only.

4.8 Notes

67

There is a formal theory of what makes a decision maker rational (a decision maker in a nutshell is rational if they do not contradict themself). Rational decision makers compare stochastic alternatives based on the alternatives' expected utilities, according to the von-Neumann­Morgenstern utility theorem. Humans are known not to do this. We are irrational. No surprise here. 2 The study of utility and risk has a long history, going right back to (at least) the beginning of probability [Bernoulli, 1954, translated from the original Latin, 1738]. The research can broadly be categorised into two branches. The first deals with describing how people actually make choices (descriptive theories), while the second is devoted to characterising how a rational decision maker should make decisions (prescriptive theories). A notable example of the former type is `prospect theory' [Kahneman and Tversky, 1979], which models how people handle probabilities (especially small ones) and earned Daniel Kahneman a Nobel Prize (after the death of his long-time collaborator, Amos Tversky). Further descriptive theories concerned with alternative aspects of human decision-making include bounded rationality, choice strategies, recognition-primed decision-making and image theory [Adelman, 2013]. 3 The most famous example of a prescriptive theory is the von Neumann­ Morgenstern expected utility theorem, which states that under (reasonable) axioms of rational behaviour under uncertainty, a rational decision maker must choose amongst alternatives by computing the expected utility of the outcomes [Neumann and Morgenstern, 1944]. Thus, rational decision makers, under the chosen axioms, differ only in terms of how they assign utility to outcomes (i.e. rewards). Finance is another field where attitudes towards uncertainty and risk are important. Markowitz [1952] argues against expected return as a reasonable metric that investors would use. His argument is based on the (simple) observation that portfolios maximising expected returns will tend to have a single stock only (unless there are multiple stocks with equal expected returns, a rather unlikely outcome). He argues that such a complete lack of diversification is unreasonable. He then proposes that investors should minimise the variance of the portfolio's return subject to a constraint on the portfolio's expected return, leading to the so-called mean-variance optimal portfolio choice theory. Under this criteria, portfolios will indeed tend to be diversified (and in a meaningful way: correlations between returns are taken into account). This theory eventually won him a Nobel Prize in economics (shared with two others). Closely related to the mean-variance criterion are the `value-at-risk' (VaR) and the `conditional value-at-risk', the latter of which has been introduced and promoted by Rockafellar and Uryasev [2000] due to its superior optimisation properties. The distinction between the prescriptive and descriptive theories is important: human decision makers are in many ways violating rules of rationality in their attitudes towards risk. 4 We defined the regret as an expectation, which makes it unusable in conjunction with measures of risk because the randomness has been eliminated by the expectation. When using a risk measure in a bandit setting, we can either base

4.9 Bibliographical Remarks

68

this on the random regret or pseudo-regret defined by

n
R^n = nµ - Xt .
t=1 n
R¯n = nµ - µAt .
t=1

(random regret) (pseudo-regret)

While R^n is influenced by the noise Xt - µAt in the rewards, the pseudo-regret filters this out, which arguably makes it a better basis for measuring the `skill' of a bandit policy. As these random regret measures tend to be highly skewed, using variance to assess risk suffers not only from the problem of penalising upside risk, but also from failing to capture the skew of the distribution.
5 What happens if the distributions of the arms are changing with time? Such bandits are unimaginatively called non-stationary bandits. With no assumptions, there is not much to be done. Because of this, it is usual to assume the distributions change infrequently or drift slowly. We'll eventually see that techniques for stationary bandits can be adapted to this set-up (see Chapter 31).
6 The rigourous models introduced in Sections 4.6 and 4.7 are easily extended to more sophisticated settings. For example, the environment sometimes produces side information as well as rewards or the set of available actions may change with time. You are asked to formalise an example in Exercise 4.6.

4.9 Bibliographical Remarks
There is now a huge literature on stochastic bandits, much of which we will discuss in detail in the chapters that follow. The earliest reference that we know of is by Thompson [1933], who proposed an algorithm that forms the basis of many of the currently practical approaches in use today. Thompson was a pathologist who published broadly and apparently did not pursue bandits much further. Sadly his approach was not widely circulated, and the algorithm (now called Thompson sampling) did not become popular until very recently. Two decades after Thompson, the bandit problem was formally restated in a short but influential paper by Robbins [1952], an American statistician now most famous for his work on empirical Bayes. Robbins introduced the notion of regret and minimax regret in his 1952 paper. The regret decomposition (Lemma 4.5) has been used in practically every work on stochastic bandits, and its origin is hard to pinpoint. All we can say for sure is that it does not appear in the paper by Robbins [1952], but does appear in the work of Lai and Robbins [1985]. Denardo et al. [2007] considers risk in a (complicated) Bayesian setting. Sani et al. [2012] consider a mean-variance approach to risk, while Maillard [2013] considers socalled coherence risk measures (CVaR, is one example of such a risk measure),

4.10 Exercises

69

and with an approach where the regret itself is redefined. VaR is considered in the context of a specific bandit policy family by Audibert et al. [2007, 2009].

4.10

Exercises

4.1 (Positivity of the regret) Prove Lemma 4.4.

4.2 (Uniqueness of law) Prove Proposition 4.8.

4.3 (Definition of canonical probability measure) Prove that the measure defined in terms of the density in Eq. (4.7) satisfies the conditions (a) and (b) in Section 4.6.

Hint Use the properties of the Radon­Nikodym derivative in combination with Fubini's theorem.

4.4 (Mixing policies) Fix a horizon n and k. Let  be a finite set of policies
for k-armed bandits on horizon n and p  P() be a distribution over . Show there exists a policy  such that for any k-armed stochastic bandit ,

P =

p()P .



Proof For action/reward sequence a1, x1, . . . , an, xn, syntactically abbreviate ht = a1, x1, . . . , at, xt. Then define

t(at | ht-1) =

 p()  p()

t
s=1 t-1 s=1

s(as s(as

| |

hs-1) hs-1)

.

By the definition of the canonical probability space and the product of probability

kernels,

k

k

P (B) =

···

IB(hn)an (dxn)n (an | hn-1) · · · a1 (dx1)1(a1)

a1=1 R an=1 R

k

k

= p()

···

IB(hn)an (dxn)n(an | hn-1) · · · a1 (dx1)1(a1)



a1=1 R an=1 R

= p()P(B) ,



where the second equality follows by substituting the definition of  and

induction.

4.5 (Regret decomposition and canonical model for large action spaces) Let  be a bandit on measurable action space (A, G) and 1, . . . , n be a policy satisfying the conditions in Section 4.7.

(a) Show that all quantities in Lemma 4.6 are appropriately defined and measurable.

4.10 Exercises

70

(b) Prove Lemma 4.6. (c) Prove that Proposition 4.8 continues to hold.
4.6 (Canonical model for contextual bandit) Let A and C be finite sets. A stochastic contextual bandit is like a normal stochastic bandit, but in each round the learner first observes a context Ct  C. They then choose an action At  A and receive a reward Xt  PAt,Ct .
(a) Suppose that C1, . . . , Cn is sampled independently from distribution  on C. Construct the canonical probability space that carries C1, A1, X1, . . . , Cn, An, Xn.
(b) What changes when Ct is allowed to depend on C1, A1, X1, . . . , Ct-1, At-1, Xt-1?
4.7 (Bernoulli environment implementation) Implement a Bernoulli bandit environment in Python using the code snippet below (or adapt to your favourite language).
class BernoulliBandit: # accepts a list of K >= 2 floats , each lying in [0 ,1] def __init__(self , means): pass
# Function should return the number of arms def K(self):
pass
# Accepts a parameter 0 <= a <= K-1 and returns the # realisation of random variable X with P(X = 1) being # the mean of the (a+1)th arm. def pull(self , a):
pass
# Returns the regret incurred so far. def regret(self):
pass
4.8 (Follow-the-leader implementation) Implement the following simple algorithm called `follow-the-leader', which chooses each action once and subsequently chooses the action with the largest average observed so far. Ties should be broken randomly.
def FollowTheLeader(bandit , n): # implement the Follow -the -Leader algorithm by replacing # the code below that just plays the first arm in every round for t in range(n): bandit . pull (0)
Depending on the literature you are reading, follow-the-leader may be called `stay with the winner' or the `greedy algorithm'.

4.10 Exercises

71

4.9 Suppose  is a finite-armed stochastic bandit and  is a policy such that

lim
n

Rn(, ) n

=

0.

Let T (n) =

n t=1

I {µAt

=

µ}

be

the

number

of

times

an

optimal

arm

is

chosen.

Prove or disprove each of the following statements:

(a) limn E[T (n)]/n = 1. (b) limn P (At > 0) = 0.

4.10 (one-armed bandits) Let M1 be a set of distributions on (R, B(R)) with finite means and M2 = {µ2 } be the singleton set with a Dirac at µ2  R. The set of bandits E = M1 × M2 is called a one-armed bandit because, although there are two arms, the second arm always yields a known reward of µ2. A policy  = (t)t is called a retirement policy if once action 2 has been played once, it is played until the end of the game. Precisely, if at = 2, then
t+1(2 | a1, x1, . . . , at, xt) = 1 for all (as)st-=11 and (xs)ts=1 .
(a) Let n be fixed and  = (t)tn=1 be any policy. Prove there exists a retirement policy  = (t)tn=1 such that for all   E.
Rn( , )  Rn(, ) .
(b) Let M1 = {B(µ1) : µ1  [0, 1]} and suppose that  = (t) t=1 is a retirement policy. Prove there exists a bandit   E such that

lim sup
n

Rn(, ) n

>

0.

4.11 (Failure of follow-the-leader (i)) Consider a Bernoulli bandit with two arms and means µ1 = 0.5 and µ2 = 0.6.

(a) Using a horizon of n = 100, run 1000 simulations of your implementation

of follow-the-leader on the Bernoulli bandit above and record the (random)

pseudo regret, nµ -

n t=1

µAt ,

in

each

simulation.

(b) Plot the results using a histogram. Your figure should resemble Fig. 4.2.

(c) Explain the results in the figure.

4.12 (Failure of follow-the-leader (ii)) Consider the same Bernoulli bandit as used in the previous question.
(a) Run 1000 simulations of your implementation of follow-the-leader for each horizon n  {100, 200, 300, . . . , 1000}.
(b) Plot the average regret obtained as a function of n (see Fig. 4.3). Because the average regret is an estimator of the expected regret, you should generally include error bars to indicate the uncertainty in the estimation.
(c) Explain the plot. Do you think follow-the-leader is a good algorithm? Why/why not?

4.10 Exercises

72

Follow-the-leader 400

Frequency

200

0

0

2

4

6

8

10

Regret

Figure 4.2 Histogram of regret for follow-the-leader over 1000 trials on a Bernoulli bandit with means µ1 = 0.5, µ2 = 0.6

Expected Regret

50

Follow-the-leader

40

30

20

10

200 400 600 800 1,000 n
Figure 4.3 The regret for Follow-the-leader over 1000 trials on Bernoulli bandit with means µ1 = 0.5, µ2 = 0.6 and horizons ranging from n = 100 to n = 1000.

5 Concentration of Measure

Before we can start designing and analysing algorithms, we need one more tool from probability theory, called concentration of measure. Recall that the optimal action is the one with the largest mean. Since the mean pay-offs are initially unknown, they must be learned from data. How long does it take to learn about the mean reward of an action? In this section, after introducing the notion of tail probabilities, we look at ways of obtaining upper bounds on them. The main point is to introduce subgaussian random variables and the Cram´er­Chernoff exponential tail inequalities, which will play a central role in the design and analysis of the various bandit algorithms.

5.1 Tail Probabilities

Suppose that X, X1, X2, . . . , Xn is a sequence of independent and identically distributed random variables, and assume that the mean µ = E[X] and variance 2 = V[X] exist. Having observed X1, X2, . . . , Xn, we would like to estimate the
common mean µ. The most natural estimator is

µ^

=

1 n

n

Xi ,

i=1

which is called the sample mean or empirical mean. Linearity of expectation (Proposition 2.6) shows that E[µ^] = µ, which means that µ^ is an unbiased estimator of µ. How far from µ do we expect µ^ to be? A simple measure
of the spread of the distribution of a random variable Z is its variance, V [Z] = E (Z - E [Z])2 . A quick calculation using independence shows that

V [µ^] = E

(µ^ - µ)2

=

2 n

,

(5.1)

which means that we expect the squared distance between µ and µ^ to shrink as n grows large at a rate of 1/n and scale linearly with the variance of X. While the expected squared error is important, it does not tell us very much about the distribution of the error. To do this we usually analyse the probability that µ^ overestimates or underestimates µ by more than some value  > 0. Precisely, how

5.2 The Inequalities of Markov and Chebyshev

74

Figure 5.1 The figure shows a probability density, with the tails shaded indicating the regions where X is at least  away from the mean µ.
do the following quantities depend on ? P (µ^  µ + ) and P (µ^  µ - ) .
The expressions above (as a function of ) are called the tail probabilities of µ^ - µ (Fig. 5.1). Specifically, the first is called the upper tail probability and the second the lower tail probability. Analogously, P (|µ^ - µ|  ) is called a two-sided tail probability.

5.2 The Inequalities of Markov and Chebyshev

The most straightforward way to bound the tails is by using Chebyshev's inequality, which is itself a corollary of Markov's inequality. The latter is one of the golden hammers of probability theory, and so we include it for the sake of completeness.

Lemma 5.1. For any random variable X and  > 0, the following holds:

(a) (b)

(Markov):

P (|X|



)



E

[|X |] 

.

(Chebyshev): P (|X - E [X] |  ) 

V [X 2

]

.

We leave the proof of Lemma 5.1 as an exercise for the reader. By combining (5.1) with Chebyshev's inequality, we can bound the two-sided tail directly in terms of the variance by

P (|µ^

-

µ|



)



2 n2

.

(5.2)

This result is nice because it was so easily bought and relied on no assumptions other than the existence of the mean and variance. The downside is that when X is well behaved, the inequality is rather loose. By assuming that higher moments of X exist, Chebyshev's inequality can be improved by applying Markov's inequality to |µ^ - µ|k, with the positive integer k to be chosen so that the resulting bound is

5.2 The Inequalities of Markov and Chebyshev

75

optimised. This is a bit cumbersome, and thus instead we present the continuous analog of this, known as the Cram´er-Chernoff method.
To calibrate our expectations on what improvement to expect relative to Chebyshev's inequality, let us start by recalling the central limit theorem (CLT). Let Sn = tn=1(Xt - µ). The CLT says that under no additional assumptions than the existence of the variance, the limiting distribution of Sn/ n2 as n   is a Gaussian with mean zero and unit variance. If Z  N (0, 1), then

P (Z  u) =

 1 exp u 2

-

x2 2

dx .

The integral has no closed-form solution, but is easy to bound:

 1 exp u 2

- x2 2

dx  1 u 2


x exp
u

- x2 2

dx

=

1 2u2

exp

-

u2 2

,

(5.3)

which gives

 P (µ^  µ + ) = P Sn/ 2n   n/2  P Z   n/2



2 2n2

exp

-

n2 22

.

(5.4)

This is usually much smaller than what we obtained with Chebyshev's inequality (Exercise 5.3). In particular, the bound on the right-hand side of (5.4) decays slightly faster than the negative exponential of n2/2, which means that µ^ rapidly concentrates around its mean.

An oft-taught rule of thumb is that the CLT provides a reasonable

approximation for n  30. We advise caution. Suppose that X1, . . . , Xn

are independent Bernoulli with bias p = 1/n. As n tends to infinity the

distribution of

n t=1

Xt

converges

to

a

Poisson

distribution

with

parameter

1, which does not look Gaussian at all.

The asymptotic nature of the CLT makes it unsuitable for designing bandit algorithms. In the next section, we derive finite-time analogs, which are only possible by making additional assumptions.

5.3 The Cram´er-Chernoff Method and Subgaussian Random Variables

76

5.3 The Cram´er-Chernoff Method and Subgaussian Random Variables

For the sake of moving rapidly towards bandits, we start with a straightforward and relatively fundamental assumption on the distribution of X, known as the subgaussian assumption.

Definition 5.2 (Subgaussianity). A random variable X is -subgaussian if for all   R, it holds that E [exp(X)]  exp 22/2 .

An alternative way to express the subgaussianity condition uses the momentgenerating function of X, which is a function MX : R  R defined by MX () = E [exp(X)]. The condition in the definition can be written as

X ()

=

log MX ()



1 2

2

2

for all   R .

The function X is called the cumulant-generating function. It is not hard

to see that MX (or X ) need not exist for all random variables over the whole

range of real numbers. For example, if X is exponentially distributed and   1,

then



E [exp(X)] =

exp(-x) × exp(x)dx =  .

0 density of exponential

The moment-generating function of X  N (0, 2) satisfies MX () = exp(22/2), and so X is -subgaussian.

A random variable X is heavy tailed if MX () =  for all  > 0. Otherwise it is light tailed.

The following theorem explains the origin of the term `subgaussian'. The tails of a -subgaussian random variable decay approximately as fast as that of a Gaussian with zero mean and the same variance.

Theorem 5.3. If X is -subgaussian, then for any   0,

P (X  )  exp

-

2 22

.

(5.5)

Proof We take a generic approach called the Cram´er­Chernoff method. Let  > 0 be some constant to be tuned later. Then

P (X  ) = P (exp (X)  exp ())

 E [exp (X)] exp (-)

 exp

22 2

-



.

Choosing  = /2 completes the proof.

(Markov's inequality) (Def. of subgaussianity)

5.3 The Cram´er-Chernoff Method and Subgaussian Random Variables

77

A similar inequality holds for the left tail. By using the union bound P (A  B)  P (A) + P (B), we also find that P (|X|  )  2 exp(-2/(22)). An equivalent form of these bounds is

P X  22 log(1/)   P |X|  22 log(2/)   .

This form is often more convenient and especially the latter, which for small  shows that with overwhelming probability X takes values in the interval

- 22 log(2/), 22 log(2/) .

To study the tail behaviour of µ^ - µ, we need one more lemma.

Lemma 5.4. Suppose that X is -subgaussian and X1 and X2 are independent and 1 and 2-subgaussian, respectively, then:
(a) E[X] = 0 and V [X]  2. (b) cX is |c|-subgaussian for all c  R. (c) X1 + X2 is 12 + 22-subgaussian.
The proof of the lemma is left to the reader (Exercise 5.7). Combining Lemma 5.4 and Theorem 5.3 leads to a straightforward bound on the tails of µ^ - µ.

Corollary 5.5. Assume that Xi - µ are independent, -subgaussian random variables. Then for any   0,

P (µ^  µ + )  exp

-

n2 22

and

P (µ^  µ - )  exp

-

n2 22

,

where

µ^

=

1 n

n t=1

Xt

.

Proof By Lemma 5.4, it holds that µ^-µ = Then apply Theorem 5.3.

n i=1

(Xi

-µ)/n

is

/n-subgaussian.

For x > 0, it holds that exp(-x)  1/(ex), which shows that the above inequality is stronger than what we obtained via Chebyshev's inequality except when  is very small. It is exponentially smaller if n2 is large relative to 2. The deviation form of the above result says that under the conditions of the result, for any   [0, 1], with probability at least 1 - ,

µ  µ^ +

22

log(1/) n

.

Symmetrically, it also follows that with probability at least 1 - ,

(5.6)

µ  µ^ -

22

log(1/) n

.

Again, one can use a union bound to derive a two-sided inequality.

(5.7)

Example 5.6. The following random variables are subgaussian:

5.4 Notes

78

(a) If X is Gaussian with mean zero and variance 2, then X is -subgaussian.
(b) If X has mean zero and |X|  B almost surely for B  0, then X is B-subgaussian.
(c) If X has mean zero and X  [a, b] almost surely, then X is (b - a)/2subgaussian.
If X is exponentially distributed with rate  > 0, then X is not -subgaussian for any   R.
For random variables that are not centred (E [X] = 0), we abuse notation by saying that X is -subgaussian if the noise X - E [X] is -subgaussian. A distribution is called -subgaussian if a random variable drawn from that distribution is -subgaussian. Subgaussianity is really a property of both a random variable and the measure on the space on which it is defined, so the nomenclature is doubly abused.

5.4 Notes

1 The Berry­Esseen theorem (independently discovered by Berry [1941] and

Esseen [1942]) quantifies the speed of convergence in the CLT. It essentially

says at a

that rate

the of

1d/istannucendbeertwseoemnethmeiGldauassssiuamn patnidontshe(saecetuEaxl edricsitsreib5u.t5i)o.nTdhecisayiss

known to be tight for the class of probability distributions that appear in the

Berry­Esseen result. themselves are much

Hsmowalelevrert,htahnis1i/sanv.aHcueonucse

result when the tail probabilities the need for concrete finite-time

results.

2 Theorem 5.3 shows that subgaussian random variables have tails that decay almost as fast as a Gaussian. A version of the converse is also possible. That is, if a centered random has tails that behave in a similar way to a Gaussian, then it is subgaussian. In particular, the following holds: let X be a centered random variable (E[X] = 0) with P (|X|  )  2 exp(-2/2). Then X is

5.4 Notes

79

 5-subgaussian:

E[exp(X)] = E

 iXi i=0 i!


1+ E
i=2



1+

P

i=2 0

|X |



i!1/i 

x1/i

dx


1+2
i=2


exp
0

-

i!2/ix2/i 22

dx

 = 1 + 2

exp(2/2)

1 + erf



2

 exp

52 2

.

i |X |i i!
-1

(Exercise 2.19) (by assumption) (by Mathematica)

This bound is surely loose. At the same time, there is little room for

improvement: if X has exp(-2/2). And yet X

density p(x) = |x| exp(-x2 is at best 2-subgaussian,

/2)/2, then P (|X| so some degree of

 ) slack

= is

required (see Exercise 5.4).

3 We saw in (5.4) that if X1, X2, . . . , Xn are independent standard Gaussian

random

variables

and

µ^

=

1 n

nt=1, then

P (µ^  ) 

2 2n2

exp

-

n2 22

.

If n2/2 is relatively large, then this bound is marginally stronger than exp(-n2/(22)), which follows from the subgaussian analysis. One might ask whether or not a similar improvement is possible more generally. And Talagrand [1995] will tell you: yes! At least for bounded random variables (details in the paper).
4 Hoeffding's lemma states that for a zero-mean random variable X such that X  [a, b] almost surely for real values a < b, then MX ()  exp(2(b - a)2/8). Applying the Cram´er­Chernoff method shows that if X1, X2, . . . , Xn are independent and Xt  [at, bt] almost surely with at < bt for all t, then

P

1 n

n
(Xt
t=1

-

E[Xt])





 exp

-2n22 tn=1(bt - at)2

.

(5.8)

The above is called Hoeffding's inequality. For details see Exercise 5.11.

There are many variants of this result that provide tighter bounds when X

satisfies certain additional distributional properties like small variance (see

Exercise 5.14).

5 The Cram´er­Chernoff method is applicable beyond the subgaussian case, even

when the moment-generating function is not defined globally. One example

where this occurs is when X1, X2, . . . , Xn are independent standard Gaussian

and Y =

n i=1

Xi2.

Then

Y

has a 2-distribution with n degrees of freedom.

5.5 Bibliographical Remarks

80

An easy calculation shows that MY () = (1 - 2)-n/2 for   [0, 1/2) and MY () is undefined for   1/2. By the Cram´er­Chernoff method, we have

P (Y  n + )  inf M(Y ) exp(-(n + ))
[0,1/2)

n

 inf
[0,1/2)

1 1 - 2

2
exp(-(n + ))

Choosing

=

1 2

-

n 2(n+)

leads

to

P (Y

 n + ) 

1

+

 n

n
2 exp

-

 2

, which

turns out to be about the best you can do [Laurent and Massart, 2000].

6 The subgaussian concept provides a large class of distributions for which

concentration is easily analysed. As mentioned, however, many distributions

are not subgaussian, like the exponential and 2-distribution. There are other

general notions based on bounds on the moment generating function that

generalise these kinds of distributions. For more on these ideas, you should

look for keywords subexponential and subgamma.

5.5 Bibliographical Remarks
We return to concentration of measure many times, but note here that it is an interesting (and still active) topic of research. What we have seen is only the tip of the iceberg. Readers who want to learn more about this exciting field might enjoy the book by Boucheron et al. [2013]. For matrix versions of many standard results, there is a recent book by Tropp [2015]. The survey of McDiarmid [1998] has many of the classic results. There is a useful type of concentration bound that are `self-normalised' by the variance. A nice book on this is by de la Pen~a et al. [2008]. Another tool that is occasionally useful for deriving concentration bounds in more unusual set-ups is called empirical process theory. There are several references for this, including those by van de Geer [2000] or Dudley [2014].

5.6 Exercises

There are too many candidate exercises to list. We heartily recommend all the exercises in chapter 2 of the book by Boucheron et al. [2013].

5.1 (Variance of average) Let X1, X2, . . . , Xn be a sequence of independent

and identically distributed random variables with mean µ and variance 2 < .

Let

µ^

=

1 n

n t=1

Xt

and

show

that

V[µ^]

=

E[(µ^

-

µ)2]

=

2/n.

5.2 (Markov's inequality) Prove Markov's inequality (Lemma 5.1).

5.3 Compare the Gaussian tail probability bound on the right-hand side of (5.4) and the one on (5.2). What values of  make one smaller than the other? Discuss your findings.

5.6 Exercises

81

5.4 Let X be a random variable on R with density with respect to the Lebesgue measure of p(x) = |x| exp(-x2/2)/2. Show the following:
(a) P (|X|  ) = exp(-2/2). (b) X is not (2 - )-subgaussian for any  > 0.

5.5 (Berry­Esseen inequality) Let X1, X2, . . . , Xn be a sequence of independent and identically distributed random variables with mean µ, variance 2 and bounded third absolute moment:

Let Sn =

 = E[|X1 - µ|3] <  .

n t=1

(Xt

-

µ)/.

The

Berry­Esseen

theorem

shows

that

sup P
x

Sn n



x

- 1 2

x
exp(-y2/2)dy
-



C  n

,

(x)

where C < 1/2 is a universal constant.

(a)

Let µ^n

=

1 n

n t=1

Xt

and

derive

a

tail

bound

from

the

Berry­Esseen

theorem.

That is, give a bound of the form P (µ^n  µ + ) for positive values of .

(b) Compare your bound with the one that can be obtained from the Cram´er­

Chernoff method. Argue pro- and contra- for the superiority of one over the

other.

5.6 (Central limit theorem) We mentioned that invoking the CLT to approximate the distribution of sums of independent Bernoulli random variables using a Gaussian can be a bad idea. Let X1, . . . , Xn  B(p) be independent Bernoulli random variables with common mean p = pn = /n, where   (0, 1). For x  N natural number, let Pn(x) = P (X1 + · · · + Xn = x).
(a) Show that limn Pn(x) = e-x/(x!), which is a Poisson distribution with parameter .
(b) Explain why this does not contradict the CLT, and discuss the implications of the Berry­Esseen.
(c) In what way does this show that the CLT is indeed a poor approximation in some cases?
(d) Based on Monte Carlo simulations, plot the distribution of X1 + · · · + Xn for n = 30 and some well-chosen values of . Compare the distribution to what you would get from the CLT. What can you conclude?

5.7 (Properties of subgaussian random variables (i)) Prove Lemma 5.4.

Hint Use Taylor series.
5.8 (Properties of subgaussian random variables (ii)) Let Xi be isubgaussian for i  {1, 2} with i  0. Prove that X1+X2 is (1+2)-subgaussian. Do not assume independence of X1 and X2.

5.6 Exercises

82

5.9 (Properties of moment/cumulative-generating functions) Let X be a real-valued random variable and let MX () = E [exp(X)] be its momentgenerating function defined over dom(MX )  R, where the expectation takes on finite values. Show that the following properties hold:

(a) MX is convex, and in particular dom(MX ) is an interval containing zero.

(b) MX ()  eE[X] for all   dom(MX ).

(c) For any  in the interior of dom(MX ), MX is infinitely many times

differentiable.

(d) Let MX(k)()

=

dk dk

MX

().

Then,

for



in

the

interior

of

dom(MX ),

M (k)() = E Xk exp(X) .

(e) Assuming 0 is in the interior of dom(MX ), MX(k)(0) = E Xk (hence the name of MX ).

(f) X is convex (that is, MX is log-convex).

Hint For part (a), use the convexity of x  ex.

5.10 (Large deviation theory) Let X, X1, X2, . . . , Xn be a sequence of

independent and identically distributed random variables with zero mean and

moment-generating

function

MX

with

dom(MX )

=

R.

Let

µ^n

=

1 n

n t=1

Xt

.

(a) Show that for any  > 0,

1 n

log

P

(µ^n



)



-X ()

=

-

sup


(

-

log

MX ())

.

(5.9)

(b) Show that when X is a Rademacher variable (P (X = -1) = P (X = 1) =

1/2),

X ()

=

1+ 2

log(1 + ) +

1- 2

log(1 - )

when

||

<

1

and

X ()

=

+,

otherwise.

(c) Show that when X is a centered Bernoulli random variable with parameter p (that is, P (X = -p) = 1 - p and P (X = 1 - p) = p) then X () =  when  is such that p +  > 1 and X () = d(p + , p) otherwise, where d(p, q) = p log(p/q) + (1 - p) log((1 - p)/(1 - q)) is the relative entropy

between the distributions B(p) and B(q).

(d) Show that when X  N (0, 2) then X () = 2/(22). (e) Let 2 = V[X]. The (strong form of the) central limit theorem says that

lim sup P
n xR

µ^n

n 2



x

- (1 - (x)) = 0 ,

where

(x)

=

1 2

x -

exp(-y2/2)dy

is

the

cumulative

distribution

of

the

standard Gaussian. Let Z be a random variable distributed like a standard

Gaussian. A careless application of this result might suggest that

lim
n

1 n

log

P

(µ^n



)

=?

lim
n

1 n

log

P

Z 

n 2

.

Evaluate the right-hand side. In light of the previous parts, what can you

5.6 Exercises

83

conclude about the validity of the question-marked equality? What goes wrong with the careless application of the central limit theorem? What do you conclude about the accuracy of this theorem?
Hint For Part ((e)), consider using Eq. (13.4).
As it happens, the inequality in (5.9) may be replaced by an equality as n  . The assumption that the moment-generating function exists everywhere may be relaxed significantly. We refer the interested reader to the classic text by Dembo and Zeitouni [2009]. The function X is called the Legendre transform, convex conjugate or Fenchel dual of the convex function X . In probability theory, X is also called the Cram´er transform and is also known as a rate function. Convexity and the Fenchel dual will play a role in some of the later chapters and will be discussed in more detail in Chapter 26 and later.

The name "large deviation" originates from rewriting the tail probabilities in

terms of the partial sum Sn = X1+· · ·+Xn, we see that the inequality in (5.9)

bounds the probability of the deviation of Sn from its mean (which is zero by assumption) at a scale of (n): P (µ^n  ) = P (Sn  n). In contrast, the

central-limit theorem (CLT) gives of Sn from its mean at the scales

otfhe((limni)t:inPg()µ^pnrobnabilit)y=ofPth(Sendeviatnion).

Compared to n, n is thought of as a "large" deviation. The deviation

probabilities at this scale can decay to zero faster than what the CLT

predicts, as also showcased in the last part of the last exercise. But what

happens at intermediate scales? That is, when deviations are of size n with

1/2 <  < n? This is studied on the formulaic name of moderate deviations.

As it turns out, in this case, the ruthless use of the large deviation formula

gives correct answers. The reader who wants to learn more about large

deviation theory can check out the lecture notes by Swart [2017].

5.11 (Hoeffding's lemma) Suppose that X is zero mean and X  [a, b] almost surely for constants a < b.
(a) Show that X is (b - a)/2-subgaussian. (b) Prove Hoeffding's inequality (5.8).
Hint For part (a), it suffices to prove that X ()  2(b - a)2/4. By Taylor's theorem, for some  between 0 and , X () = X (0) + X (0) + X ( )2/2. To bound the last term, introduce the distribution P for   R arbitrary: P(dz) = e-X()ezP (dz). Show that X () = V[Z], where Z  P. Now,

5.6 Exercises

84

since Z  [a, b] with probability one, argue (without relying on E [Z]) that V[Z]  (b - a)2/4.

5.12 (Subgaussianity of Bernoulli distribution) Let X be a random variable with Bernoulli distribution with mean p. That is X  B(p): P (X = 1) = p and P (X = 0) = 1 - p.

(a) Show that X is 1/2-subgaussian for all p.

(b) Let Q : [0, 1]  [0, 1/2] be the function given by Q(p) =

1-2p 2 ln((1-p)/p)

where undefined points are defined in terms of their limits. Show that X is

Q(p)-subgaussian.

(c) The subgaussianity constant of a random variable X is the smallest value of

 such that X is -subgaussian. Show that the subgaussianity constant of

X  B(p) is Q(p).

(d) Plot Q(p) as a function of p. How does it compare to V[X] = p(1 - p)? (e) Show that for   0 and p  1/2, Eexp(X)  exp(p(1 - p)2/2). Think of

how these inequalities are used for bounding tails. What do you conclude?

Readers looking for a hint to parts (b), (c) and (e) in the previous exercise might like to look at the papers by Berend and Kontorovich [2013] and Ostrovsky and Sirota [2014]. The result that the subgaussianity constant of X  B(p) is upper bounded by Q(p) is known as the Kearn-Saul inequality and is due to Kearns and Saul [1998].

5.13 (Central limit theorem for sums of Bernoulli random variables)

In this question we try to understand the concentration of the empirical mean

for Bernoulli random variables. Let X1, X2, . . . , Xn be independent Bernoulli

random variables with mean p  [0, 1] and p^n =

n t=1

Xt/n.

Let

Zn

be

normally

distributed random variable with mean p and variance p(1 - p)/n.

(a) Write down expressions for E[p^n] and V[p^n]. (b) What does the central limit theorem say about the relationship between p^n
and Zn as n gets large?
(c) For each p  {1/10, 1/2} and  = 1/100 and  = 1/10, find the minimum n such that P (p^n  p + )  .
(d) Let p = 1/10 and  = 1/10 and

nBer(, p, ) = min {n : P (p^n  p + )  } , nGauss(, p, ) = min {n : P (Zn  p + )  } .

(i) Evaluate analytically the value of

lim
0

nBer(, 1/10, 1/10) nGauss(, 1/10, 1/10)

.

5.6 Exercises

85

(ii) In light of the central limit theorem, explain why the answer you got in (i) was not 1.

Hint For Part (d.i) use large deviation theory (Exercise 5.10).

5.14 (Bernstein's inequality) Let X1, . . . , Xn be a sequence of independent

random variables with Xt - E[Xt]  b almost surely and S =

and v =

n t=1

V[Xt].

n t=1

(Xt

-

E[Xt])

(a)

Show

that

g(x) =

1 2

+

x 3!

+

x2 4!

+ · · · = (exp(x) - 1 - x)/x2

is

increasing.

(b) Let X be a random variable with E[X] = 0 and X  b almost surely. Show

that E[exp(X)]  1 + g(b)V[X].

(c)

Prove

that

(1 + ) log(1 + ) -  

32 6+2

for

all



0.

Prove

that

this

is

the best possible approximation in the sense that the 2 in the denominator

cannot be increased.

(d) Let  > 0 and  = b/v and prove that

P (S  )  exp

-

v b2

((1

+

)

log(1

+

)

-

)

(5.10)

 exp

- 2v

2

1

+

b 3v

.

(5.11)

(e) Use the previous result to show that

P S

2v log

1 

+

2b 3

log

1 

 .

(f) Let be X1, X2, . . . , Xn be a sequence of random variables adapted to

filtration F = (Ft)t. Abbreviate Et[·] = E[· | Ft] and µt = Et-1[Xt]. Define

S=

n t=1

Xt

variation of (

- µt
p t=1

and let V Xt - µt)p.

=

n t=1

Et-1[(Xt

-

µt)2]

be

the

predictable

Show that if Xt - µt  b holds almost surely

for all t  [n] then with  = b/v,

P (S  , V  v)  exp

-

v b2

((1

+

)

log(1

+

)

-

)

.

Note that the right-hand side of this inequality is the same as that shown in

Eq. (5.10).

The bound in Eq. (5.10) is called Bennett's inequality and the one in Eq. (5.11) is called Bernstein's inequality. There are several generalisations, the most notable of which is the martingale version that slightly relaxes the independence assumption and which was presented in Part (f). Martingale techniques appear in Chapter 20. Another useful variant (under slightly different conditions) replaces the actual variance with the empirical variance. This is useful when the variance is unknown. For more, see the papers by Audibert et al. [2007], Mnih et al. [2008], Maurer and Pontil [2009].

5.6 Exercises

86

5.15 (Another Bernstein-type inequality) Let X1, X2, . . . , Xn be a sequence of random variables adapted to the filtration F = (Ft)t. Abbreviate Et[·] = E[· | Ft] and µt = Et-1[Xt]. Prove the following

(a) If  > 0 and (Xt - µt)  1 almost surely, then

P

n
(Xt - µt)  

n

Et-1[(Xt

-

µt)2]

+

1 

log

t=1

t=1

(b) If  > 0 and Xt  1 almost surely, then

P

n
(Xt - µt)  

n

Et-1[Xt2]

+

1 

log

1 

t=1

t=1

1 

 .

 .

Hint Use the Cram´er­Chernoff method and the fact that exp(x)  1 + x + x2 for all x  1 and exp(x)  1 + x for all x.

Let (Mt) be the martingale defined by Mt = ts=1(Xs -µs). The inequalities in Exercise 5.15 can be viewed as a kind of Bernstein's inequality because

they bound the tail of the martingale (Mt) in terms of the predictable

variation of the martingale (Mt), which is V =

n t=1

Et-1[(Xt

-

µt)2].

The main difference relative to well-known results is that the analysis has

stopped early. The next step is usually to choose  to minimise the bound

in some sense. Either by assuming bounds on the predictable variation,

union bounding or using the method of mixtures [de la Pen~a et al., 2008].

These techniques are covered in Chapter 20. Note, optimising  directly is

not possible because the bounds hold for any fixed , but minimising the

right-hand side inside the probability with respect to  would lead to a

random . For more martingale results with this flavour, see the notes by

McDiarmid [1998].

5.16 Let X1, . . . , Xn be independent random variables with P (Xt  x)  x for each x  [0, 1] and t  [n]. Prove for any  > 0 that

P

n
log(1/Xt)  



 n

n
exp(n - ) .

t=1

5.17 (Concentration for categorical distributions) Let X1, . . . , Xn be

an independent and identically distributed sequence taking values in [m]. For

i



[m],

let

p(i)

=

P (X1

=

i)

and

p^(i)

=

1 n

n t=1

I

{Xt

=

i}.

Show

that

for

any

  (0, 1),





P  p - p^ 1 

2 log

1 

+ m log(2) n

  .

(5.12)

5.6 Exercises

87

Hint Use the fact that p - p^ 1 = max{-1,1}m , p - p^ .
5.18 (Expectation of maximum) Let X1, . . . , Xn be a sequence of subgaussian random variables (possibly dependent) and Z = maxt[n] Xt. Prove that
(a) E[Z]  22 log(n). (b) P Z  22 log(n/)   for any   (0, 1).

Hint Use Jensen's inequality to show that exp(E[Z])  E[exp(Z)], and then provide a naive bound on the moment-generating function of Z.

5.19 (Almost surely bounded sums) Let X1, X2, . . . , Xn be a sequence of non-

negative random variables adapted to filtration (Ft)tn=0 such that

n t=1

Xt



1

almost surely. Prove that for all x > 1,

P

n
E[Xt | Ft-1]  x
t=1





fn(x)

=.

 0

n-x n-1
,

n-1
,

if x < n ; if x  n ,

where the equality serves as the definition of fn(x).

Hint This problem does not use the techniques introduced in the chapter. Prove that Bernoulli random variables are the worst case and use backwards induction. Although this result is new to our knowledge, a weaker version was derived by Kirschner and Krause [2018] for the analysis of information-directed sampling. The bound is tight in the sense that there exists a sequence of random variables and filtration for which equality holds.

Part II
Stochastic Bandits with Finitely Many Arms

89
Over the next few chapters, we introduce the fundamental algorithms and tools of analysis for unstructured stochastic bandits with finitely many actions. The keywords here are finite, unstructured and stochastic. The first of these just means that the number of actions available is finite. The second is more ambiguous, but roughly means that choosing one action yields no information about the mean pay-off of the other arms. A bandit is stochastic if the sequence of rewards associated with each action is independent and identically distributed according to some distribution. This latter assumption will be relaxed in Part III.
There are several reasons to study this class of bandit problems. First, their simplicity makes them relatively easy to analyse and permits a deep understanding of the trade-off between exploration and exploitation. Second, many of the algorithms designed for finite-armed bandits, and the principle underlying them, can be generalised to other settings. Finally, finite-armed bandits already have applications ­ notably as a replacement to A/B testing, as discussed in the introduction.

6 The Explore-Then-Commit Algorithm
The first bandit algorithm of the book is called explore-then-commit (ETC), which explores by playing each arm a fixed number of times and then exploits by committing to the arm that appeared best during exploration.
For this chapter, as well as Chapters 7 to 9, we assume that all bandit instances are in ESkG(1), which means the reward distribution for all arms is 1-subgaussian.
The focus on subgaussian distributions is mainly for simplicity. Many of the techniques in the chapters that follow can be applied to other stochastic bandits such as those listed in Table 4.1. The key difference is that new concentration analysis is required that exploits the different assumptions. The Bernoulli case is covered in Chapter 10, where other situations are discussed along with references to the literature. Notice that the subgaussian assumption restricts the subgaussian constant to  = 1, which saves us from endlessly writing . All results hold for other subgaussian constants by scaling the rewards (see Lemma 5.4). Two points are obscured by this simplification:
(a) All the algorithms that follow rely on the knowledge of . (b) It may happen that Pi is subgaussian for all arms, but with a different
subgaussian constant for each arm. Algorithms are easily adapted to this situation if the subgaussian constants are known, as you will investigate in Exercise 7.2. The situation is more complicated when the subgaussian constant is unknown (Exercise 7.7).
6.1 Algorithm and Regret Analysis
ETC is characterised by the number of times it explores each arm, denoted by a natural number m. Because there are k actions, the algorithm will explore for mk rounds before choosing a single action for the remaining rounds. Let µ^i(t) be the

6.1 Algorithm and Regret Analysis

91

average reward received from arm i after round t, which is written formally as

µ^i(t)

=

1 Ti(t)

t
I {As
s=1

=

i} Xs ,

where Ti(t) =

t s=1

I

{As

=

i}

is

the

number

of

times

action

i

has

been

played

after round t. The ETC policy is given in Algorithm 1 below.

1: Input m. 2: In round t choose action

At =

(t mod k) + 1 , argmaxi µ^i(mk) ,

if t  mk ; t > mk .

(ties in the argmax are broken arbitrarily)

Algorithm 1: Explore-then-commit.

Recall that µi is the mean reward when playing action i and i = µ - µi is suboptimality gap between the mean of action i and the optimal action.

Theorem 6.1. When ETC is interacting with any 1-subgaussian bandit and 1  m  n/k,

k

k

Rn  m i + (n - mk) i exp

i=1

i=1

-

mi2 4

.

Proof Assume without loss of generality that the first arm is optimal, which means that µ1 = µ = maxi µi. By the decomposition given in Lemma 4.5, the
regret can be written as

k
Rn = iE [Ti(n)] .
i=1

(6.1)

In the first mk rounds, the policy is deterministic, choosing each action exactly m times. Subsequently it chooses a single action maximising the average reward during exploration. Thus,

E [Ti(n)] = m + (n - mk)P (Amk+1 = i)

 m + (n - mk)P

µ^i(mk)



max
j=i

µ^j (mk)

.

The probability on the right-hand side is bounded by

(6.2)

P

µ^i(mk)



max
j=i

µ^j

(mk)

 P (µ^i(mk)  µ^1(mk))

= P (µ^i(mk) - µi - (µ^1(mk) - µ1)  i) .

The next step is to check that µ^i(mk) - µi - (µ^1(mk) - µ1) is 2/m-subgaussian,

6.1 Algorithm and Regret Analysis

92

which by the properties of subgaussian random variables follows from the definitions of (µ^j)j and the algorithm. Hence by Corollary 5.5,

P (µ^i(mk) - µi - µ^1(mk) + µ1  i)  exp

-

m2i 4

.

(6.3)

Substituting Eq. (6.3) into Eq. (6.2) and the regret decomposition (Eq. (6.1)) gives the result.

The bound in Theorem 6.1 illustrates the trade-off between exploration and exploitation. If m is large, then the policy explores for too long, and the first term will be large. On the other hand, if m is too small, then the probability that the algorithm commits to the wrong arm will grow, and the second term becomes large. The question is how to choose m. Assume that k = 2 and that the first arm is optimal so that 1 = 0, and abbreviate  = 2. Then the bound in Theorem 6.1 simplifies to

Rn  m + (n - 2m) exp

-

m2 4

 m + n exp

-

m2 4

.

(6.4)

For large n the quantity on the right-hand side of Eq. (6.4) is minimised up to a possible rounding error by

m = max

1,

4 2

log

n2 4

,

(6.5)

and for this choice and any n, the regret is bounded by

Rn  min

n,



+

4 

1 + max

0, log

n2 4

.

(6.6)

In Exercise 6.2 you will show that Eq. (6.6) implies that 
Rn   + C n ,

(6.7)

where C > 0 is a universal constant. In particular, when   1 as is often assumed, we get
 Rn  1 + C n ,

Bounds of this type are called worst-case, problem free or problem independent (see Eq. (4.2) or Eq. (4.3)). The reason is that the bound only depends on the horizon and class of bandits for which the algorithm is designed, and not the specific instance within that class. Because the suboptimality gap does not appear, bounds like this are sometimes called gap-free. In contrast, bounds like the one in Eq. (6.6) are called gap/problem/distribution/instance dependent.
Note that without the condition   1, the worst-case bound for ETC is infinite. In fact, without a bound on the reward range, the worst-case bound of all reasonable algorithms (that try each action at least once) will also be infinite. With the understanding that Eq. (6.7) gives rise to a meaningful worst-case

6.1 Algorithm and Regret Analysis

93

bound for bandits with bounded reward range, we take the liberty and will also call bounds like that in Eq. (6.7) a worst-case bound.
The bound in (6.6) is close to optimal (see Part IV), but there is a caveat. The choice of m that defines the policy and leads to this bound depends on both the suboptimality gap and the horizon. While the horizon is sometimes known in advance, it is seldom reasonable to assume knowledge of the suboptimality gap. You will show in Exercise 6.5 that there is a choice of m depending only on n, for which Rn = O(n2/3) regardless of the value of . Alternatively, the number of plays before commitment can be made data dependent, which means the learner plays arms alternately until it decides based on its observations to commit to a single arm for the remainder (Exercise 6.5). ETC also has the property that its immediate expected regret per time step is monotonically decreasing as time goes by, though not in a nice smooth fashion. This monotone decreasing property is a highly desirable property. In later chapters we will see policies where the decrease is smoother.
Experiment 6.1 Fig. 6.1 shows the expected regret of ETC when playing a Gaussian bandit with k = 2 and means µ1 = 0 and µ2 = -. The horizon is set to n = 1000, and the suboptimality gap  is varied between 0 and 1. Each data point is the average of 105 simulations, which makes the error bars invisible. The results show that the theoretical upper bound provided by Theorem 6.1 is quite close to the actual performance.

Upper bound in (6.6)

80

ETC with m in (6.5)

Expected regret

60

40

20

0

0.2

0.4

0.6

0.8

1



Figure 6.1 The expected regret of ETC and the upper bound in Eq. (6.6).

6.2 Notes

94

6.2 Notes
1 An algorithm is called anytime if it does not require advance knowledge of the horizon n. ETC is not anytime because the choice of commitment time depends on the horizon. This limitation can be addressed by the doubling trick, which is a simple way to convert a horizon-dependent algorithm into an anytime algorithm (Exercise 6.6).
2 By allowing the exploration time m to be a data-dependent random variable, it is possible to recover near-optimal regret without knowing the suboptimality gap. For more details see Exercise 6.5. Another idea is to use an elimination algorithm that acts in phases and eliminates arms using increasingly sensitive hypothesis tests (Exercise 6.8). Elimination algorithms are often easy to analyse and can work well in practice, but they also have inherent limitations, just like ETC algorithms, as will be commented on later.
3 The -greedy algorithm is a randomised relative of ETC that in round t plays the empirically best arm with probability 1 - t and otherwise explores uniformly at random. You will analyse this algorithm in Exercise 6.7.
6.3 Bibliographical Remarks
ETC has a long history. Robbins [1952] considered `certainty equivalence with forcing', which chooses the arm with the largest sample mean except at a fixed set of times Ti  N when arm i is chosen for i  [k]. By choosing the set of times carefully, it is shown that this policy enjoys sublinear regret. While ETC performs all the exploration at the beginning, Robbins's policy spreads the exploration over time. This is advantageous if the horizon is not known, but disadvantageous otherwise. Anscombe [1963] considered exploration and commitment in the context of medical trials or other experimental set-ups. He already largely solves the problem in the Gaussian case and highlights many of the important considerations. Besides this, the article is beautifully written and well worth reading. Strategies based on exploration and commitment are simple to implement and analyse. They can also generalise well to more complex settings. For example, Langford and Zhang [2008] consider this style of policy under the name `epoch-greedy' for contextual bandits (the idea of exploring then exploiting in epochs, or intervals, is essentially what Robbins [1952] suggested). We'll return to contextual bandits in Chapter 18. Abbasi-Yadkori et al. [2009], Abbasi-Yadkori [2009b] and Rusmevichientong and Tsitsiklis [2010] consider ETC-style policies under the respective names of `forced exploration' and `phased exploration and greedy exploitation' (PEGE) in the context of linear bandits (which we shall meet in Chapter 19). Other names include `forced sampling', `explore-first', `explorethen-exploit'. Garivier et al. [2016b] have shown that ETC policies are necessarily suboptimal in the limit of infinite data in a way that is made precise in Chapter 16. This comment also applies to elimination-based strategies, which are described in

6.4 Exercises

95

Exercise 6.8. The history of -greedy is unclear, but it is a popular and widely used and known algorithm in reinforcement learning [Sutton and Barto, 1998]. Auer et al. [2002a] analyse the regret of -greedy with slowly decreasing exploration probabilities. There are other kinds of randomised exploration as well, including Thompson sampling [1933] and Boltzmann exploration analysed recently by Cesa-Bianchi et al. [2017].

6.4 Exercises

6.1 (Subgaussian empirical estimates) Let  be the policy of ETC and P1, . . . , Pk be the 1-subgaussian distributions associated with the k arms. Provide a fully rigourous proof of the claim that

µ^i(mk) - µi - µ^1(mk) + µ1

is 2/m-subgaussian. You should only use the definitions and the interaction protocol, which states that

(a) P (At  · | A1, X1, . . . , At-1, Xt-1) = (· | A1, X1, . . . , At-1, Xt-1) a.s. (b) P (Xt  · | A1, X1, . . . , At-1, Xt-1, At) = PAt (·) a.s.
6.2 (Minimax regret) Show that Eq. (6.6) implies the regret of anoptimally tuned ETC for subgaussian two-armed bandits satisfies Rn   + C n where C > 0 is a universal constant.

6.3 (High-probability bounds (i)) Assume that k = 2, and let   (0, 1).

Modify the ETC algorithm to depend on  and prove a bound on the pseudo-

regret R¯n = nµ -

n t=1

µAt

of

ETC

that

holds

with

probability

1 - .

The

algorithm is allowed to use the action suboptimality gaps.

6.4 (High-probability bounds (ii)) Repeat the previous exercise, but now

prove a high probability bound on the random regret: R^n = nµ -

n t=1

Xt.

Compare this to the bound derived for the pseudo-regret in the previous exercise.

What can you conclude?

6.5 (Adaptive commitment times) Suppose that ETC interacts with a twoarmed 1-subgaussian bandit   E with means µ1, µ2  R and  = |µ1 - µ2|.

(a) Find a choice of m that only depends on the horizon n and not  such that there exists a constant C > 0 such that for any n and for any   E, the regret Rn() of Algorithm 1 is bounded by
Rn()  ( + C)n2/3 .
Furthermore, show that there is no C > 0 such that for any problem instance  and n  1, Rn()   + Cn2/3 holds.

6.4 Exercises

96

(b) Now suppose the commitment time is allowed to be data dependent, which means the algorithm explores each arm alternately until some condition is met and then commits to a single arm for the remainder. Design a condition such that the regret of the resulting algorithm can be bounded by

Rn()





+

C log 

n

,

(6.8)

where C is a universal constant. Your condition should only depend on the observed rewards and the time horizon. It should not depend on µ1, µ2 or  .
(c) Show that any algorithm for which (6.8) holds also satisfies Rn()   + C n log(n) for any n  1 and   E and a suitably chosen universal constant C > 0.
(d) As for (b), but now the objective is to design a condition such that for any n  1 and   E, the regret of the resulting algorithm is bounded by

Rn()





+

C

log

max 

e,

n2

.

(6.9)

(e) Show that any algorithm for which (6.9) holds also satisfies that for any n  1 and   E, Rn()   + C n for suitably chosen universal constant C > 0.

Hint For (a) start from Rn  m + n exp(-m2/2) and show an upper bound on the second term which is independent of . Then, choose m. For (b) think about the simplest stopping policy and then make it robust by using confidence intervals. Tune the failure probability. For (c) note that the regret can never be larger than n.

6.6 (Doubling trick) The purpose of this exercise is to analyse a meta-algorithm based on the so-called doubling trick that converts a policy depending on the horizon to a policy with similar guarantees that does not. Let E be an arbitrary set of bandits. Suppose you are given a policy  = (n) designed for E that accepts the horizon n as a parameter and has a regret guarantee of

max
1tn

Rt((n),

)



fn()

,

  E ,

where fn : E  [0, ) is a sequence of functions. Let n1 < n2 < n3 < · · · be a fixed sequence of integers and consider the policy that runs  with horizon n1 until round t = min{n, n1}, then runs  with horizon n2 until t = min{n, n1 +n2}, and then restarts again with horizon n3 until t = min{n, n1 + n2 + n3} and so-on. Note that t is the real-time counter and is not reset on each restart. Let  be the
resulting policy. When n +1 = 2n , the length of periods when  is used double with each phase, hence the name `doubling trick'.

(a) Let n > 0 be arbitrary, max = min{ : i=1 ni  n}. Prove that for any

6.4 Exercises

97

  E, the n-horizon regret of dbl on  is at most

max
Rn(, )  fn () .

(6.10)

=1

(b)

Suppose

that

fn()



 n.

Show

that

if

n

= 2 -1, then for any   E and

horizon n the regret of dbl is at most

Rn(,

)



 Cn

,

where C > 0 is a carefully chosen universal constant. (c) Suppose that fn() = g() log(n) for some function g : E  [0, ). What is
the regret of  if n = 2 -1? Can you find a better choice of (n ) ? (d) In light of this idea, should we bother trying to design algorithms that do not
depend on the horizon? Are there any disadvantages to using the doubling trick? If so, what are they? Write a short summary of the pros and cons of the doubling trick.

According to Besson and Kaufmann [2018], the doubling trick was first applied to bandits by Auer et al. [1995]. Note, nowhere in this exercise did we use that the bandit is stochastic. Nothing changes in the adversarial or contextual settings studied later in the book.

6.7 (-greedy) For this exercise assume the rewards are 1-subgaussian and there are k  2 arms. The -greedy algorithm depends on a sequence of
parameters 1, 2, . . .. First it chooses each arm once and subsequently chooses At = argmaxi µ^i(t - 1) with probability 1 - t and otherwise chooses an arm uniformly at random.

(a)

Prove

that

if

t

=  > 0,

then

lim
n

Rn n

=

 k

k

i.

i=1

(b) Let min = min {i : i > 0} and let t = min

1,

Ck t2min

, where C > 0 is

a sufficiently large universal constant. Prove that there exists a universal

C > 0 such that

k
Rn  C
i=1

i

+

i m2 in

log

max

e,

nm2 in k

.

6.8 (Elimination algorithm) A simple way to generalise the ETC policy to multiple arms and overcome the problem of tuning the commitment time is to use an elimination algorithm. The algorithm operates in phases and maintains an active set of arms that could be optimal. In the th phase, the algorithm aims to eliminate from the active set all arms i for which i  2- .
Without loss of generality, assume that arm 1 is an optimal arm. You may assume that the horizon n is known.

6.4 Exercises

98

1: Input: k and sequence (m ) 2: A1 = {1, 2, . . . , k} 3: for = 1, 2, 3, . . . do 4: Choose each arm i  A exactly m times 5: Let µ^i, be the average reward for arm i from this phase only 6: Update active set:

A +1 =

i : µ^i,

+ 2-



max
jA

µ^j,

7: end for

Algorithm 2: Phased elimination for finite-armed bandits

(a) Show that for any  1,

P (1 / A +1, 1  A )  k exp

-m

2-2 4

.

(b) Show that if i  [k] and  1 are such that i  2- , then

P (i  A +1, 1  A , i  A )  exp

-m

(i - 2- 4

)2

.

(c) Let i = min  1 : 2-  i/2 . Choose m in such a way that P (exists : 1 / A )  1/n and P (i  A i+1)  1/n.
(d) Show that your algorithm has regret at most

Rn  C
i:i >0

i

+

1 i

log(n)

,

where C > 0 is a carefully chosen universal constant. (e) Modify your choice of m and show that the regret of the resulting algorithm
satisfies

Rn  C
i:i >0

i

+

1 i

log

max

e, ni2

.

(f) Show that with an appropriate universal constant C > 0, the regret satisfies

Rn  i + C nk log(k) .
i

Algorithm 2 is due to Auer and Ortner [2010]. The log(k) term in Part (f) can be removed by modifying the algorithm to use the refined confidence intervals in Chapter 9, but we would not recommend this for the reasons discussed in Section 9.2 of that chapter. You could also use a more sophisticated confidence level [Lattimore, 2018].

6.4 Exercises

99

ETC 70

Expected regret

60

50

0

100

200

300

400

m

Figure 6.2 Expected regret for ETC over 105 trials on a Gaussian bandit with means µ1 = 0, µ2 = -1/10

6.9 (Empirical study) In this exercise you will investigate the empirical behaviour of ETC on a two-armed Gaussian bandit with means µ1 = 0 and µ2 = -. Let
n
R¯n = At ,
t=1
which is chosen so that Rn = E[R¯n]. Complete the following:
(a) Using programming language of your choice, write a function that accepts an integer n and  > 0 and returns the value of m that exactly minimises the expected regret.
(b) Reproduce Fig. 6.1. (c) Fix  = 1/10 and plot the expected regret as a function of m with n = 2000.
Your plot should resemble Fig. 6.2. (d) Plot the standard deviation V[R¯n]1/2 as a function of m for the same bandit
as above. Your plot should resemble Fig. 6.3. (e) Explain the shape of the curves you observed in Parts (b), (c) and (d) and
reconcile what you see with the theoretical results. (f) Think, experiment and plot. Is it justified to plot V[R¯n]1/2 as a summary of
how R¯n is distributed? Explain your thinking.

6.4 Exercises

100

Standard deviation of the regret

100 ETC
80

60

40

0

100

200

300

400

m

Figure 6.3 Standard deviation of the regret for ETC over 105 trials on a Gaussian bandit with means µ1 = 0, µ2 = -1/10

7 The Upper Confidence Bound Algorithm
The upper confidence bound (UCB) algorithm offers several advantages over the explore-then-commit (ETC) algorithm introduced in the last chapter.
(a) It does not depend on advance knowledge of the suboptimality gaps. (b) It behaves well when there are more than two arms. (c) The version introduced here depends on the horizon n, but in the next
chapter, we will see how to eliminate that as well.
The algorithm has many different forms, depending on the distributional assumptions on the noise. Like in the previous chapter, we assume the noise is 1-subgaussian. A serious discussion of other options is delayed until Chapter 10.
7.1 The Optimism Principle
The UCB algorithm is based on the principle of optimism in the face of uncertainty, which states that one should act as if the environment is as nice as plausibly possible. As we shall see in later chapters, the principle is applicable beyond the finite-armed stochastic bandit problem.
Imagine visiting a new country and making a choice between sampling the local cuisine or visiting a well-known multinational chain. Taking an optimistic view of the unknown local cuisine leads to exploration because without data, it could be amazing. After trying the new option a few times, you can update your statistics and make a more informed decision. On the other hand, taking a pessimistic view of the new option discourages exploration, and you may suffer significant regret if the local options are delicious. Just how optimistic you should be is a difficult decision, which we explore for the rest of the chapter in the context of finite-armed bandits.
For bandits, the optimism principle means using the data observed so far to assign to each arm a value, called the upper confidence bound that with high probability is an overestimate of the unknown mean. The intuitive reason why this leads to sublinear regret is simple. Assuming the upper confidence bound assigned to the optimal arm is indeed an overestimate, then another arm can only be played if its upper confidence bound is larger than that of the optimal arm, which in turn is larger than the mean of the optimal arm. And yet this cannot

7.1 The Optimism Principle

102

happen too often because the additional data provided by playing a suboptimal

arm means that the upper confidence bound for this arm will eventually fall

below that of the optimal arm.

In order to make this argument more precise, we need to define the upper

confidence bound. Let (Xt)nt=1 be a sequence of independent 1-subgaussian random

variables

with

mean

µ

and

µ^

=

1 n

n t=1

Xt.

By

Eq.

(5.6),

P µ  µ^ +

2 log(1/) n



for all   (0, 1) .

(7.1)

When considering its options in round t, the learner has observed Ti(t - 1)

samples from arm i and received rewards from that arm with an empirical mean

of µ^i(t - 1). Then a reasonable candidate for `as large as plausibly possible' for

the unknown mean of the ith arm is  
UCBi(t - 1, ) = µ^i(t - 1) +

2 log(1/) Ti (t-1)

if Ti(t - 1) = 0 otherwise .

(7.2)

Great care is required when comparing (7.1) and (7.2) because in the former the number of samples is the constant n, but in the latter it is a random variable Ti(t - 1). By and large, however, this is merely an annoying technicality, and the intuition remains that  is approximately an upper bound on the probability of the event that the above quantity is an underestimate of the true mean. More details are given in Exercise 7.1.
At last we have everything we need to state a version of the UCB algorithm, which takes as input the number of arms and the error probability .

1: Input k and  2: for t  1, . . . , n do 3: Choose action At = argmaxi UCBi(t - 1, ) 4: Observe reward Xt and update upper confidence bounds 5: end for
Algorithm 3: UCB().

Although there are many versions of the UCB algorithm, we often do not distinguish them by name and hope the context is clear. For the rest of this chapter, we'll usually call UCB() just UCB.
The value inside the argmax is called the index of arm i. Generally speaking, an index algorithm chooses the arm in each round that maximises some value (the index), which usually only depends on the current time step and the samples from that arm. In the case of UCB, the index is the sum of the empirical mean

7.1 The Optimism Principle

103

of rewards experienced so far and the exploration bonus, which is also known as the confidence width.
Besides the slightly vague `optimism guarantees optimality or learning' intuition we gave before, it is worth exploring other intuitions for the choice of index. At a very basic level, an algorithm should explore arms more often if they are (a) promising because µ^i(t - 1) is large or (b) not well explored because Ti(t - 1) is small. As one can plainly see, the definition in Eq. (7.2) exhibits this behaviour. This explanation is not completely satisfying, however, because it does not explain why the form of the functions is just so.
A more refined explanation comes from thinking of what we expect of any reasonable algorithm. Suppose at the start of round t the first arm has been played much more frequently than the rest. If we did a good job designing our algorithm, we would hope this is the optimal arm, and because it has been played so often, we expect that µ^1(t - 1)  µ1. To confirm the hypothesis that arm 1 is optimal, the algorithm had better be highly confident that other arms are indeed worse. This leads quite naturally to the idea of using upper confidence bounds. The learner can be reasonably certain that arm i is worse than arm 1 if

µ^i(t - 1) +

2 log(1/) Ti(t - 1)



µ1



µ^1(t

-

1)

+

2 log(1/) T1(t - 1)

,

(7.3)

where  is called the confidence level and quantifies the degree of certainty. This means that choosing the arm with the largest upper confidence bound leads to a situation where arms are only chosen if their true mean could reasonably be larger than those of arms that have been played often. That this rule is indeed a good one depends on two factors. The first is whether the width of the confidence interval at a given confidence level can be significantly decreased, and the second is whether the confidence level is chosen in a reasonable fashion. For now, we will take a leap of faith and assume that the width of confidence intervals for subgaussian bandits cannot be significantly improved from what we use here (we shall see that this holds in later chapters), and concentrate on choosing the confidence level now.

Choosing the confidence level is a delicate problem, and we will analyse a number of choices in future chapters. The basic difficulty is that  should be small enough to ensure optimism with high probability, but not so large that suboptimal arms are explored excessively.

Nevertheless, as a first cut, the choice of this parameter can be guided by the following considerations. If the confidence interval fails and the index of an optimal arm drops below its true mean, then it could happen that the algorithm stops playing the optimal arm and suffers linear regret. This suggests we might choose   1/n so that the contribution to the regret of this failure case is relatively small. Unfortunately things are not quite this simple. As we have

7.1 The Optimism Principle

104

already alluded to, one of the main difficulties is that the number of samples Ti(t - 1) in the index (7.2) is a random variable, and so our concentration results cannot be immediately applied. For this reason we will see that (at least naively)  should be chosen a bit smaller than 1/n.

Theorem 7.1. Consider UCB as shown in Algorithm 3 on a stochastic k-armed 1-subgaussian bandit problem. For any horizon n, if  = 1/n2, then

Rn



3

k i=1

i

+

i:i >0

16 log(n) i

.

Before the proof we need a little more notation. Let (Xti)t[n],i[k] be a collection

of independent random variables with the law of Xti equal to Pi. Then define

µ^is

=

1 s

s u=1

Xui

to

be

the

empirical

mean

based

on

the

first

s

samples.

We

make use of the third model in Section 4.6 by assuming that the reward in round

t is

Xt = XTAt (t)At .
Then we define µ^i(t) = µ^iTi(t) to be the empirical mean of the ith arm after round t. The proof of Theorem 7.1 relies on the basic regret decomposition identity,

k
Rn = iE [Ti(n)] .

(Lemma 4.5)

i=1

The theorem will follow by showing that E [Ti(n)] is not too large for suboptimal

arms i. The key observation is that after the initial period where the algorithm

chooses each action once, action i can only be chosen if its index is higher than

that of an optimal arm. This can only happen if at least one of the following is

true:

(a) The index of action i is larger than the true mean of a specific optimal arm. (b) The index of a specific optimal arm is smaller than its true mean.

Since with reasonably high probability the index of any arm is an upper bound on its mean, we don't expect the index of the optimal arm to be below its mean. Furthermore, if the suboptimal arm i is played sufficiently often, then its exploration bonus becomes small and simultaneously the empirical estimate of its mean converges to the true value, putting an upper bound on the expected total number of times when its index stays above the mean of the optimal arm. The proof that follows is typical for the analysis of algorithms like UCB, and hence we provide quite a bit of detail so that readers can later construct their own proofs.

Proof of Theorem 7.1 Without loss of generality, we assume the first arm is optimal so that µ1 = µ. As noted above,

k
Rn = iE [Ti(n)] .
i=1

(7.4)

7.1 The Optimism Principle

105

The theorem will be proven by bounding E[Ti(n)] for each suboptimal arm i. We make use of a relatively standard idea, which is to decouple the randomness from
the behaviour of the UCB algorithm. Let Gi be the `good' event defined by

Gi =

µ1 < min UCB1(t, )
t[n]



µ^iui +

2 ui

log

1 

< µ1 ,

where ui  [n] is a constant to be chosen later. So Gi is the event when µ1 is never underestimated by the upper confidence bound of the first arm, while at the same time the upper confidence bound for the mean of arm i after ui observations are taken from this arm is below the pay-off of the optimal arm. We will show two things:

1 If Gi occurs, then arm i will be played at most ui times: Ti(n)  ui.
2 The complement event Gci occurs with low probability (governed in some way yet to be discovered by ui).

Because Ti(n)  n no matter what, this will mean that E [Ti(n)] = E [I {Gi} Ti(n)] + E [I {Gci } Ti(n)]  ui + P (Gci ) n .

(7.5)

The next step is to complete our promise by showing that Ti(n)  ui on Gi and that P (Gci ) is small. Let us first assume that Gi holds and show that Ti(n)  ui, which we do by contradiction. Suppose that Ti(n) > ui. Then arm i was played
more than ui times over the n rounds, and so there must exist a round t  [n]
where Ti(t - 1) = ui and At = i. Using the definition of Gi,

UCBi(t - 1, ) = µ^i(t - 1) +

2 log(1/) Ti(t - 1)

= µ^iui +

2 log(1/) ui

< µ1

< UCB1(t - 1, ) .

(definition of UCBi(t - 1, ))
(since Ti(t - 1) = ui) (definition of Gi) (definition of Gi)

Hence At = argmaxj UCBj(t - 1, ) = i, which is a contradiction. Therefore if Gi occurs, then Ti(n)  ui. Let us now turn to upper bounding P (Gic). By its definition,

Gci =

µ1  min UCB1(t, )
t[n]

   µ^iui +



2 log(1/) ui



 µ1

.

(7.6)

7.1 The Optimism Principle

106

The first of these sets is decomposed using the definition of UCB1(t, ),

µ1



min
t[n]

UCB1(t,

)



µ1



min
s[n]

µ^1s

+

2 log(1/) s

=

µ1  µ^1s +

2 log(1/) s

.

s[n]

Then using a union bound and the concentration bound for sums of independent

subgaussian random variables in Corollary 5.5, we obtain:





P

µ1



min
t[n]

UCB1(t,

)

 P

µ1  µ^1s +

s[n]

2 log(1/)  s

n
 P µ1  µ^1s +
s=1

2 log(1/) s

 n .

(7.7)

The next step is to bound the probability of the second set in (7.6). Assume that ui is chosen large enough that

i -

2 log(1/) ui



ci

(7.8)

for some c  (0, 1) to be chosen later. Then, since µ1 = µi + i, and using

Corollary 5.5,







P µ^iui +

2 log(1/) ui



µ1

=

P µ^iui

-

µi



i

-

2 log(1/)  ui

 P (µ^iui - µi  ci)  exp

- uic2i2 2

.

Taking this together with (7.7) and (7.6), we have

P (Gci )  n + exp

-

uic22i 2

.

When substituted into Eq. (7.5), we obtain

E [Ti(n)]  ui + n

n + exp

-

uic22i 2

.

(7.9)

It remains to choose ui  [n] satisfying (7.8). A natural choice is the smallest integer for which (7.8) holds, which is

ui =

2 log(1/) (1 - c)22i

.

This choice of ui can be larger than n, but in this case Eq. (7.9) holds trivially

7.1 The Optimism Principle

107

since Ti(n)  n. Then, using the assumption that  = 1/n2 and this choice of ui leads via (7.9) to

E[Ti(n)]  ui + 1 + n1-2c2/(1-c)2 =

2 log(n2) (1 - c)22i

+ 1 + n1-2c2/(1-c)2 . (7.10)

All that remains is to choose c  (0, 1). The second term will contribute a polynomial dependence on n unless 2c2/(1 - c)2  1. However, if c is chosen too close to 1, then the first term blows up. Somewhat arbitrarily we choose c = 1/2, which leads to

E [Ti(n)]



3

+

16

log(n) 2i

.

The result follows by substituting the above display in Eq. (7.4).

As we saw for the ETC strategy, the regret bound in Theorem 7.1 depends on the reciprocal of the gaps, which may be meaningless when even a single suboptimal action has a very small suboptimality gap. As before, one can also prove a sublinear regret bound that does not depend on the reciprocal of the gaps.

Theorem 7.2. If  = 1/n2, then the regret of UCB, as defined in Algorithm 3, on any   ESkG(1) environment, is bounded by

k
Rn  8 nk log(n) + 3 i .
i=1

Proof Let  > 0 be some value to be tuned subsequently, and recall from the proof of Theorem 7.1 that for each suboptimal arm i, we can bound

E[Ti(n)]



3

+

16

log(n) i2

.

Therefore, using the basic regret decomposition again (Lemma 4.5), we have

k
Rn = iE [Ti(n)] =

iE [Ti(n)] +

iE [Ti(n)]

i=1

i:i <

i:i 

 n +
i:i 

3i

+

16

log(n) i



n

+

16k

log(n) 

+

3

i

i

k

 8 nk log(n) + 3 i ,

i=1

where the first inequality follows because i:i< Ti(n)  n and the last line by choosing  = 16k log(n)/n.

The additive i i term is unavoidable because no reasonable algorithm can avoid playing each arm once (try to work out what would happen if it did not).
In any case, this term does not grow with the horizon n and is typically negligible.

7.1 The Optimism Principle

108

Expected regret

100

ETC (m = 25)

ETC (m = 50)

80

ETC (m = 75)

ETC (m = 100)

60

ETC (optimal m)

UCB

40

20

0 0.2 0.4 0.6 0.8 1 

Figure 7.1 Experiment showing universality of UCB relative to fixed instances of ETC

As it happens, Theorem 7.2 is close to optimal. We will see in Chapter 15 that no algorithm can enjoy regret smaller than O( nk) over all problems in ESkG(1). In Chapter 9 we will also see a more complicated variant of Algorithm 3 that shaves the logarithmic term from the upper bound given above.
Experiment 7.1 We promised that UCB would overcome the limitations of ETC by achieving the same guarantees but without prior knowledge of the suboptimality gaps. The theory supports this claim, but just because two algorithms have similar theoretical guarantees does not mean they perform the same empirically. The theoretical analysis might be loose for one algorithm and maybe not the other, or by a different margin. For this reason it is always wise to prove lower bounds (which we do later) and compare the empirical performance, which we do (very briefly) now.
The set-up is the same as in Fig. 6.1, which has n = 1000 and k = 2 and unit variance Gaussian rewards with means 0 and - respectively. The plot in Fig. 7.1 shows the expected regret of UCB relative to ETC for a variety of choices of commitment time m. The expected regret of ETC with the optimal choice of m (which depends on the knowledge of  and that the pay-offs are Gaussian, cf. Fig. 6.1) is also shown.
The results demonstrate a common phenomenon. If ETC is tuned with the optimal choice of commitment time for each choice of , then it outperforms the parameter-free UCB, though only by a relatively small margin. If, however, the commitment time must be chosen without the knowledge of , then ETC will usually not outperform UCB. As it happens, a variant of UCB introduced in the next chapter actually outperforms even the optimally tuned ETC.

7.2 Notes

109

7.2 Notes

1 The choice of  = 1/n2 led to an easy analysis, but comes with two disadvantages. First of all, it turns out that a slightly smaller value of  improves the regret (and empirical performance). Secondly, the dependence on n means the horizon must be known in advance, which is often not reasonable. Both of these issues are resolved in the next chapter, where  is chosen to be smaller and to depend on the current round t rather than n. Nonetheless ­ as promised ­ Algorithm 3 with  = 1/n2 does achieve a regret bound similar to the ETC strategy, but without requiring knowledge of the gaps.
2 The assumption that the rewards generated by each arm are independent can be relaxed significantly. All of the results would go through by assuming there exists a mean reward vector µ  Rk such that

E[Xt | X1, A1, . . . , At-1, Xt-1, At] = µAt a.s. . E[exp((Xt - µAt )) | X1, A1, . . . , At-1, Xt-1, At]  exp(2/2) a.s. .

(7.11) (7.12)

Eq. (7.11) is just saying that the conditional mean of the reward in round t only depends on the chosen action. Eq. (7.12) ensures that the tails of Xt are conditionally subgaussian. That everything still goes through is proven using martingale techniques, which we develop in detail in Chapter 20.
3 So is the optimism principle universal? Does it always lead to policies with strong guarantees in more complicated settings? Unfortunately the answer turns out to be no. The optimism principle usually leads to reasonable algorithms when (i) any action gives feedback about the quality of that action and (ii) no action gives feedback about the value of other actions. When (i) is violated, even sublinear regret may not be guaranteed. When (ii) is violated, an optimistic algorithm may avoid actions that lead to large information gain and low reward, even when this trade-off is optimal. An example where this occurs is provided in Chapter 25 on linear bandits. Optimism can work in more complex models as well, but sometimes fails to appropriately balance exploration and exploitation.
4 When thinking about future outcomes, humans and some animals often have higher expectations than are warranted by past experience or conditions of the environment. This phenomenon, a form of cognitive bias, is known as the optimism bias in the psychology and behavioural economics literature and is in fact `one of the most consistent, prevalent, and robust biases documented in psychology and behavioral economics' [Sharot, 2011a]. While much has been written about this bias in these fields, and one of the current explanations of why the optimism bias is so prevalent is that it helps exploration, to our best knowledge, the connection to the deeper mathematical justification of optimism, pursued here and in other parts of this book, has so far escaped the attention of researchers in all the relevant fields.

7.3 Bibliographical Remarks

110

7.3 Bibliographical Remarks
The use of confidence bounds and the idea of optimism first appeared in the work by Lai and Robbins [1985]. They analysed the asymptotics for various parametric bandit problems (see the next chapter for more details on this). The first version of UCB is by Lai [1987]. Other early work is by Katehakis and Robbins [1995], who gave a very straightforward analysis for the Gaussian case, and Agrawal [1995], who noticed that all that was needed is an appropriate sequence of upper confidence bounds on the unknown means. In this way, their analysis is significantly more general than what we have done here. These researchers also focused on the asymptotics, which at the time was the standard approach in the statistics literature. The UCB algorithm was independently discovered by Kaelbling [1993], although with no regret analysis or clear advice on how to tune the confidence parameter. The version of UCB discussed here is most similar to that analysed by Auer et al. [2002a] under the name UCB1, but that algorithm used t rather than n in the confidence level (see the next chapter). Like us, they prove a finite-time regret bound. However, rather than considering 1-subgaussian environments, Auer et al. [2002a] considers bandits where the pay-offs are confined to the [0, 1] interval, which are ensured to be 1/2-subgaussian. See Exercise 7.2 for hints on what must change in this situation. The basic structure of the proof of our Theorem 7.1 is essentially the same as that of theorem 1 of Auer et al. [2002a]. The worst-case bound in Theorem 7.2 appeared in the book by Bubeck and Cesa-Bianchi [2012], which also popularised the subgaussian set-up. We did not have time to discuss the situation where the subgaussian constant is unknown. There have been several works exploring this direction. If the variance is unknown, but the noise is bounded, then one can replace the subgaussian concentration bounds with an empirical Bernstein inequality [Audibert et al., 2007]. For details, see Exercise 7.6. If the noise has heavy tails, then a more serious modification is required, as discussed in Exercise 7.7 and the note that follows.
We found the article by Sharot [2011a] on optimism bias from the psychology literature quite illuminating. Readers looking to dive deeper into this literature may enjoy the book by the same author [Sharot, 2011b]. Optimism bias is also known as `unrealistic optimism', a term that is most puzzling to us ­ what bias is ever realistic? The background of this is explained by Jefferson et al. [2017].

7.4 Exercises

7.1 (Concentration for sequences of random length) In this exercise,

we investigate one of the more annoying challenges when analyzing sequential

algorithms. Let X1, X2, . . . be a sequence of independent standard Gaussian

random variables defined on probability space (, F, P). Suppose that T :  

{1, 2, 3, . . .} is another random variable, and let µ^ =

T t=1

Xt/T

be

the

empirical

mean based on T samples.

7.4 Exercises

111

(a) Show that if T is independent from Xt for all t, then

P µ^ - µ 

2 log(1/) T

 .

(b) Now relax the assumption that T is independent from (Xt)t. Let Et = I {T = t} be the event that T = t and Ft = (X1, . . . , Xt) be the -algebra generated by the first t samples. Let   (0, 1) and show there exists a T
such that for all t  {1, 2, 3, . . .} it holds that Et is Ft-measurable and

P µ^ - µ 

2 log(1/) T

= 1.

(c) Show that

P µ^ - µ 

2 log(T (T + 1)/) T

 .

(7.13)

Hint For part (b) above, you may find it useful to apply the law of the iterated logarithm, which says if X1, X2, . . . is a sequence of independent and identically distributed random variables with zero mean and unit variance, then

lim sup
n



n t=1

Xt

2n log log

n

=

1

almost surely .

This result is especially remarkable because it relies on no assumptions other than zero mean and unit variance. You might wonder if Eq. (7.13) might continue to hold if log(T (T + 1)/) were replaced by log(log(T )/). It almost does, but the proof of this fact is more sophisticated. For more details, see the paper by Garivier [2013] or Exercise 20.9.

7.2 (Relaxing the subgaussian assumption) In this chapter, we assumed the pay-off distributions were 1-subgaussian. The purpose of this exercise is to relax this assumption.

(a) First suppose that 2 > 0 is a known constant and that   ESkG(2). Modify the UCB algorithm and state and prove an analogue of Theorems 7.1 and 7.2
for this case. (b) Now suppose that  = (Pi)ki=1 is chosen so that Pi is i-subgaussian where
(i2)ki=1 are known. Modify the UCB algorithm and state and prove an analogue of Theorems 7.1 and 7.2 for this case.
(c) If you did things correctly, the regret bound in the previous part should not depend on the values of {i2 : i = 0}. Explain why not.

7.3 (High-probability bounds) Recall from Chapter 4 that the pseudo-regret is defined to be the random variable
n
R¯n = At .
t=1

7.4 Exercises

112

The UCB policy in Algorithm 3 depends on confidence parameter   (0, 1] that determines the level of optimism. State and prove a bound on the pseudo-regret of this algorithm that holds with probability 1 - f (n, k), where f (n, k) is a function, that depends on n and k only. More precisely show that for bandit   ESkG(1) that
P R¯n  g(n, , )  f (n, k) ,
where g and f should be as small as possible (there are trade-offs ­ try and come up with a natural choice).
7.4 (Phased UCB (i)) Fix a 1-subgaussian k-armed bandit environment and a horizon n. Consider the version of UCB that works in phases of exponentially increasing length of 1, 2, 4, . . .. In each phase, the algorithm uses the action that would have been chosen by UCB at the beginning of the phase (see Algorithm 4 below).

(a) State and prove a bound on the regret for this version of UCB. (b) Compare your result with Theorem 7.1. (c) How would the result change if the th phase had a length of 
 > 1?

with

1: Input k and  2: Choose each arm once 3: for = 1, 2, . . . do 4: Compute A = argmaxi UCBi(t - 1, ) 5: Choose arm A exactly 2 times 6: end for
Algorithm 4: A phased version of UCB.

7.5 (Phased UCB (ii)) Let  > 1 and consider the version of UCB that first plays each arm once. Thereafter it operates in the same way as UCB, but rather than playing the chosen arm just once, it plays it until the number of plays of that arm is a factor of  larger (see Algorithm 5 below).
(a) State and prove a bound on the regret for version of UCB with  = 2 (doubling counts).
(b) Compare with the result of the previous exercise and with Theorem 7.1. What can you conclude?
(c) Repeat the analysis for  > 1. What is the role of ? (d) Implement these algorithms and compare them empirically to UCB().

7.4 Exercises

113

1: Input k and  2: Choose each arm once 3: for = 1, 2, . . . do 4: Let t = t 5: Compute A = argmaxi UCBi(t - 1, ) 6: Choose arm A until round t such that Ti(t)  Ti(t - 1) 7: end for
Algorithm 5: A phased version of UCB.

The algorithms of the last two exercises may seem ridiculous. Why would you wait before updating empirical estimates and choosing a new action? There are at least two reasons:
(a) It can happen that the algorithm does not observe its rewards immediately, but rather they appear asynchronously after some delay. Alternatively many bandits algorithms may be operating simultaneously and the results must be communicated at some cost.
(b) If the feedback model has a more complicated structure than what we examined so far, then even computing the upper confidence bound just once can be quite expensive. In these circumstances, it's comforting to know that the loss of performance by updating the statistics only rarely is not too severe.

7.6 (Adapting to reward variance in bandits with bounded rewards)

Let X1, X2, . . . , Xn be a sequence of independent and identically distributed

random variables with mean µ and variance 2 and bounded support so that

Xt  [0, b] almost surely. Let µ^ =

n t=1

Xt/n

and

^2

=

n t=1

(µ^

-

Xt)2/n.

The

empirical Bernstein inequality says that for any   (0, 1),

P |µ^ - µ| 

2^2 n

log

3 

+

3b n

log

3 

 .

(a)

Show

that

^2

=

1 n

n t=1

(Xt

-

µ)2

-

(µ^

-

µ)2.

(b) Show that V[(Xt - µ)2]  b22.

(c) Use Bernstein's inequality (Exercise 5.14) to show that

P ^2  2 +

2b22 n

log

1 

+

2b2 3n

log

1 

 .

(d) Suppose that  = (i)ki=1 is a bandit where Supp(i)  [0, b] and the variance of the ith arm is i2 (with our earlier notation,   E[k0,b]). Design a policy

7.4 Exercises

114

that depends on b, but not i2 such that

Rn  C
i:i >0

i +

b

+

i2 i

log(n)

,

where C > 0 is a universal constant.

(7.14)

If you did things correctly, then the policy you derived in Exercise 7.6 should resemble UCB-V by Audibert et al. [2007]. The proof of the empirical Bernstein also appears there or (with slightly better constants) in the papers by Mnih et al. [2008] and Maurer and Pontil [2009].

It is worth comparing (7.14) to the result of Theorem 7.1. In particular,

recall that if the rewards are bounded by b, the reward distributions are

b-subgaussian. The regret of UCB which adjusts the confidence intervals

accordingly can then be shown to be Rn = O(

i:i >0

b

log(n) i

).

Thus,

the

main advantage of the policy of the previous exercise is the replacement of

b/i

in

this

bound

with

b

+

. i2
i

In

Exercise

16.7,

you

will

show

that

this

is

essentially unimprovable.

7.7 (Median of means and bandits with known finite variance) Let n  N+ and (Ai)im=1 be a partition of [n] so that im=1Ai = [n] and Ai  Aj =  for all i = j. Suppose that   (0, 1) and X1, X2, . . . , Xn is a sequence of independent random variables with mean µ and variance 2. The
median-of-means estimator µ^M of µ is the median of µ^1, µ^2, . . . , µ^m, where
µ^i = tAi Xt/|Ai| is the mean of the data in the ith block.

(a) Show that if m =

min

n 2

,

8

log

e1/8 

sized as possible, then

and Ai are chosen as equally

P µ^M +

1922 n

log

e1/8 

µ .

(b) Use the median-of-means estimator to design an upper confidence bound algorithm such that for all   EVk(2),

Rn  C
i:i >0

i

+

2

log(n) i

,

where C > 0 is a universal constant.

7.4 Exercises

115

This exercise shows that the subgaussian assumption can be relaxed to requiring only finite variance at the price of increased constant factors. The result is only possible by replacing the standard empirical estimator with something more robust. The median-of-means estimator is only one way to do this. In fact, the empirical estimator can be made robust by truncating the observed rewards and applying the empirical Bernstein concentration inequality. The disadvantage of this approach is that choosing the location of truncation requires prior knowledge about the approximate location of the mean. Another approach is Catoni's estimator, which also exhibits excellent asymptotic properties [Catoni, 2012]. Yet another idea is to minimise the Huber loss [Sun et al., 2017]. This latter paper is focussing on linear models, but the results still apply in one dimension. The application of these ideas to bandits was first made by Bubeck et al. [2013a], where the reader will find more interesting results. Most notably, that things can still be made to work even if the variance does not exist. In this case, however, there is a price to be paid in terms of the regret. The median-of-means estimator is due to Alon et al. [1996]. In case the variance is also unknown, then it may be estimated by assuming a known bound on the kurtosis, which covers many classes of bandits (Gaussian with arbitrary variance, exponential and many more), but not some simple cases (Bernoulli). The policy that results from this procedure has the benefit of being invariant under the transformations of shifting or scaling the losses [Lattimore, 2017].
7.8 (Empirical comparison)
(a) Implement Algorithm 3. (b) Reproduce Fig. 7.1. (c) Explain the shape of the curves for ETC. In particular, when m = 50, we
see a bump, a dip and then a linear asymptote as  grows. Why does the curve look like this? (d) Design an experiment to determine the practical effect of the choice of . (e) Explain your results.

8 The Upper Confidence Bound Algorithm: Asymptotic Optimality

The algorithm analysed in the previous chapter is not anytime. This shortcoming is resolved via a slight modification and a refinement of the analysis. The improved analysis leads to constant factors in the dominant logarithmic term that match a lower bound provided later in Chapter 16.

8.1 Asymptotically Optimal UCB
The algorithm studied is shown in Algorithm 6. It differs from the one analysed in the previous section (Algorithm 3) only by the choice of the confidence level, the choice of which is dictated by the analysis of its regret.

1: Input k 2: Choose each arm once 3: Subsequently choose

At = argmaxi µ^i(t - 1) +

2 log f (t) Ti(t - 1)

where f (t) = 1 + t log2(t)

Algorithm 6: Asymptotically optimal UCB.

The regret bound for Algorithm 6 is more complicated than the bound for Algorithm 3 (see Theorem 7.1). The dominant terms in the two results have the same order, but the gain here is that in this result the leading constant, governing the asymptotic rate of growth of regret, is smaller.

Theorem 8.1. For any 1-subgaussian bandit, the regret of Algorithm 6 satisfies





Rn



inf i 1 +
i:i>0 (0,i)

5 2

+

2

log f (n) +  log f (n) + 1 (i - )2

.

(8.1)

8.1 Asymptotically Optimal UCB

117

Furthermore,

lim sup
n

Rn log(n)



i:i >0

2 i

.

(8.2)

Choosing  = i/2 inside the sum shows that

Rn 
i:i >0

i

+

1 i

8 log f (n) + 8

 log f (n) + 28

.

(8.3)

Even more concretely, there exists some universal constant C > 0 such that

Rn  C
i:i >0

i

+

log(n) i

,

which by the same argument as in the proof of Theorem 7.2 leads a worst-case

bound of Rn  C

k i=1

i

+

2

Cnk log(n).

Taking the limit of the ratio of the bound in (8.3) and log(n) does not result in the same constant as in the theorem, which is the main justification for introducing the more complicated regret bound. You will see in Chapter 15 that the asymptotic bound on the regret given in (8.2) is unimprovable in a strong sense.

We start with a useful lemma to bound the number of times the index of a suboptimal arm will be larger than some threshold above its mean.

Lemma 8.2. Let X1, . . . , Xn be a sequence of independent 1-subgaussian random

variables,

µ^t

=

1 t

t s=1

Xs,



>

0,

a

>

0

and

n
 = I µ^t +
t=1

2a t





,

n

 =u+

I µ^t +

t= u

2a t





,

where

u

=

2a-2.

Then

it

holds

E[]



E[

]



1

+

2 2

(a

+

 a

+

1).

The intuition for this result is as follows. Since the Xi are 1-subgaussian and independent we have E[µ^t] = 0, so we cannot expect µ^t + 2a/t to be smaller than  until t is at least 2a/2. The lemma confirms that this is the right order as an estimate for E [].

Proof By Corollary 5.5 we have

n

E[]  E[ ] = u +

P µ^t +

t= u

2a t







2

u+

n

exp - t

- 2

2a t



t= u



2

1+u+

 exp - t
u

- 2

2a t



dt

=

1

+

2 2

(a

+

 a

+

1)

,

8.1 Asymptotically Optimal UCB

118

 where the final equality follows by making the substitution s =  t - 2a and substituting the value of u from the lemma statement.

Proof of Theorem 8.1 As usual, the starting point is the fundamental regret decomposition (Lemma 4.5),

Rn =

iE[Ti(n)] .

i:i >0

The rest of the proof revolves around bounding E[Ti(n)]. Let i be a suboptimal arm. The main idea is to decompose Ti(n) into two terms. The first measures the number of times the index of the optimal arm is less than µ1 - . The second term measures the number of times that At = i and its index is larger than µ1 - .

n

n

Ti(n) = I {At = i}  I µ^1(t - 1) +

t=1

t=1

2 log f (t) T1(t - 1)



µ1

-



n
+ I µ^i(t - 1) +
t=1

2 log f (t) Ti(t - 1)



µ1

-

and

At

=

i

. (8.4)

The proof of the first part of the theorem is completed by bounding the expectation of each of these two sums. Starting with the first, we again use Corollary 5.5:

n

E

I µ^1(t - 1) +

t=1

2 log f (t) T1(t - 1)



µ1

-



nn



P

t=1 s=1

µ^1s + 



n t=1

n s=1

exp

- s

2 log f (t) s



µ1

-

2

2 log f (t) s

+



2





n t=1

1 f (t)

n s=1

exp

-

s2 2



5 2

.

The first inequality follows from the union bound over all possible values of T1(t - 1). The last inequality is an algebraic exercise (Exercise 8.1). The function f (t) was chosen precisely so this bound would hold. For the second term in (8.4)

8.2 Notes

119

we use Lemma 8.2 to get

n

E

I µ^i(t - 1) +

t=1

2 log f (t) Ti(t - 1)



µ1

-



and

At

=

i

n

E

I µ^i(t - 1) +

t=1

2 log f (n) Ti(t - 1)



µ1

-



and

At

=

i

n

E

I µ^is +

s=1

2 log f (n) s



µ1

-



n

=E

I µ^is - µi +

s=1

2 log f (n) s



i

-





1

+

(i

2 -

)2

log f (n) +

 log f (n) + 1 .

The first part of the theorem follows by substituting the results of the previous two displays into (8.4). The second part follows by choosing  = log-1/4(n) and
taking the limit as n tends to infinity.

8.2 Notes
1 The improvement to the constants comes from making the confidence interval slightly smaller, which is made possible by a more careful analysis. The main trick is the observation that we do not need to show that µ^1s  µ1 for all s with high probability, but instead that µ^1s  µ1 -  for small .
2 The choice of f (t) = 1 + t log2(t) looks quite odd. With a slightly messier calculation we could have chosen f (t) = t log(t) for any  > 0. If the rewards are actually Gaussian, then a more careful concentration analysis allows one to choose f (t) = t or even some slightly slower-growing function [Katehakis and Robbins, 1995, Lattimore, 2016a, Garivier et al., 2016b].
3 The asymptotic regret is often indicative of finite-time performance. The reader is advised to be cautious, however. The lower-order terms obscured by the asymptotics can be dominant in all practical regimes.

8.3 Bibliographic Remarks
Lai and Robbins [1985] designed policies for which Eq. (8.2) holds. They also proved a lower bound showing that no `reasonable' policy can improve on this bound for any problem, where `reasonable' means that they suffer subpolynomial regret on all problems (see Part IV). The policy proposed by Lai and Robbins [1985] was based on upper confidence bounds, but was not a variant of UCB. The asymptotics for variants of the policy presented here were given first by Lai [1987],

8.4 Exercises

120

Katehakis and Robbins [1995] and Agrawal [1995]. None of these articles gave finite-time bounds like what was presented here. When the reward distributions lie in an exponential family, then asymptotic and finite-time bounds with the same flavor to what is presented here are given by Capp´e et al. [2013]. There are now a huge variety of asymptotically optimal policies in a wide range of settings. Burnetas and Katehakis [1996] study the general case and give conditions for a version of UCB to be asymptotically optimal. Honda and Takemura [2010, 2011] analyse an algorithm called DMED, proving asymptotic optimality for noise models where the support is bounded or semi-bounded. Kaufmann et al. [2012b] prove asymptotic optimality for Thompson sampling (see Chapter 36) when the rewards are Bernoulli, which is generalised to single-parameter exponential families by Korda et al. [2013]. Kaufmann [2018] proves asymptotic optimality for the BayesUCB class of algorithms for single-parameter exponential families. M´enard and Garivier [2017] prove asymptotic optimality and minimax optimality for exponential families (more discussion in Chapter 9).

8.4 Exercises

8.1 Do the algebra needed at the end of the proof of Theorem 8.1. Precisely, show that

n t=1

1 f (t)

n s=1

exp

-

s2 2



5 2

,

where f (t) = 1 + t log2(t).

Hint

First bound F =

n s=1

exp(-s2/2)

using

a

geometric

series.

Then

show

that exp(-a)/(1 - exp(-a)) 

Finish by bounding

n t=1

1/f

1/a holds for (t) using the

any fact

a > 0 and conclude that 1/f (t)  1/(t

that

F



2 2

.

log(t)2) and

bounding a sum by an integral.

8.2 (One-armed bandits) Consider the one-armed bandit problem: E = {N (µ1, 1) : µ1  R} × {N (0, 1)}. Suppose that  = (P1, P2)  E and P1 has mean µ1 = 1. Evaluate

lim sup
n

Rn(, ) log(n)

,

where  is the policy of Algorithm 6.

8.3 (One-armed bandits (ii)) Consider the setting of Exercise 8.2 and define

a policy by



At

=

1 2

if µ^1(t - 1) + otherwise .

2 log f (t) T1 (t-1)



0

(8.5)

8.4 Exercises

121

Suppose that  = (P1, P2) where P1 = N (µ1, 1) and P2 = N (0, 1). Prove that for the modified policy,

lim sup
n

Rn() log(n)



0
2 µ21

if µ1  0 if µ1 < 0 .

Hint Follow the analysis for UCB, but carefully adapt the proof by using the fact that the index of the second arm is always zero.

The strategy proposed in the above exercise is based on the idea that optimism is used to overcome uncertainty in the estimates of the quality of an arm, but for one-armed bandits the mean of the second arm is known in advance.

8.4 (One-armed bandits (iii)) The purpose of this question is to compare UCB and the modified version in (8.5).

(a) Implement a simulator for the one-armed bandit problem and two algorithms: UCB and the modified version analysed in Exercise 8.3.
(b) Use your simulator to estimate the expected regret of each algorithm for a horizon of n = 1000 and µ1  [-1, 1].
(c) Plot your results with µ1 on the x-axis and the estimated expected regret on the y-axis. Don't forget to label the axis and include error bars and a legend.
(d) Explain the results. Why do the curves look the way they do? (e) In your plot, for what values of µ1 does the worst-case expected regret
for each algorithm occur? What is the worst-case expected regret for each algorithm?

8.5 (Different subgaussian constants) Let 2  [0, )k be known and suppose that the reward is Xt  N (µAt , A2 t ). Design an algorithm (that depends on 2) for which the asymptotic regret is

lim sup
n

Rn log(n)

=

i:i >0

2i2 i

.

9 The Upper Confidence Bound Algorithm: Minimax Optimality ( )

We proved that the variants of UCB analysed in the last two chapters have a worst-case regret of Rn = O( kn log(n)). Further, in Exercise 6.8 you showed that an elimination algorithm achieves Rn = O( kn log(k)). By modifying the confidence levels of the algorithm it is possible to remove the log factor entirely. Building on UCB, the directly named `minimax optimal strategy in the stochastic case' (MOSS) algorithm was the first to make this modification and is presented below. MOSS again depends on prior knowledge of the horizon, a requirement that may be relaxed, as we explain in the notes.
The term minimax is used because, except for constant factors, the worstcase bound proven in this chapter cannot be improved on by any algorithm. The lower bounds are deferred to Part IV.

9.1 The MOSS Algorithm
Algorithm 7 shows the pseudocode of MOSS, which is again an instance of the UCB family. The main novelty is that the confidence level is chosen based on the number of plays of the individual arms, as well as n and k.

1: Input n and k 2: Choose each arm once 3: Subsequently choose

At = argmaxi µ^i(t - 1) +

4 Ti(t -

1)

log+

n kTi(t - 1)

,

where log+(x) = log max {1, x} .

Algorithm 7: MOSS.

9.1 The MOSS Algorithm

123

Theorem 9.1. For any 1-subgaussian bandit, the regret of Algorithm 7 satisfies



k

Rn  39 kn + i .

i=1

Before the proof we state and prove a strengthened version of Corollary 5.5.

Theorem 9.2. Let X1, X2, . . . , Xn be a sequence of independent -subgaussian

random variables and St =

t s=1

Xs.

Then,

for

any



>

0,

P (exists t  n : St  )  exp

-

2 2n2

.

(9.1)

The bound in Eq. (9.1) is the same as the bound on P (Sn  ) that appears in a simple reformulation of Corollary 5.5, so this new result is strictly stronger.

Proof From the definition of subgaussian random variables and Lemma 5.4,

E [exp (Sn)]  exp

n22 2

.

Then, choosing  = /(n2) leads to

P (exists t  n : St  ) = P

max
tn

exp

(St)



exp

()



E [exp (Sn)] exp ()



exp

n22 2

-



= exp

-

2 2n2

.

The novel step is the first inequality, which follows from Doob's submartingale inequality (Theorem 3.10) and the fact that that exp(St) is a submartingale with respect to the filtration generated by X1, X2, . . . , Xn (Exercise 9.1).

Before the proof of Theorem 9.1, we need one more lemma to bound the probability that the index of the optimal arm ever drops too far below the actual mean of the optimal arm. The proof of this lemma relies on a tool called the peeling device, which is an important technique in probability theory and has many applications beyond bandits. For example, it can be used to prove the celebrated law of the iterated logarithm.

Lemma 9.3. Let   (0, 1) and X1, X2, . . . be independent and 1-subgaussian and

µ^t

=

1 t

t s=1

Xs.

Then,

for

any



>

0,

P exists s  1 : µ^s +

4 s

log+

1 s

+0



15 2

.

9.1 The MOSS Algorithm

124

Proof Let St = tµ^t. Then

P exists s  1 : µ^s +

4 s

log+

1 s

+0

= P exists s  1 : Ss +

4s log+

1 s

+ s  0


 P exists s  [2j, 2j+1] : Ss +
j=0

4s log+

1 s

+ s  0


 P exists s  2j+1 : Ss +
j=0

4 · 2j log+

1 2j+1



2

  exp -

2j+2 log+

1 2j +1 

+ 2j

2j+2

 .

j=0

+ 2j  0

The first inequality follows from a union bound over a geometric grid. The second

step is straightforward but important because it sets up to apply Theorem 9.2.

The rest is purely algebraic:

  exp -
j=0

2j+2 log+

1 2j +1 

2j+2

2 + 2j      2j+1 exp -22j-2
j=0



8 e2

+


2s+1 exp
0

-22s-2

ds



15 2

.

Above, the first inequality follows since (a + b)2  a2 + b2 for a, b  0, and

the second last step follows by noting that the integrand is unimodal and

has a maximum value of 8/(e2). For such functions f , one has the bound

b j=a

f (j)



maxs[a,b]

f (s)

+

b a

f

(s)ds.

Proof of Theorem 9.1 As usual, we assume without loss of generality that the first arm is optimal, so µ1 = µ. Arguing that the optimal arm is sufficiently optimistic with high probability is no longer satisfactory because in this refined analysis, the probability that an arm is played linearly often needs to depend on its suboptimality gap. A way around this difficulty is to make an argument in terms of the expected amount of optimism. Define a random variable  that measures how far below the index of the optimal arm drops below its true mean.

+

=

µ1

-

min
sn

µ^1s +

4 s

log+

n ks

.

Arms with suboptimality gaps much larger than  will not be played too often, while arms with suboptimality gaps smaller than  may be played linearly often, but  is sufficiently small in expectation that this price is small. Using the basic

9.1 The MOSS Algorithm

125

regret decomposition (Lemma 4.5) and splitting the actions based on whether or not their suboptimality gap is smaller or larger than 2 leads to

Rn =

iE[Ti(n)]

i:i>0



 E 2n +

iTi(n)



i:i >2





E

2n

+

 8 kn

+



iTi(n) .

i:i>max 2,8 k/n

The first term is easily bounded using Proposition 2.8 and Lemma 9.3:





E[2n] = 2nE[] = 2n P (  x) dx  2n min

0

0

1,

15k nx2

 dx  16 kn .

For suboptimal arm i, define

n
i = I
s=1

µ^is +

4 s

log+

n ks

 µi + i/2

.

The reason for choosing i in this way is that for arms i with i > 2, it holds
that the index of the optimal arm is always larger than µi + i/2, so i is an upper bound on the number of times arm i is played, Ti(n). If i  8(k/n)1/2,
then the expectation of ii is bounded using Lemma 8.2 by

iE[i]



1 i

+

iE

n
I
s=1

µ^is +

4 s

log+

n2i k

 µi + i/2



1 i

+

i

+

8 i

2 log+

n2i k

+

2 log+

ni2 k

+1



1 8

n k

+

i

+

n k

4 log 8 + 2

 log 8 + 1  i + 15

n k

,

where the first inequality follows by replacing the s in the logarithm with 1/i2 and adding the i × 1/2i correction term to compensate for the first i-2

rounds where this fails to x  x-1-p log+(ax2) for

hold. Then we use Lemma p  [0, 1], positive a and x

8.2e/anda.tThehemloanstotionneiqcuitaylitoyf

9.2 Two Problems

126

 follows by naively bounding 1/8 + 4 log 8 + 2  log 8 + 1  15. Then







E 



iTi(n)  E 

 ii

i:i>max 2,8 k/n

i:i>8 k/n





i + 15

n k

i:i>8 k/n



k

 15 nk + i .

i=1

 Combining all the results we have Rn  39 kn +

k i=1

i

.

9.2 Two Problems

MOSS is not the ultimate algorithm. Here we highlight two drawbacks.

Suboptimality Relative to UCB Although MOSS is nearly asymptotically optimal (Note 1), all versions of MOSS can be arbitrarily worse than UCB in some regimes. This unpleasantness is hidden by both the minimax and asymptotic optimality criteria, which highlights the importance of fully finite-time upper and lower bounds. The counter-example witnessing the failure is quite simple. Let the rewards for all arms be Gaussian with unit variance and n = k3, µ1 = 0, µ2 = - k/n and µi = -1 for all i > 2. From Theorem 8.1, we have that
RnUCB = O(k log k) ,
while it turns out that MOSS has a regret of 
RnMOSS = ( kn) = (k2) .
A rigourous proof of this claim is quite delicate, but we encourage readers to try to understand why it holds intuitively.

Instability

There is a hidden cost of pushing too hard to reduce the expected regret, which

is that the distribution of the regret is less well-behaved. Consider a two-armed

Gaussian bandit with suboptimality gap . The random (pseudo) regret is

R^n =

n t=1

At ,

which

for

a

carefully

tuned

algorithm

has

a

roughly

bimodal

distribution:

R^n 

n

1 

log

1 

with probability  otherwise ,

9.3 Notes

127

where  is a parameter of the policy that determines the likelihood that the optimal arm is misidentified. Integrating, one has

Rn = E[R^n] = O

n

+

1 

log

1 

,

The choice of  that minimises the expected regret depends on  and is approximately 1/(n2). With this choice, the regret is

Rn = O

1 

1 + log

n2

.

Of course  is not known in advance, but it can be estimated online so that the
above bound is actually realisable by an adaptive policy that does not know  in advance (Exercise 9.3). Let F be the (informal) event that R^n = (n). The problem is that when  = 1/(n2) is chosen to minimise the expected regret,
then the second moment due to failure is

E[IF R^n2 ] = (n) . On the other hand, by choosing  = (n)-2, the regret increases only slightly to

Rn = O

1 

1 n

+

log

n22

.

The second moment of the regret due to failure, however, is E[IF R^n2 ] = O(1).

9.3 Notes

1 MOSS is quite close to asymptotically optimal. You can prove that

lim sup
n

Rn log(n)



i:i >0

4 i

.

By modifying the algorithm slightly, it is even possible to replace the four with a two and recover the optimal asymptotic regret. The trick is to increase g slightly and replace the four in the exploration bonus by two. The major task is then to re-prove Lemma 9.3, which is done by replacing the intervals [2j, 2j+1] with smaller intervals [j, j+1], where  is tuned subsequently to be fractionally larger than one. This procedure is explained in detail by Garivier [2013]. When the reward distributions are actually Gaussian, there is a more elegant technique that avoids peeling altogether (Exercise 9.4). 2 One way to mitigate the issues raised in Section 9.2 is to replace the index used by MOSS with a less aggressive confidence level:

µ^i(t - 1) +

4 Ti(t -

1)

log+

n Ti(t - 1)

.

(9.2)

The resulting algorithm is never worse than UCB, and you will show in

9.4 Bibliographic Remarks

128

Exercise 9.3 that it has a distribution free regret of O( nk log(k)). An algorithm that does almost the same thing in disguise is called `improved UCB', which operates in phases and eliminates arms for which the upper confidence bound drops below a lower confidence bound for some arm [Auer and Ortner, 2010]. This algorithm was the topic of Exercise 6.8. 3 Overcoming the failure of MOSS to be instance optimal without sacrificing minimax optimality is possible by using an adaptive confidence level that tunes the amount of optimism to match the instance. One of the authors has proposed two ways to do this, using one of the following indices:

µ^i(t - 1) +

2(1 + ) Ti(t - 1)

log

n t

, or

(9.3)

µ^i(t - 1) +

2 Ti(t -

1)

log

n

k j=1

min{Ti(t

-

1),

Ti(t - 1)Tj(t - 1)}

.

The first of these algorithms is called the `optimally confident UCB' [Lattimore, 2015b] while the second is AdaUCB [Lattimore, 2018]. Both algorithms are minimax optimal up to constant factors and never worse than UCB. The latter is also asymptotically optimal. If the horizon is unknown, then AdaUCB can be modified by replacing n with t. It remains a challenge to provide a straightforward analysis for these algorithms.

9.4 Bibliographic Remarks
MOSS is due to Audibert and Bubeck [2009], while an anytime modification is by Degenne and Perchet [2016]. The proof that a modified version of MOSS is asymptotically optimal may be found in the article by M´enard and Garivier [2017]. There is also a variant of MOSS that adapts to the variance for rewards bounded in [0, 1] [Mukherjee et al., 2018]. AdaUCB and its friends are by one of the authors [Lattimore, 2015b, 2016b, 2018]. The idea to modify the confidence level has been seen in several places, with the earliest by Lai [1987] and more recently by Honda and Takemura [2010]. Kaufmann [2018] also used a confidence level like in Eq. (9.2) to derive an algorithm based on Bayesian upper confidence bounds.

9.5 Exercises

9.1 (Submartingale property) Let X1, X2, . . . , Xn be adapted to filtration

F = (Ft)t with E[Xt | Ft-1] = 0 almost surely. Prove that Mt = exp(

t s=1

Xs)

is a F-submartingale for any   R.

9.2 (Problem-dependent bound) Let min = mini:i>0 i. Show there exists

9.5 Exercises

129

a universal constant C > 0 such that the regret of MOSS is bounded by

Rn



Ck min

log+

nm2 in k

k
+ i .
i=1

9.3 (UCB*) Suppose we modify the index used by MOSS to be

µ^i(t - 1) +

4 Ti(t -

1)

log+

n Ti(t - 1)

.

(a) Show that for all 1-subgaussian bandits, this new policy suffers regret at

most





Rn



C



i

i:i >0

+

1 i

log+(n2i )

,

where C > 0 is a universal constant. (b) Under the same conditions as the previous part, show there exists a universal
constant C > 0 such that
k
Rn  C kn log(k) + i .
i=1

(c) Repeat parts (a) and (b) using the index

µ^i(t - 1) +

4 Ti(t -

1)

log+

t Ti(t - 1)

.

9.4 (Gaussian noise and the tangent approximation) Let g(t) = at + b with b > 0 and

u(x, t) = 1 exp 2t

-

x2 2t

- 1 exp 2t

-2ab

-

(x

- 2b)2 2t

.

(a) Show that u(x, t) > 0 for x  (-, g(t)) and u(x, t) = 0 for x = g(t). (b) Show that u(x, t) satisfies the heat equation:

tu(x, t)

=

1 2

x2

u(x,

t)

.

(c) Let Bt be a standard Brownian motion, which for any fixed t has density with respect to the Lebesgue measure.

p(x, t) = 1 exp 2t

-

x2 2t

.

Define  = min{t : Bt = g(t)} as the first time the Brownian motion hits the boundary. Put on your physicists hat (or work hard) to argue that

g(t)

P (  t) =

u(x, t)dx .

-

9.5 Exercises

130

(d) Let v(t) be the density of time  with respect to the Lebesgue measure so

that P (g  t) =

t 0

v(t)dt.

Show

that

v(t) =  b exp 2t3

- g(t)2 2t

(e) In the last part, you established the exact density of the hitting time of a
Brownian motion approaching a linear boundary. We now generalise this
to nonlinear boundaries, but at the cost that now we only have a bound. Suppose that f : [0, )  [0, ) is concave and differentiable, and let  : R  R be the intersection of the tangent to f at t with the y-axis given by (t) = f (t) - tf (t). Let  = min{t : Bt = f (t)} and v(t) be the density of  . Show that for t > 0,

v(t)  (t) exp 2t3

-

f

(t)2 2t

.

(f) Suppose that X1, X2, . . . is a sequence of independent standard Gaussian random variables. Show that

P

t
exists t  n : Xs  f (t)
s=1



n (t) exp 0 2t3

-

f

(t)2 2t

dt .

(g) Let h : (0, )  (1, ) be a concave increasing function such that log(h(a))/h(a)  c/a for some constant c > 0 and f (t) = 2t log h(1/t)+
t. Show that

P

t
exists t : Xs  f (t)
s=1

 2c 2 .

(h) Show that h(a) = 1 + (1 + a) log(1 + a) satisfies the requirements of the previous part with c = 11/10.
(i) Use your results to modify MOSS for the case when the rewards are Gaussian. Compare the algorithms empirically.
(j) Prove for your modified algorithm that

lim sup
n

Rn log(n)



i:i >0

2 i

.

Hint The above exercise has several challenging components and assumes prior knowledge of Brownian motion and its interpretation in terms of the heat equation. We recommend the book by Lerche [1986] as a nice reference on hitting times for Brownian motion against concave barriers. The equation you derived in Part (d) is called the Bachelier­L´evy formula , and the technique for doing so is the method of images. The use of this theory in bandits was introduced by one of the authors [Lattimore, 2018], which readers might find useful when working through these questions.

9.5 (Asymptotic optimality and subgaussian noise) In the last exercise,

9.5 Exercises

131

you modified MOSS to show asymptotic optimality when the noise is Gaussian. This is also possible for subgaussian noise. Follow the advice in the notes of this chapter to adapt MOSS so that for all 1-subgaussian bandits, it holds that

lim sup
n

Rn log(n)



i:i >0

2 i

,



while maintaining the property that Rn  C kn for universal constant C > 0.

10 The Upper Confidence Bound Algorithm: Bernoulli Noise ( )

In previous chapters we assumed that the noise of the rewards was -subgaussian for some known  > 0. This has the advantage of simplicity and relative generality, but stronger assumptions are sometimes justified and often lead to stronger results. In this chapter the rewards are assumed to be Bernoulli, which just means that Xt  {0, 1}. This is a fundamental setting found in many applications. For example, in click-through prediction, the user either clicks on the link or not. A Bernoulli bandit is characterised by the mean pay-off vector µ  [0, 1]k and the reward observed in round t is Xt  B(µAt ).
The Bernoulli distribution is 1/2-subgaussian regardless of its mean (Exercise 5.12). Hence the results of the previous chapters are applicable, and an appropriately tuned UCB enjoys logarithmic regret. The additional knowledge that the rewards are Bernoulli is not being fully exploited by these algorithms, however. The reason is essentially that the variance of a Bernoulli random variable depends on its mean, and when the variance is small, the empirical mean concentrates faster, a fact that should be used to make the confidence intervals smaller.

10.1

Concentration for Sums of Bernoulli Random Variables
The first step when designing a new optimistic algorithm is to construct confidence sets for the unknown parameters. For Bernoulli bandits, this corresponds to analysing the concentration of the empirical mean for sums of Bernoulli random variables. For this, the following definition will prove useful:
Definition 10.1 (Relative entropy between Bernoulli distributions). The relative entropy between Bernoulli distributions with parameters p, q  [0, 1] is
d(p, q) = p log(p/q) + (1 - p) log((1 - p)/(1 - q)) ,
where singularities are defined by taking limits: d(0, q) = log(1/(1 - q)) and d(1, q) = log(1/q) for q  [0, 1] and d(p, 0) = 0 if p = 0 and  otherwise and d(p, 1) = 0 if p = 1 and  otherwise.

10.1 Concentration for Sums of Bernoulli Random Variables

133

More generally, the relative entropy or Kullback­Leibler divergence is a measure of similarity between distributions. See Chapter 14 for a generic definition, interpretation and discussion.

Lemma 10.2. Let p, q,   [0, 1]. The following hold:

(a) The functions d(·, q) and d(p, ·) are convex and have unique minimisers at q and p, respectively.
(b) d(p, q)  2(p - q)2 (Pinsker's inequality). (c) If p  q -   q, then d(p, q - )  d(p, q) - d(q - , q)  d(p, q) - 22.

Proof We assume that p, q  (0, 1). The corner cases are easily checked separately. Part (a): d(·, q) is the sum of the negative binary entropy function h(p) = p log p + (1 - p) log(1 - p) and a linear function. The second derivative of h is h (p) = 1/p + 1/(1 - p), which is positive, and hence h is convex. For fixed p the function d(p, ·) is the sum of h(p) and convex functions p log(1/q) and (1 - p) log(1/(1 - q)). Hence d(p, ·) is convex. The minimiser property follows because d(p, q) > 0 unless p = q in which case d(p, p) = d(q, q) = 0. A more general version of (b) is given in Chapter 15. A proof of the simple version here follows by considering the function g(x) = d(p, p + x) - 2x2, which obviously satisfies g(0) = 0. The proof is finished by showing that this is the unique minimiser of g over the interval [-p, 1 - p]. The details are left to Exercise 10.1. For (c), notice that

h(p)

=

d(p,

q

-

)

-

d(p,

q)

=

p

log

q

q -



+

(1

-

p)

log

1

1-q -q+



.

It is easy to see then that h is linear and increasing in its argument. Therefore, since p  q - ,

h(p)  h(q - ) = -d(q - , q) ,

as required for the first inequality of (c). The second inequality follows by using the result in (b).

The next lemma controls the concentration of the sample mean of a sequence of independent and identically distributed Bernoulli random variables.

Lemma 10.3 (Chernoff's bound). Let X1, X2, . . . , Xn be a sequence of independent

random variables that are Bernoulli distributed with mean µ, and let µ^ =

1 n

n t=1

Xt

be

the

sample

mean.

Then,

for





[0, 1 - µ],

it

holds

that

P (µ^  µ + )  exp (-nd(µ + , µ))

(10.1)

and for   [0, µ],

P (µ^  µ - )  exp (-nd(µ - , µ)) .

(10.2)

10.1 Concentration for Sums of Bernoulli Random Variables

134

Proof We will again use the Cram´er­Chernoff method. Let  > 0 be some constant to be chosen later. Then,

n

P (µ^  µ + ) = P exp  (Xt - µ)  exp (n)

t=1



E [exp (

n t=1

(Xt

exp (n)

-

µ))]

= (µ exp((1 - µ - )) + (1 - µ) exp(-(µ + )))n .

This

expression

is

minimised

by



=

log

(µ+)(1-µ) µ(1-µ-)

.

Therefore,

P (µ^  µ + )



µ

(µ + )(1 - µ) µ(1 - µ - )

1-µ-
+ (1 - µ)

(µ + )(1 - µ) -µ- n µ(1 - µ - )

=

µ µ+

(µ + )(1 - µ) 1-µ- n µ(1 - µ - )

= exp (-nd(µ + , µ)) .

The bound on the left tail is proven identically.

Using Pinsker's inequality, it follows that P (µ^  µ + ) , P (µ^  µ - )  exp(-2n2), which is the same as what can be obtained from Hoeffding's lemma (see (5.8)). Solving exp(-2n2) = , we recover the usual 1 -  confidence upper bound. In fact, this cannot be improved when µ  1/2, but the Chernoff bound is much stronger when µ is close to either zero or one. Can we invert the Chernoff tail bound to get confidence intervals that get tighter automatically as µ (or µ^) approaches zero or one? The following corollary shows how to do this.

Corollary 10.4. Let µ, µ^, n be as above. Then, for any a  0,
P (d(µ^, µ)  a, µ^  µ)  exp(-na) , and P (d(µ^, µ)  a, µ^  µ)  exp(-na) .

(10.3) (10.4)

Furthermore, defining

U (a) = max{u  [0, 1] : d(µ^, u)  a} , and L(a) = min{u  [0, 1] : d(µ^, u)  a} .

Then, P (µ  U (a))  exp(-na) and P (µ  L(a))  exp(-na).

Proof First, we prove (10.3). Note that d(·, µ) is decreasing on [0, µ], and thus, for 0  a  d(0, µ), {d(µ^, µ)  a, µ^  µ} = {µ^  µ - x, µ^  µ} = {µ^  µ - x}, where x is the unique solution to d(µ - x, µ) = a on [0, µ]. Hence, by Eq. (10.2) of Lemma 10.3, P (d(µ^, µ)  a, µ^  µ)  exp(-na). When a  d(0, µ), the inequality trivially holds. The proof of (10.4) is entirely analogous and hence
is omitted. For the second part of the corollary, fix a and let U = U (a).

10.1 Concentration for Sums of Bernoulli Random Variables

135

First, notice that U  µ^ and d(µ^, ·) is strictly increasing on [µ^, 1]. Hence, {µ  U } = {µ  U, µ  µ^} = {d(µ^, µ)  d(µ^, U ), µ  µ^} = {d(µ^, µ)  a, µ  µ^},
where the last equality follows by d(µ^, U ) = a, which holds by the definition
of U . Taking probabilities and using the first part of the corollary shows that P (µ  U )  exp(-na). The statement concerning L = L(a) follows with a similar reasoning.

Note that for   (0, 1), U = U (log(1/)/n) and L = L(log(1/)/n) are upper and lower confidence bounds for µ. Although the relative entropy has no closedform inverse, the optimisation problem that defines U and L can be solved to a high degree of accuracy using Newton's method (the relative entropy d is convex in its second argument). The advantage of this confidence interval relative to the one derived from Hoeffding's bound is now clear. As µ^ approaches one, the width of the interval U (a) - µ^ approaches zero, whereas the width of the interval provided by Hoeffding's bound stays at log(1/)/(2n). The same holds for µ^ - L(a) as µ^  0.

Example 10.5. Fig. 10.1 shows a plot of d(3/4, x) and the lower bound given by Pinsker's inequality. The approximation degrades as |x - 3/4| grows large, especially for x > 3/4. As explained in Corollary 10.4, the graph of d(µ^, ·) can be used to derive confidence bounds by solving for d(µ^, x) = a = log(1/)/n. Assuming µ^ = 3/4 is observed, a confidence level of 90 per cent with n = 10, a  0.23. The confidence interval can be read out from the figure by finding those values where the horizontal dashed black line intersects the solid blue line. The resulting confidence interval will be highly asymmetric. Note that in this scenario, the lower confidence bounds produced by both Hoeffding's inequality and Chernoff's bound are similar, while the upper bound provided by Hoeffding's bound is vacuous.

0.6

0.4

0.2

0

0

0.25

0.5

0.75

1

x

Figure 10.1 Relative entropy and Pinsker's inequality

d(3/4, x) 2(x - 3/4)2 a = 0.23

10.2 The KL-UCB Algorithm

136

10.2

The KL-UCB Algorithm

The difference between KL-UCB and UCB is that Chernoff's bound is used to define the upper confidence bound instead of Lemma 5.5.

1: Input k 2: Choose each arm once 3: Subsequently choose

At = argmaxi max

µ~



[0, 1]

:

d(µ^i(t

-

1), µ~)



log f (t) Ti(t - 1)

,

where f (t) = 1 + t log2(t) .

Algorithm 8: KL-UCB.

Theorem 10.6. If the reward in round t is Xt  B(µAt ), then the regret of Algorithm 8 is bounded by

Rn



i:i

>0

1

inf
1 ,2 >0 +2 (0,i

)

i

d(µi

log(f (n)) + 1, µ -

2)

+

1 212

+

2 22

.

Furthermore,

lim sup
n

Rn log(n)



i:i >0

i d(µi, µ

)

.

Comparing the regret in Theorem 10.6 to what would be obtained when using UCB from Chapter 8, which for subgaussian constant  = 1/2 satisfies

lim sup
n

Rn log(n)



i:i >0

1 2i

.

By Pinsker's inequality (part (b) of Lemma 10.2) we see that d(µi, µ)  2(µ - µi)2 = 2i2, which means that the asymptotic regret of KL-UCB is never worse than that of UCB. On the other hand, a Taylor's expansion shows that when µi and µ are close (the hard case in the asymptotic regime),

d(µi, µ)

=

2i 2µi(1 -

µi)

+

o(i2) ,

indicating that the regret of KL-UCB is approximately

lim sup
n

Rn log(n)



i:i >0

2µi(1 - i

µi)

.

(10.5)

Notice that µi(1 - µi) is the variance of a Bernoulli distribution with mean µi. The approximation indicates that KL-UCB will improve on UCB in regimes where µi is close to zero or one.
The proof of Theorem 10.6 relies on two lemmas. The first is used to show that the index of the optimal arm is never too far below its true value, while the

10.2 The KL-UCB Algorithm

137

second shows that the index of any other arm is not often much larger than the same value. These results mirror those given for UCB, but things are complicated by the non-symmetric and hard-to-invert divergence function.
For the next results, we define d(p, q) = d(p, q)I {p  q}.

Lemma 10.7. Let X1, X2, . . . , Xn be independent Bernoulli random variables with mean µ  [0, 1],  > 0 and

 = min

t

:

max
1sn

d(µ^s

,

µ

-

)

-

log f (t) s



0

.

Then,

E[ ]



2 2

.

Proof We start with a high-probability bound and then integrate to control the expectation.

P ( > t)  P

1



s



n

:

d(µ^s, µ - )

>

log f (t) s

n
P
s=1 n
=P
s=1 n
P
s=1

d(µ^s, µ -

)

>

log f (t) s

d(µ^s, µ -

)

>

log

f s

(t)

,

µ^s

<

µ-



d(µ^s, µ)

>

log f (t) s

+

22, µ^s

<

µ

((c) of Lemma 10.2)



n
exp

-s

22

+

log f (t) s

s=1

(Eq. (10.3) of Corollary 10.4)



1 f (t)

n
exp
s=1

-2s2



1 2f (t)2

.

To finish, we integrate the tail,

E[ ] =

 0

P (



t) dt



1 22

 0

dt f (t)



2 2

.

Lemma 10.8. Let X1, X2, . . . , Xn be independent Bernoulli random variables with mean µ. Further, let  > 0, a > 0 and define

n
= I
s=1

d(µ^s, µ

+

)



a s

.

Then, E[]  inf
(0,)

d(µ

+

a , µ

+

)

+

1 22

.

10.2 The KL-UCB Algorithm

138

Proof Let   (0, ) and u = a/d(µ + , µ + ). Then,

E[] =

n

P

d(µ^s, µ

+

)



a s

s=1



n

P

µ^s



µ

+



or

d(µ

+

, µ

+

)



a s

s=1

(d(·, µ + ) is decreasing on [0, µ + ])

n

u+

P (µ^s  µ + )

s= u



 u + exp (-sd(µ + , µ))

(Lemma 10.3)

s=1



d(µ

+

a , µ

+

)

+

d(µ

1 + , µ)



d(µ

+

a , µ

+

)

+

1 22

(Pinsker's inequality/Lemma 10.2(b))

as required.

Proof of Theorem 10.6 As in other proofs, we assume without loss of generality that µ1 = µ and bound E[Ti(n)] for suboptimal arms i. To this end, fix a suboptimal arm i and let 1 + 2  (0, i) with both 1 and 2 positive. Define

 = min

t

:

max
1sn

d(µ^1s

,

µ1

-

2) -

log f (t) s



0

=

n
I

d(µ^is, µi

+

i

-

2)



log f (n) s

.

s=1

, and

Using a similar argument as in the proof of Theorem 8.1,

n

E[Ti(n)] = E

I {At = i}

t=1

n

 E[ ] + E

I {At = i}

t= +1

 E[ ] + E

n
I
t=1

At

=

i

and

d(µ^i,Ti(t-1), µ1

-

2)



log f (t) Ti(t - 1)

 E[ ] + E[]



2 22

+

d(µi

f (n) + 1, µ

-

2)

+

1 212

,

where the second inequality follows, since by the definition of  , if t >  , then the index of the optimal arm is at least as large as µ1 - 2. The third inequality follows from the definition of  as in the proof of Theorem 8.1. The final inequality

10.3 Notes

139

follows from Lemmas 10.7 and 10.8. The first claim of the theorem is completed by substituting the above into the standard regret decomposition
k
Rn = iE[Ti(n)] .
i=1
The asymptotic claim for you in Exercise 10.2.

10.3

Notes

1 The new concentration inequality (Lemma 10.3) holds more generally for any sequence of independent and identically distributed random variables X1, X2, . . . , Xn for which Xt  [0, 1] almost surely. Therefore all results in this section also hold if the assumption that the noise is Bernoulli is relaxed to the case where it is simply supported in [0, 1] (or other bounded sets by shifting/scaling).
2 Expanding on the previous note, all that is required is a bound on the momentgenerating function for random variables X where, X  [0, 1] almost surely. Garivier and Capp´e [2011, Lemma 9] noted that f (x) = exp(x) - x(exp() - 1) - 1 is negative on [0, 1], and so

E [exp(X)]  E [X(exp() - 1) + 1] = µ exp() + 1 - µ ,

which is precisely the moment-generating function of the Bernoulli distribution with mean µ. Then the remainder of the proof of Lemma 10.3 goes through unchanged. This shows that for any bandit  = (Pi)i with Supp(Pi)  [0, 1] for all i the regret of the policy in Algorithm 8 satisfies

lim sup
n

Rn log(n)



i:i >0

i d(µi, µ)

.

3 The bounds obtained using the argument in the previous note are not quite tight. Specifically one can show there exists an algorithm such that for all bandits  = (Pi)i with Pi, the reward distribution of the ith arm supported on [0, 1], then

lim sup
n

Rn log(n)

=

i:i >0

i di

,

where

di = inf{D(Pi, P ) : µ(P ) > µ and Supp(P )  [0, 1]}

and D(P, Q) is the relative entropy between measures Pi and P , which we define in Chapter 14. The quantity di is never smaller than d(µi, µ). For details on this, see the paper by Honda and Takemura [2010].
4 The approximation in Eq. (10.5) was used to show that the regret for KL-UCB is closely related to the variance of the Bernoulli distribution. It is natural to ask whether or not this result could be derived, at least asymptotically, by

10.4 Bibliographic Remarks

140

appealing to the central limit theorem. The answer is no. First, the quality of the approximation in Eq. (10.5) does not depend on n, so asymptotically it is not true that the Bernoulli bandit behaves like a Gaussian bandit with variances tuned to match. The reason is that as n tends to infinity, the confidence level should be chosen so that the risk of failure also tends to zero. But the central limit theorem does not provide information about the tails with probability mass less than O(n-1/2). See Note 1 in Chapter 5. 5 The analysis in this chapter is easily generalised to a wide range of alternative noise models. You will do this for single-parameter exponential families in Exercises 10.4, 10.5 and 34.5. 6 Chernoff credits Lemma 10.3 to his friend Herman Rubin [Chernoff, 2014], but the name seems to have stuck.

10.4

Bibliographic Remarks
Several authors have worked on Bernoulli bandits, and the asymptotics have been well understood since the article by Lai and Robbins [1985]. The earliest version of the algorithm presented in this chapter is due to Lai [1987], who provided asymptotic analysis. The finite-time analysis of KL-UCB was given by two groups simultaneously (and published in the same conference) by Garivier and Capp´e [2011] and Maillard et al. [2011] (see also the combined journal article: Capp´e et al. 2013). Two alternatives are the DMED [Honda and Takemura, 2010] and IMED [Honda and Takemura, 2015] algorithms. These works go after the problem of understanding the asymptotic regret for the more general situation where the rewards lie in a bounded interval (see Note 3). The latter work covers even the semi-bounded case where the rewards are almost surely upperbounded. Both algorithms are asymptotically optimal. M´enard and Garivier [2017] combined MOSS and KL-UCB to derive an algorithm that is minimax optimal and asymptotically optimal for single-parameter exponential families. While the subgaussian and Bernoulli examples are very fundamental, there has also been work on more generic set-ups where the unknown reward distribution for each arm is known to lie in some class F. The article by Burnetas and Katehakis [1996] gives the most generic (albeit, asymptotic) results. These generic set-ups remain wide open for further work.

10.5

Exercises
10.1 (Pinsker's inequality) Prove Lemma 10.2(b). Hint Consider the function g(x) = d(p, p + x) - 2x2 over the [-p, 1 - p] interval. By taking derivatives, show that g  0. 10.2 (Asymptotic optimality) Prove the asymptotic claim in Theorem 10.6.

10.5 Exercises

141

Hint Choose 1, 2 to decrease slowly with n and use the first part of the theorem.

10.3 (Concentration for bounded random variables) Let F = (Ft)t be a

filtration, (Xt)t be [0, 1]-valued, F-adapted sequence, such that E [Xt | Ft-1] = µt

for µ^ =

some µ1, . . . , µn  [0,

1 n

n t=1

Xt.

Prove

that

1] non-random numbers. Define the conclusion of Lemma 10.3 still

µ= holds.

1 n

n t=1

µt

,

Hint Read Note 2 at the end of this chapter. Let g(·, µ) be the cumulant-
generating function of the µ-parameter Bernoulli distribution. For X  B(µ),   R, g(, µ) = log E [exp(X)]. Show that g(, ·) is concave. Next, use this and the tower rule to show that E [exp(n(µ^ - µ))]  g(, µ)n.

The bound of the previous exercise is most useful when all µt are either all close to zero or they are all close to one. When half of the {µt} are close to zero and the other half close to one, then the bound degrades to Hoeffding's bound.

10.4 (KL-UCB for exponential families) Let M = {P :   } be a
regular non-singular exponential family with sufficient statistic S(x) = x and E = {(Pi )ki=1 :   k} be the set of bandits with reward distributions in M. Design a policy  such that for all   E, it holds that

lim
n

Rn(, ) log(n)



i:i >0

i di,inf

,

where µ() µ,   },

= R xdP(x) is the mean of P and di,inf with d(, ) the relative entropy between P

= inf{d(, ) and P.

:

µ()

>

Hint Readers not familiar with exponential families should skip ahead to Section 34.3.1 and then do Exercise 34.5. For the exercise, repeat the proof of Theorem 10.6, adapting as necessary. See also the paper by Capp´e et al. [2013].
10.5 (KL-UCB for non-canonical exponential families) Repeat the previous exercise, but relax the assumption that S(x) = x.

Hint This is a subtle problem. You should adapt the algorithm so that if there
are ties in the upper confidence bounds, then an arm with the largest number of
plays is chosen. A solution is available. Korda et al. [2013] analysed Thompson sampling in this setting. Their result only holds when   R xp(x)dh(x) is invertible, which does not always hold.

10.5 Exercises

142

In the analysis of KL-UCB for canonical exponential families, the asymptotic rate is a good indicator of the finite-time regret in the sense that the o(log(n)) term hidden by the asymptotics has roughly the same leading constant as the dominant term. By contrast, the analysis here indicates that

E[Ti(n)]



log(n) di,inf

+

1 di,min

,

where di,min = di,min(0). Although the latter term is negligible asymptotically, it may be the dominant term for all reasonable n.

10.6 (Comparison to UCB) In this exercise, you compare KL-UCB and UCB empirically.
(a) Implement Algorithm 8 and Algorithm 6, where the latter algorithm should be tuned for 1/2-subgaussian bandits so that

At = argmaxi[k] µ^i(t - 1) +

log(f (t)) 2Ti(t - 1)

.

(b) Let n = 10000 and k = 2. Plot the expected regret of each algorithm as a function of  when µ1 = 1/2 and µ2 = 1/2 + .
(c) Repeat the above experiment with µ1 = 1/10 and µ1 = 9/10. (d) Discuss your results.

Part III
Adversarial Bandits with Finitely Many Arms

144
Statistician George E. P. Box is famous for writing that `all models are wrong, but some are useful'. In the stochastic bandit model the reward is sampled from a distribution that depends only on the chosen action. It does not take much thought to realise this model is almost always wrong. At the macroscopic level typically considered in bandit problems, there is not much that is stochastic about the world. And even if there were, it is hard to rule out the existence of other factors influencing the rewards.
The quotation suggests we should not care whether or not the stochastic bandit model is right, only whether it is useful. In science, models are used for predicting the outcomes of future experiments, and their usefulness is measured by the quality of the predictions. But how can this be applied to bandit problems? What predictions can be made based on bandit models? In this respect, we postulate the following:
The point of bandit models is to facilitate predicting the performance of bandit algorithms on future problem instances that one encounters in their practice.
A model can fail in two fundamentally different ways. It can be too specific, imposing assumptions so detached from reality that a catastrophic mismatch between actual and predicted performance may arise. The second mode of failure occurs when a model is too general, which makes the algorithms designed to do well on the bandit model overly cautious, which can harm performance.
Not all assumptions are equally important. It is a critical assumption in stochastic bandits that the mean reward of individual arms does not change (significantly) over time. On the other hand, the assumption that a single, armdependent distribution generates the rewards for a given arm plays a relatively insignificant role. The reader is encouraged to think of cases when the constancy of arm distributions plays no role, and also of cases when it does ­ furthermore, to decide to what extent the algorithms can tolerate deviations from the assumption that the means of arms stay the same. Stochastic bandits where the means of the arms are changing over time are called non-stationary and are the topic of Chapter 31.
If a highly specialised model is actually correct, then the resulting algorithms usually dominate algorithms derived for a more general model. This is a general manifestation of the bias-variance trade-off, well known in supervised learning and statistics. The holy grail is to find algorithms that work `optimally' across a range of models. The reader should think about examples from the previous chapters that illustrate these points.
The usefulness of the stochastic model depends on the setting. In particular, the designer of the bandit algorithm must carefully evaluate whether stochasticity, stability of the mean and independence are reasonable assumptions. For some applications, the answer will probably be yes, while in others the practitioner

145
may seek something more robust. This latter situation is the topic of the next few chapters.
Adversarial Bandits
The adversarial bandit model abandons almost all the assumptions on how the rewards are generated, so much so that the environment is often called the adversary. The adversary has a great deal of power in this model, including the ability to examine the code of the proposed algorithms and choose the rewards accordingly. All that is kept from the previous chapters is that the objective will be framed in terms of how well a policy is able to compete with the best action in hindsight.
At first sight, it seems remarkable that one can say anything at all about such a general model. And yet it turns out that this model is not much harder than the stochastic bandit problem. Why this holds and how to design algorithms that achieve these guarantees will be explained in the following chapters.
To give you a glimmer of hope, imagine playing the following simple bandit game with a friend. The horizon is n = 1, and you have two actions. The game proceeds as follows:
1 You tell your friend your strategy for choosing an action. 2 Your friend secretly chooses rewards x1  {0, 1} and x2  {0, 1}. 3 You implement your strategy to select A  {1, 2} and receive reward xA. 4 The regret is R = max{x1, x2} - xA.
Clearly, if your friend chooses x1 = x2, then your regret is zero no matter what. Now let's suppose you implement the deterministic strategy A = 1. Then your friend can choose x1 = 0 and x2 = 1, and your regret is R = 1. The trick to improve on this is to randomise. If you tell your friend, `I will choose A = 1 with probability one half', then the best she can do is choose x1 = 1 and x2 = 0 (or reversed), and your expected regret is R = 1/2. You are forgiven if you did not settle on this solution yourself because we did not tell you that a strategy may be randomised. With such a short horizon, you cannot do better than this, but for longer games the relative advantage of the adversary decreases, as we shall see soon.
In the next two chapters, we investigate the k-armed adversarial model in detail, providing both algorithms and regret analysis. Like the stochastic model, the adversarial model has many generalisations, which we'll visit in future chapters.
Bibliographic Remarks
The quote by George Box was used several times with different phrasings [Box, 1976, 1979]. The adversarial framework has its roots in game theory, with familiar

146
names like Hannan [1957] and Blackwell [1954] producing some of the early work. The non-statistical approach has enjoyed enormous popularity since the 1990's and has been adopted wholeheartedly by the theoretical computer science community [Vovk, 1990, Littlestone and Warmuth, 1994, and many, many others]. The earliest work on adversarial bandits is by Auer et al. [1995]. There is now a big literature on adversarial bandits, which we will cover in more depth in the chapters that follow. There has been a lot of effort to move away from stochastic assumptions. An important aspect of this is to define a sense of regularity for individual sequences. We refer the reader to some of the classic papers by MartinLo¨f [1966] and Levin [1973] and the more recent paper by Ivanenko and Labkovsky [2013].

11 The Exp3 Algorithm

In this chapter we first introduce the formal model of adversarial bandit environments and discuss the relationship to the stochastic bandit model. This is followed by the discussion of importance-weighted estimation, the Exp3 algorithm that uses this technique and the analysis of the regret of Exp3.

11.1

Adversarial Bandit Environments

Let k > 1 be the number of arms. A k-armed
adversarial bandit is an arbitrary sequence of reward vectors (xt)tn=1, where xt  [0, 1]k. In each round, the learner chooses a distribution over the actions Pt  Pk-1. Then the action At  [k] is sampled from Pt, and the learner receives reward xtAt . The interaction protocol is summarised in Fig. 11.2.
A policy in this setting is a function  : ([k] × [0, 1])  Pk-1 mapping history sequences to distributions over actions (regardless of measurability). Figure 11.1 Would you play The performance of a policy  in environment x is with this multi-armed bandit?
measured by the expected regret, which is the expected loss in revenue of the
policy relative to the best fixed action in hindsight.

n

n

Rn(, x) = max xti - E
i[k] t=1

xtAt
t=1

,

(11.1)

Adversary secretly chooses rewards (xt)nt=1 with xt  [0, 1]k For rounds t = 1, 2, . . . , n:
Learner selects distribution Pt  Pk-1 and samples At from Pt. Learner observes reward Xt = xtAt .
Figure 11.2 Interaction protocol for k-armed adversarial bandits.

11.1 Adversarial Bandit Environments

148

where the expectation is over the randomness of the learner's actions. The arguments  and x are omitted from the regret when they are clear from context.
The only source of randomness in the regret comes from the randomness in the actions of the learner. Of course the interaction with the environment means the action chosen in round t may depend on actions s < t as well as the observed rewards until round t. As we noted, unlike the case of stochastic bandits, here, there is no measurability restriction on the learner's policy . This is actually by choice, see Note 12 for details.
The worst-case regret over all environments is
Rn () = sup Rn(, x) .
x[0,1]n×k
The main question is whether or not there exist policies  for which Rn () is sublinear in n. In Exercise 11.2 you will show that for deterministic policies Rn ()  n(1 - 1/k), which follows by constructing a bandit so that xtAt = 0 for all t and xti = 1 for i = At. Because of this, sublinear worst-case regret is only possible by using a randomised policy.
Readers familiar with game theory will not be surprised by the need for randomisation. The interaction between learner and adversarial bandit can be framed as a two-player zero-sum game between the learner and environment. The moves for the environment are the possible reward sequences, and for the player they are the policies. The pay-off for the environment/learner is the regret and its negation respectively. Since the player goes first, the only way to avoid being exploited is to choose a randomised policy.
While stochastic and adversarial bandits seem quite different, it turns out that the optimal worst-case regret is the same up to constant factors and that lower bounds for adversarial bandits are invariably derived in the same manner as for stochastic bandits (see Part IV). In this chapter, we present a simple algorithm for which the worst-case regret is suboptimal by just a logarithmic factor. First, however, we explore the differences and similarities between stochastic and adversarial environments.
We already noted that deterministic strategies will have linear regret for some adversarial bandit. Since strategies in Part II like UCB and `Explore-thenCommit' were deterministic, they are not well suited for the adversarial setting. This immediately implies that policies that are good for stochastic bandit can be very suboptimal in the adversarial setting. What about the other direction? Will an adversarial bandit strategy have small expected regret in the stochastic setting? Let  be an adversarial bandit policy and  = (1, . . . , k) be a stochastic bandit with Supp(i)  [0, 1] for all i. Next, let Xti be sampled from i for each

11.2 Importance-Weighted Estimators

149

i  [k] and t  [n], and assume these random variables are mutually independent. By Jensen's inequality and convexity of the maximum function, we have

n

Rn(, ) = max E
i[k]

(Xti - XtAt )
t=1

n

E

max
i[k]

(Xti
t=1

-

XtAt )

= E [Rn(, X)]  Rn () ,

(11.2)

where the regret in the first line is the stochastic regret (using the random table

model), and in the last it is the adversarial regret. Therefore the worst-case

stochastic regret is upper-bounded by the worst-case adversarial regret. Going

the other way, the above inequality also implies that the worst-case regret for

adversarial problems is lower-bounded by the worst-case regret on stochastic

problems with rewards bounded in [0, 1]. In Chapter 15, we prove that the worstcase regret for stochastic Bernoulli bandits is at least c nk, where c > 0 is a

universal constant (Exercise 15.4). And so for the same universal constant, the

minimax regret for adversarial bandits satisfies



Rn

=

inf


sup
x[0,1]n×k

Rn(, x)



c

nk .

There is a little subtlety here. In order to define the expectations in the stochastic regret, the policy should be appropriately measurable. This can be resolved by noting that lower bounds can be proven using Bernoulli bandits. For details, see again Note 12.

11.2

Importance-Weighted Estimators

A key ingredient of all adversarial bandit algorithms is a mechanism for estimating the reward of unplayed arms. Recall that Pt is the conditional distribution of the action played in round t, and so for i  [k], Pti is the conditional probability

Pti = P (At = i | A1, X1, . . . , At-1, Xt-1) .

In what follows, we assume that for all t and i, Pti > 0 almost surely. As we shall see later, this will be true for all policies considered in this chapter. The importance-weighted estimator of xti is

X^ti

=

I {At = i} Xt Pti

.

(11.3)

Let Et[·] = E[· | A1, X1, . . . , At, Xt] denote the conditional expectation given the history up to time t. The conditional mean of X^ti satisfies

Et-1[X^ti] = xti ,

(11.4)

11.2 Importance-Weighted Estimators

150

which means that X^ti is an unbiased estimate of xti conditioned on the history observed after t - 1 rounds. To see why Eq. (11.4) holds, let Ati = I {At = i} so
that XtAti = xtiAti and

X^ti

=

Ati Pti

xti .

Now, Et-1[Ati] = Pti, and since Pti is (A1, X1, . . . , At-1, Xt-1)-measurable,

Et-1[X^ti] = Et-1

Ati Pti

xti

=

xti Pti

Et-1[Ati]

=

xti Pti

Pti

=

xti .

Being unbiased is a good start, but the variance of an estimator is also important. For arbitrary random variable U , the conditional variance Vt-1[U ] is the random variable

Vt-1[U ] = Et-1 (U - Et-1[U ])2 .

So Vt-1[X^ti] is a random variable that measures the variance of X^ti conditioned on the past. Calculating the conditional variance using the definition of X^ti and Eq. (11.4) shows that

Vt-1[X^ti] = Et-1[X^t2i] - xt2i = Et-1

Atix2ti Pt2i

- xt2i

=

xt2i(1 - Pti) Pti

.

(11.5)

This can be extremely large when Pti is small and xti is bounded away from zero. In the notes and exercises, we shall see to what extent this can cause trouble. The estimator in (11.3) is the first that comes to mind, but there are alternatives. For example,

X^ti

=

1

-

I

{At = Pti

i} (1

-

Xt) .

(11.6)

This estimator is still unbiased. Rewriting the formula in terms of yti = 1 - xti and Yt = 1 - Xt and Y^ti = 1 - X^ti leads to

Y^ti

=

I {At = Pti

i}

Yt

.

This is the same as (11.3) except that Yt has replaced Xt. The terms yti, Yt and Y^ti should be interpreted as losses. Had we started with losses to begin with, then this would have been the estimator that first came to mind. For obvious reasons, the estimator in Eq. (11.6) is called the loss-based importance-weighted estimator. The conditional variance of this estimator is essentially the same as Eq. (11.5):

Vt[X^ti]

=

Vt[Y^ti]

=

yt2i 1

- Pti Pti

.

The only difference is that the variance now depends on yt2i rather than xt2i. Which is better depends on the rewards for arm i, with smaller rewards suggesting the

superiority of the first estimator and larger rewards (or small losses) suggesting

the superiority of the second estimator. Can we change the estimator (either one

11.3 The Exp3 Algorithm

151

of them) so that it is more accurate for actions whose reward is close to some specific value v? Of course! Just change the estimator so that v is subtracted from the observed reward (or loss), then use the importance-sampling formula, and subsequently add back v. The problem is that the optimal value of v depends on the unknown quantity being estimated. Also note that the dependence of the variance on Pti is the same for both estimators, and since the rewards are bounded, it is this term that usually contributes most significantly. In Exercise 11.5, we ask you to show that all unbiased estimators in this setting are importance-weighted estimators.
Although the two estimators seem quite similar, it should be noted that the first estimator takes values in [0, ) while the second takes values in (-, 1]. Soon we will see that this difference has a big impact on the usefulness of these estimators when used in the Exp3 algorithm.

11.3

The Exp3 Algorithm

The simplest algorithm for adversarial bandits is called Exp3, which stands

for `exponential-weight algorithm for exploration and exploitation'. The reason

for this name will become clear after the explanation of the algorithm. Let

S^ti =

t s=1

X^si

be

the

total

estimated

reward

by

the

end

of

round

t,

where

X^si

is

given in Eq. (11.6). It seems natural to play actions with larger estimated reward

with higher probability. While there are many ways to map S^ti into probabilities,

a simple and popular choice is called exponential weighting, which for tuning

parameter  > 0 sets

Pti =

exp(S^t-1,i)

k j=1

exp(S^t-1,j

)

.

(11.7)

The parameter  is called the learning rate. When the learning rate is large, Pt concentrates about the arm with the largest estimated reward and the resulting algorithm exploits aggressively. For small learning rates, Pt is more uniform, and the algorithm explores more frequently. Note that as Pt concentrates, the variance of the importance-weighted estimators for poorly performing arms increases dramatically. There are many ways to tune the learning rate, including allowing it to vary with time. In this chapter we restrict our attention to the simplest case by choosing  to depend only on the number of actions k and the horizon n. Since the algorithm depends on , this means that the horizon must be known in advance, a requirement that can be relaxed (see Note 10).

11.4 Regret Analysis

152

1: Input: n, k,  2: Set S^0i = 0 for all i
3: for t = 1, . . . , n do
4: Calculate the sampling distribution Pt:

Pti =

exp S^t-1,i

k j=1

exp

S^t-1,j

5: Sample At  Pt and observe reward Xt 6: Calculate S^ti:

S^ti

=

S^t-1,i

+

1

-

I

{At

=

i} (1 Pti

-

Xt)

7: end for

Algorithm 9: Exp3.

11.4

Regret Analysis

We are now ready to bound the expected regret of Exp3.

Theorem 11.1. Let x  [0, 1]n×k and  be the policy of Exp3 (Algorithm 9) with learning rate  = log(k)/(nk). Then,

Rn(, x)  2 nk log(k) .

As we will prove many variants of this result with various tools, here we give a short algebraic proof, saving the development of intuition for later.

Proof For any arm i, define

n

n

Rni = xti - E

Xt ,

t=1

t=1

which is the expected regret relative to using action i in all the rounds. The
result will follow by bounding Rni for all i, including the optimal arm. For the
remainder of the proof, let i be some fixed arm. By the unbiasedness property of the importance-weighted estimator X^ti,

n
E[S^ni] = xti
t=1

and also

k

k

Et-1[Xt] =

Ptixti =

PtiEt-1[X^ti] .

i=1

i=1

(11.8)

The tower rule says that for any random variable X, E[Et-1[X]] = E[X], which together with the linearity of expectation and Eq. (11.8) means that

nk

Rni = E S^ni - E

PtiX^ti = E S^ni - S^n ,

t=1 i=1

(11.9)

11.4 Regret Analysis

153

where the last equality serves as the definition of S^n = t i PtiX^ti. To bound the right-hand side of Eq. (11.9), let

k
Wt = exp S^tj .
j=1
By convention an empty sum is zero, which means that S^0j = 0 and W0 = k. Then,

exp(S^ni)



k
exp(S^nj )
j=1

=

Wn

=

W0

W1 W0

...

Wn Wn-1

n
=k
t=1

Wt Wt-1

.

(11.10)

The ratio in the product can be rewritten in terms of Pt by

Wt Wt-1

=

k j=1

exp(S^t-1,j Wt-1

)

exp(X^tj

)

=

k
Ptj exp(X^tj) .
j=1

(11.11)

We need the following facts:

exp(x)  1 + x + x2 for all x  1 and 1 + x  exp(x) for all x  R .

Using these two inequalities leads to

Wt Wt-1

k
 1 +  Ptj X^tj
j=1

k
+ 2 Ptj X^t2j
j=1



k

k

 exp  Ptj X^tj + 2 Ptj X^t2j  .

j=1

j=1

(11.12)

Notice that this was only possible because X^tj is defined by Eq. (11.6), which ensures that X^tj  1 and would not have been true had we used Eq. (11.3). Combining Eq. (11.12) and Eq. (11.10),





nk

exp S^ni  k exp S^n + 2

Ptj X^t2j  .

t=1 j=1

Taking the logarithm of both sides, dividing by  > 0 and reordering gives

S^ni

-

S^n



log(k) 

+

n t=1

k
Ptj X^t2j
j=1

.

(11.13)

As noted earlier, the expectation of the left-hand side is Rni. The first term on the right-hand side is a constant, which leaves us to bound the expectation of the second term. Letting ytj = 1 - xtj and Yt = 1 - Xt and expanding the definition

11.4 Regret Analysis

154

of X^t2j leads to







k

k

E  Ptj X^t2j  = E  Ptj

j=1

j=1

1

-

I

{At = j} Ptj

ytj

2






k
= E  Ptj
j=1

1-2

I {At = j} ytj Ptj

+

I {At = j} yt2j Pt2j









=

E

1

-

2Yt

+

Et-1

k

j=1

I

{At

= j} Ptj

yt2j







k

= E 1 - 2Yt + yt2j

j=1





= E (1 - Yt)2 +

yt2j 

j=At

 k.

Summing over t, and then substituting into Eq. (11.13), we get

Rni



log(k) 

+

nk

=

2

nk log(k) ,

where the equality follows by substituting  = log(k)/(nk), which was chosen to optimise this bound.

At the heart of the proof are the inequalities:

1 + x  exp(x) for all x  R and

exp(x)  1 + x + x2 for x  1 .

The former of these inequalities is an ansatz derived from the first-order Taylor expansion of exp(x) about x = 0. The latter, however, is not the second-order Taylor expansion, which would be 1 + x + x2/2. The problem is that the secondorder Taylor series is not an upper bound on exp(x) for x  1, but only for x  0:

exp(x)



1

+

x

+

1 2

x2

for

all

x



0.

(11.14)

But it is nearly an upper bound, and this can be exploited to improve the bound in Theorem 11.1. The mentioned upper and lower bounds on exp(x) are shown in Fig. 11.3, from which it is quite obvious that the bound in Eq. (11.14) is significantly tighter when x  0.
Let us now put Eq. (11.14) to use in proving the followingimproved version of Theorem 11.1, for which the regret is smaller by a factor of 2. The algorithm is unchanged except for a slightly increased learning rate.

11.4 Regret Analysis

155

exp(x) - (1 + x)

exp(x) - (1 + x + x2)

0.1

exp(x) - (1 + x + x2/2)

0

-0.1

-0.5

0

0.5

x

Figure 11.3 Approximations for exp(x) on [-1/2, 1/2].

Theorem 11.2. Let x  [0, 1]n×k be an adversarial bandit and  be the policy of Exp3 with learning rate  = 2 log(k)/(nk). Then,

Rn(, x)  2nk log(k) . Proof By construction, X^tj  1. Therefore,

exp X^tj = exp() exp (X^tj - 1)

 exp()

1

+

(X^tj

-

1)

+

2 2

(X^tj

-

1)2

.

Using the fact that j Ptj = 1 and the inequality 1 + x  exp(x), we get





Wt Wt-1

=

k

k

Ptj exp(X^tj)  exp  PtjX^tj

j=1

j=1

+

2 2

k
Ptj (X^tj
j=1

- 1)2

,

where the equality is from Eq. (11.11). We see that here we need to bound j Ptj(X^tj - 1)2. Let Y^tj = 1 - X^tj. Then,

Ptj (X^tj - 1)2 = Ptj Y^tj Y^tj = I {At = j} ytj Y^tj  Y^tj ,

where the last inequality used Y^tj  0 and ytj  1. Thus,

k

k

Ptj (X^tj - 1)2  Y^tj .

j=1

j=1

With the same calculations as before, we get

S^ni

- S^n



log(k) 

+

 2

n t=1

k
Y^tj
j=1

.

(11.15)

11.5 Notes

156

The result is completed by taking expectations of both sides, using E t,j Y^tj = E t,j Et-1Y^tj = E t,j ytj  nk and substituting the learning rate.

The reader may wonder about the somewhat ad hoc proof. The best we can do for now is to point out a few things about the proof. It is natural to replace the true rewards with the estimated ones. Then, to prove a regret

bound in terms of the estimated rewards, an alternative to the proof is

to start with the the trivial inequality that states that for any x = (xj)

vector

and

positive

quantity

,

the

inequality

xi



1 

log

j exp(xj) holds.

Applying this with x = (S^ni) gives

S^ni



1 

log(

exp(S^nj ))

=

1 

log(Wn) ,

j

from where the proof can be continued by introducing the telescoping argument.

11.5

Notes

1 Exp3 is nearly optimal in the sense that its expected regret cannot be improved significantly in the worst case. The distribution of its regret, however, is very far from optimal. Define the random regret to be the random variable measuring the actual deficit of the learner relative to the best arm in hindsight:

n

n

n

n

R^n

=

max
i[k]

t=1

xti

-

t=1

Xt

=

t=1

Yt

- min
i[k]

yti
t=1

.

in terms of rewards

in terms of losses

In Exercise 11.6 you will show that for all large enough n and reasonable choices of , there exists a bandit such that the random regret of Exp3 satisfies P(R^n  n/4) > 1/131. In the same exercise, you should explain why this does not contradict the upper bound. That Exp3 has such a high variance is a serious limitation, which we address in the next chapter.
2 What happens when the range of the rewards is unbounded? This has been studied by Allenberg et al. [2006], where some (necessarily much weaker) positive results are presented.
3 In the full information setting, the learner observes the whole vector xt  [0, 1]k at the end of round t, but the reward is still xtAt . This setting is also called prediction with expert advice. Exponential weighting is still a good idea, but the estimated rewards can now be replaced by the actual rewards. The resulting algorithm is sometimes called Hedge or the exponential weights algorithm. The proof as written goes through in almost the same way,

11.5 Notes

157

but one should replace the polynomial upper bound on exp(x) with Hoeffding's lemma. This analysis gives a regret of n log(k)/2, which is optimal in an asymptotic sense [Cesa-Bianchi and Lugosi, 2006].
4 We assumed that the adversary chooses the rewards at the start of the game. Such adversaries are called oblivious. An adversary is called reactive or non-oblivious if xt is allowed to depend on the history x1, A1, . . . , xt-1, At-1. Despite the fact that this is clearly a harder problem, the result we obtained can be generalised to this setting without changing the analysis. It is another question whether the definition of regret makes sense for reactive environments.
5 A more sophisticated algorithm and analysis shaves a factor of log(k) from the regret upper bound in Theorem 11.2 [Audibert and Bubeck, 2009, 2010a, Bubeck and Cesa-Bianchi, 2012]. It turns out that this algorithm, just like Exp3, is an instantiation of mirror descent from convex optimisation, which we present in Chapter 28. More details are in Exercise 28.15. Interestingly, this algorithm not only shaves off the extra log(k) factor from the regret, but also achieves O(log(n))-regret in the stochastic setting provided that one uses a learning rate of 1/ t in round t [Zimmert and Seldin, 2019]. This remarkable result improves in an elegant way on many previous attempts to design algorithms for stochastic and adversarial bandits [Bubeck and Slivkins, 2012, Seldin and Slivkins, 2014, Auer and Chiang, 2016, Seldin and Lugosi, 2017]. There are some complications, however, depending on whether or not the adversary is oblivious. The situation is best summarised by Auer and Chiang [2016], where the authors present upper and lower bounds on what is possible in various scenarios.
6 The initial distribution (the `prior') P1 does not have to be uniform. By biasing the prior towards a specific action, the regret can be reduced when the favoured action turns out to be optimal. There is an unavoidable price for this, however, if the optimal arm is not favoured [Lattimore, 2015a].
7 Building on the previous note, suppose the reward in round t is Xt = ft(A1, . . . , At) and f1, . . . , fn are a sequence of functions chosen in advance by the adversary with ft : [k]t  [0, 1]. Let   [k]n be a set of action sequences. Then the expected policy regret with respect to  is

n

n

max
a1 ,...,an 

t=1

ft(a1,

.

.

.

,

at)

-

E

ft(A1, . . . , At)
t=1

.

Even if  only consists of constant sequences, there still does not exist a policy
guaranteeing sublinear regret. The reason is simple. Consider the two candidate choices of f1, . . . , fn. In the first choice, ft(a1, . . . , at) = I {a1 = 1}, and in the second we have ft(a1, . . . , at) = I {a1 = 2}. Clearly the learner must suffer linear regret in at least one of these two reactive bandit environments. The
problem is that the learner's decision in the first round determines the rewards
available in all subsequent rounds, and there is no time for learning. By making

11.5 Notes

158

additional assumptions, sublinear regret is possible, however ­ e.g. by assuming the adversary has limited memory [Arora et al., 2012]. 8 There is a common misconception that the adversarial framework is a good fit for non-stationary environments. While the framework does not assume the rewards are stationary, the regret concept used in this chapter has stationarity built in. A policy designed for minimising the regret relative to the best action in hindsight is seldom suitable for non-stationary bandits, where the whole point is to adapt to changes in the optimal arm. In such cases a better benchmark is to compete with a sequence of actions. For more on non-stationary bandits, see Chapter 31. 9 The estimators in Eq. (11.3) and Eq. (11.6) both have conditional variance Vt[X^ti]  1/Pti, which blows up for small Pti. It is instructive to think about whether and how Pti can take on very small values. Consider the loss-based estimator given by (11.6). For this estimator, when PtAt and Xt are both small, X^tAt can take on a large negative value. Through the update formula (11.7), this then translates into Pt+1,At being squashed aggressively towards zero. A similar issue arises with the reward-based estimator given by (11.3). The difference is that now it will be a `positive surprise' (PtAt small, Xt large) that pushes the probabilities towards zero. But note that in this case, Pt+1,i is pushed towards zero for all i = At. This means that dangerously small probabilities are expected to be more frequent for the gains estimator Eq. (11.3). 10 Exp3 requires advance knowledge of the horizon. The doubling trick can be used to overcome this issue, but a more elegant solution is to use a decreasing learning rate. The analysis in this chapter can be adapted to this case. More discussion is provided in the notes and exercises of Chapter 28, where we give a more generic solution to this problem (Exercise 28.13). 11 The calculation in Eq. (11.2) is a reduction, showing that algorithms with low regret on finite-armed adversarial bandits also have low regret on stochastic bandits where the reward distributions have appropriately bounded support. Reductions play an important role throughout the bandit literature and we will see many more examples. The reader should be careful not to generalise the idea that adversarial algorithms work well on stochastic problems. The assumptions must be checked (like boundedness of the support), and for different models there can be subtleties. The whole of Chapter 29 is devoted to the linear case. 12 As we mentioned, a policy for k-armed adversarial bandits is defined by any function  : ([k] × [0, 1])  Pk-1. There is no need to assume that  is measurable because the actions are discrete and the rewards are deterministic. The relations between the stochastic and adversarial regret are only well defined for policies that are probability kernels as defined in Definition 4.7. You might be worried that lower bounds for stochastic bandits only imply lower bounds for measurable adversarial policies. Fortunately, the lower bounds are easily proven for Bernoulli bandits, and in this case the space of reward sequences is finite and measurability is no longer problematic. Later we study adversarial bandits

11.6 Bibliographic Remarks

159

with an infinite action set A, which is equipped with a -algebra G. In this case the reward vectors are replaced by functions (xt)tn=1, where xt : A  [0, 1] is G-measurable. Then, the measurability condition on the policy is that for all choices of the adversary and all B  B(A),
(B | a1, x1(a1), . . . , at-1, xt-1(at-1))
must be measurable as a function of a1, . . . , at-1. In practice, of course, all the policies you might ever propose would also be measurable as a function of the rewards.

11.6

Bibliographic Remarks
Exponential weighting has been a standard tool in online learning since the papers by Vovk [1990] and Littlestone and Warmuth [1994]. Exp3 and several variations were introduced by Auer et al. [1995], which was also the first paper to study bandits in the adversarial framework. The algorithm and analysis presented here differs slightly because we do not add any additional exploration, while the version of Exp3 in that paper explores uniformly with low probability. The fact that additional exploration is not required was observed by Stoltz [2005].

11.7

Exercises
11.1 (Sampling from a multinomial) In order to implement Exp3, you need a way to sample from the exponential weights distribution. Many programming languages provide a standard way to do this. For example, in Python you can use the Numpy library and numpy.random.multinomial. In more basic languages, however, you only have access to a function rand() that returns a floating point number `uniformly' distributed in [0, 1]. Describe an algorithm that takes as input a probability vector p  Pk-1 and uses a single call to rand() to return X  [k] with P (X = i) = pi.
On most computers, rand() will return a pseudo-random number, and since there are only finitely many floating point numbers, the resulting distribution will not really be uniform on [0, 1]. Thinking about these issues is a worthy endeavour, and sometimes it really matters. For this exercise you may ignore these issues, however.

11.2 (Linear regret for deterministic policies) Show that for any deterministic policy  there exists an environment x  [0, 1]n×k such that
Rn(, x)  n(1 - 1/k). What does your result say about the policies designed in Part II?

11.7 Exercises

160

11.3 (Maximum and expectations) Show that the first inequality in (11.2) holds: Moving the maximum inside the expectation increases the value of the expectation.

11.4 (Alternative regret definition) Suppose we had defined the regret by

n

n

Rntrack(, x) = E

t=1

max
i[k]

xti

-

t=1

xtAt

.

At first sight this definition seems like the right thing because it measures what
you actually care about. Unfortunately, however, it gives the adversary too much power. Show that for any policy  (randomised or not), there exists a x  [0, 1]k×n
such that

Rntrack(, x)  n

1

-

1 k

.

11.5 (Unbiased estimators are importance weighted) Let P  Pk-1
be a probability vector with nonzero components and let A  P . Suppose X^ : [k] × R  R is a function such that for all x  Rk,

k
E[X^ (A, xA)] = PiX^ (i, xi) = x1 .
i=1

Show that there exists an a  Rk such that a, P = 0 and for all i and z in their

respective

domains,

X^ (i,

z)

=

ai

+

I

{i

= 1} P1

z

.

11.6 (Variance of Exp3) In this exercise, you will show that if   [n-p, 1] for some p  (0, 1), then for sufficiently large n, there exists a bandit on which Exp3
has a constant probability of suffering linear regret. We work with losses so that given a bandit y  [0, 1]n×k, the learner samples At from Pt given by

Pti =

exp -

t-1 s=1

Y^si

,

k j=1

exp

-

t-1 s=1

Y^sj

where Y^ti = Atiyti/Pti. Let   [1/4, 1/2] be a constant to be tuned subsequently and define a two-armed adversarial bandit in terms of its losses by

0 if t  n/2 yt1 = 1 otherwise

 if t  n/2

and

yt2 = 0 otherwise .

For simplicity you may assume that n is even.

(a) Define the sequence of real-valued functions q1, . . . , qn on domain [1/4, 1/2] inductively by q0() = 1/2 and

qs+1()

=

1

-

qs() exp(-/qs()) qs() + qs() exp(-/qs())

.

11.7 Exercises

161

Regret

4,000 3,000 2,000 1,000
0 -1,000

0.28 0.285 0.29 0.295
0.3



Figure 11.4 Exp3 instability: Box and whisker plot of the distribution of the regret of Exp3 for different values of  over a horizon of n = 104 with m = 500 repetitions for the
example of Exercise 11.6. The boxes represent the quartiles of the empirical distribution,
the diamond shows the average; the median is equal to the upper quartile (and thus
cannot be seen), while the dots show values outside of the "interquartile range".

Show for t  1 + n/2 that Pt2 = qT2(t-1)(), where T2(t) =

t s=1

As2.

(b) Show that for sufficiently large n there exists an   [1/4, 1/2] and s  N

such that

qs()

=

1 8n

and

s-1 u=0

1 qu()



n 8

.

(c) Prove that P(T2(n/2)  s + 1)  1/65. (d) Prove that P(R^n  n/4)  (1 - n exp(-n)/2)/65.
(e) The previous part shows that the regret is linear with constant probability
for sufficiently large n. On the other hand, a dubious application of Markov's
inequality and Theorem 11.1 shows that

P(R^n



n/4)



4E[R^n] n

=

O(n-1/2) .

Explain the apparent contradiction.
(f) Validate the theoretical results of this exercise in an experimental fashion: Implement Exp3 with the loss sequence suggested to reproduce Fig. 11.4. The learning rate is set to the value computed in Theorem 11.2:  = 2 log(k)/(nk). Compare the figure with the theoretical results: Is there an agreement between theory and the empirical results?

11.7 Exercises

162

11.7 (Gumbel trick) Let a1, . . . , ak be positive real values and U1, . . . , Uk be a sequence of independent and identically distributed uniform random variables on [0, 1]. Then let Gi = - log(- log(Ui)), which follows a standard Gumbel distribution. Prove that

P log(ai) + Gi = max(log(aj) + Gj) =
j[k]

ai

k j=1

aj

.

11.8 (Exp3 as follow-the-perturbed-leader) Let (Zti)ti be a collection of independent and identically distributed random variables. The follow-theperturbed-leader algorithm chooses

t-1
At = argmaxi[k] Zti -  Y^si .
s=1
Show that if Zti is a standard Gumbel, then follow-the-perturbed-leader is the same as Exp3.

11.9 (Exp3 on stochastic bandits) In this exercise we compare UCB and Exp3 on stochastic data. Suppose we have a two-armed stochastic Bernoulli bandit with µ1 = 0.5 and µ2 = µ1 +  with  = 0.05.
(a) Plot the regret of UCB and Exp3 on the same plot as a function of the horizon n using the learning rate from Theorem 11.2.
(b) Now fix the horizon to n = 105 and plot the regret as a function of the learning rate. Your plot should look like Fig. 11.5.
(c) Investigate how the shape of this graph changes as you change . (d) Find empirically the choice of  that minimises the worst-case regret over all
reasonable choices of , and compare to the value proposed by the theory. (e) What can you conclude from all this? Tell an interesting story.

Hint The performance of UCB depends greatly on which version you use. For best results, remember that Bernoulli distributions are 1/2-subgaussian or use the KL-UCB algorithm from Chapter 10.

11.7 Exercises

163

Expected regret

250

Exp3

200

150

100

0

0.1



Figure 11.5 Expected regret for Exp3 for different learning rates over n = 105 rounds on a Bernoulli bandit with means µ1 = 0.5 and µ2 = 0.55.

12 The Exp3-IX Algorithm

In the last chapter, we proved a sublinear bound on the expected regret of Exp3, but with a dishearteningly large variance. The objective of this chapter is to modify Exp3 so that the regret stays small in expectation and is simultaneously well concentrated about its mean. Such results are called high-probability bounds. By slightly modifying the algorithm, we show that for each   (0, 1), there exists an algorithm such that with probability at least 1 - ,

n

R^n

=

max
aA

(ytAt - yta) = O

nk log

k 

.

t=1

The poor behaviour of Exp3 occurs because the variance of the importanceweighted estimators can become very large. In this chapter we modify the reward estimates to control the variance at the price of introducing some bias.

12.1

The Exp3-IX Algorithm

We start by summarising what we know about the behaviour of the random regret of Exp3. Because we want to use the loss-based estimator, it is more convenient to switch to losses, which we do for the remainder of the chapter. Rewriting Eq. (11.15) in terms of losses,

L^n

- L^ni



log(k) 

+

 2

k
L^ nj
j=1

,

(12.1)

where L^n and L^ni are defined using the loss estimator Y^tj by

nk

n

L^n =

Ptj Y^tj and L^ni = Y^ti .

t=1 j=1

t=1

Eq. (12.1) holds no matter how the loss estimators are chosen, provided they satisfy 0  Y^ti  1/Pti for all t and i. Of course, the left-hand side of Eq. (12.1) is not close to the regret unless Y^ti is a reasonable estimator of
the loss yti.

12.1 The Exp3-IX Algorithm

165

We also need to define the sum of losses observed by the learner and for each fixed action, which are

n

L~n =

ytAt

t=1

and

n
Lni = yti
t=1

Like in the previous chapter, we need to define the (random) regret with respect to a given arm i as follows:

n

n

R^ni = xti - Xt = L~n - Lni .

t=1

t=1

(12.2)

By substituting the above definitions into Eq. (12.1) and rearranging, the regret with respect to arm i is bounded by

R^ni = L~n - Lni = (L~n - L^n) + (L^n - L^ni) + (L^ni - Lni)



log(k) 

+

(L~n

-

L^n)

+

(L^ ni

-

Lni)

+

 2

k
L^nj .

j=1

(12.3)

This means the random regret can be bounded by controlling L~n - L^n, L^nj - Lnj and L^nj for each j. As promised we now modify the loss estimate. Let  > 0 be a small constant to be chosen later and define the biased estimator

Y^ti

=

I {At = i} Yt Pti + 

.

(12.4)

First, note that Y^ti still satisfies 0  Y^ti  1/Pti, so (12.3) is still valid. As  increases, the predictable variance decreases, but the bias increases. The optimal choice of  depends on finding the sweet spot, which we will do once the dust has settled in the analysis. When Eq. (12.4) is used in the exponential update in Exp3, the resulting algorithm is called Exp3-IX (Algorithm 10). The suffix `IX' stands for implicit exploration, a name justified by the following argument. A simple calculation shows that

Et[Y^ti] =

Ptiyti Pti + 

= yti -

yti Pti + 

 yti .

Since small losses correspond to large rewards, the estimator is optimistically biased. The effect is a smoothing of Pt so that actions with large losses for which Exp3 would assign negligible probability are still chosen occasionally. In fact, the smaller is Pti, the larger the bias is. As a result, Exp3-IX will explore more than the standard Exp3 algorithm (see Exercise 12.5).

The reason for calling the exploration implicit is because the algorithm explores more as a consequence of modifying the reward estimates, rather than directly alternating Pt.

12.2 Regret Analysis

166

1: Input: n, k, ,  2: Set L^0i = 0 for all i
3: for t = 1, . . . , n do
4: Calculate the sampling distribution Pt:

Pti =

exp -L^t-1,i

k j=1

exp

- L^ t-1,j

5: Sample At  Pt and observe reward Xt

6:

Calculate

L^ ti

=

L^ t-1,i

+

I {At

= i} (1 - Pti + 

Xt)

7: end for

Algorithm 10: Exp3-IX.

12.2

Regret Analysis

We now prove the following theorem bounding the random regret of Exp3-IX with high probability.
Theorem 12.1. Let   (0, 1) and define

1 =

2 log(k + 1) nk

and

2 =

log(k)

+ log( nk

k+1 

)

.

The following statements hold:

1 If Exp3-IX is run with parameters  = 1 and  = /2, then

P R^n 

8nk log(k + 1) +

2

nk log(k

+

1)

log

1 

+ log

k+1 

2 If Exp3-IX is run with parameters  = 2 and  = /2, then

P

R^n  2

(2 log(k + 1) + log(1/))nk + log

k+1 

 .

 . (12.5)
(12.6)

The value of 1 is independent of , which means that using this choice of learning rate leads to a single algorithm with a high-probability bound for all . On the other hand, 2 does depend on , so the user must choose a confidence level from the beginning. The advantage is that the bound is improved, but only for the specified confidence level. We will show in Chapter 17 that this trade-off is unavoidable.

The proof follows by bounding each of the terms in Eq. (12.3), which we do via a series of lemmas. The first of these lemmas is a new concentration bound.

12.2 Regret Analysis

167

To state the lemma, we recall two useful notions: Recall that given a filtration F = (Ft)nt=0, (Zt)nt=1 is F-adapted if for t  [n], Zt is Ft-measurable and (Zt)tn=1 is F-predictable, if for t  [n], Zt is Ft-1-measurable.
Lemma 12.2. Let F = (Ft)tn=0 be a filtration and for i  [k] let (Y~ti)t be F-adapted such that:

1 2

for any S  [k] with |S| > 1, E E Y~ti Ft-1 = yti for all t  [n]

iS Y~ti Ft-1 and i  [k].

 0; and

Furthermore, let (ti)ti and (ti)ti be real-valued F-predictable random sequences such that for all t, i it holds that 0  tiY~ti  2ti. Then, for all   (0, 1),

P

nk
ti
t=1 i=1

1

Y~ti + ti

- yti

 log

1 

 .

The proof relies on the Cram´er­Chernoff method and is deferred until the end of the chapter. Condition 1 states that the variables {Y~ti}i are negatively
correlated, and it helps us save a factor of k. Equipped with this result, we can easily bound the terms L^ni - Lni.

Lemma 12.3 (Concentration ­ variance). Let   (0, 1). With probability at least 1 - , the following inequalities hold simultaneously:

max
i[k]

L^ni - Lni



log(

k+1 

)

2

and

k i=1

L^ni - Lni



log(

k+1 

)

2

.

(12.7)

Proof Fix   (0, 1) to be chosen later and let Ati = I {At = i} as before. Then

k

nk

(L^ni - Lni) =

i=1

t=1 i=1

Atiyti Pti + 

- yti

=

1 2

n t=1

k
2
i=1

1

1

+

 Pti

Atiyti Pti

- yti

.

Introduce

ti

=

 Pti

,

Y~ti

=

Ati yti Pti

and

ti

= 2.

Notice that

the conditions

of

Lemma 12.2 are now satisfied. In particular, for any S  [k] with |S| > 1, it holds

that iS Ati = 0 and hence iS Y~ti = 0. Therefore,

P

k

(L^ni - Lni) 

log(1/ ) 2

i=1

Similarly, for any fixed i,

 .

(12.8)

P

L^ ni

-

Lni



log(1/ 2

)

 .

(12.9)

To see this, use the previous argument with tj = I {j = i} 2. The result follows by choosing  = /(k + 1) and the union bound.

Lemma 12.4 (Bias). L~n - L^n = 

k j=1

L^ nj

.

12.2 Regret Analysis

168

Proof Let Ati = I {At = i} as before. Writing Yt = j Atjytj, we calculate

k

k

Yt - Ptj Y^tj =

j=1

j=1

1

-

Ptj Ptj +



Atj ytj

=



k j=1

Atj Ptj +

 ytj

=



k j=1

Y^tj

.

Therefore L~n - L^n = 

k j=1

L^ nj

as

required.

Proof of Theorem 12.1 By Eq. (12.3) and Lemma 12.4, we have

R^n



log(k) 

+

(L~n

-

L^n)

+

max(L^ni
i[k]

-

Lni)

+

 2

k j=1

L^ nj

=

log(k) 

+

mia[kx] (L^ ni

-

Lni)

+

 2

+



k
L^nj .
j=1

Therefore, by Lemma 12.3, with probability at least 1 - ,





R^n



log(k) 

+

log

k+1 
2

+



+

 2

k

j=1

Lnj

+

log

k+1 
2





log(k) 

+



+

 2

nk +



+

 2

+

1

log

k+1 

2

,

where the second inequality follows since Lnj  n for all j. The result follows by substituting the definitions of   {1, 2} and  = /2.

The attentive reader may be wondering whether proving the new
concentration inequality of Lemma 12.2, which looks a bit ad hoc, was really necessary to get the bounds on L^ni that were stated in the next
lemma. After all, we had a number of concentration inequalities available
to us that could be applied. As it turns out, one could also use Bernstein
inequality to get a result that only loses a factor of two compared to the
specialised lemma. The details are in Exercise 12.1. There are two important lessons that are the basis of both proofs. The first is that since E[L^ni] < Lni and the gap between these two quantities is large enough in a manner that we make precise in Exercise 12.1, the deviation L^ni - Lni can be bounded
independently of Pti, Ati and yti. The price is that instead of log(1/), the
bound scales linearly with the generally larger quantity log(1/). The factor 1/ here is the maximum scale of the individual summands in L^ni. The second lesson is specific to how in bounding i L^ni - Lni a union bound over i is avoided: this works because for a fixed time index t, (Ati)i are negatively
correlated. Negative dependence/association/correlation are known to be
good substitutes for independence, and by exploiting such properties one
can often demonstrate better concentration.

12.2 Regret Analysis

169

12.2.1

Proof of Lemma 12.2

We start with a technical inequality:

Lemma 12.5. For any 0  x  2 it holds that exp

x 1+

 1+x.

Note that 1+x  exp(x). What the lemma shows is that by slightly discounting the argument of the exponential function, in a bounded neighbourhood of zero, 1 + x can be an upper bound for the resulting function. Or, equivalently, slightly inflating the linear term in 1 + x, the linear lower bound becomes an upper bound.

Proof of Lemma 12.5 We have

exp

x 1+

 exp

x 1 + x/2

 1+x,

where

the

first

inequality

is

because





exp(

x 1+

)

is

decreasing

in

,

and

the

second

is

because

2u 1+u



log(1 + 2u)

holds

for

all

u



0.

This

latter

inequality

can be seen to hold by noting that for u = 0, the two sides are equal, while the

derivative of the left-hand side is smaller than that of the right-hand side at any

u  0.

Proof of Lemma 12.2 Fix t  [n] and let Et[·] = E[· | Ft] denote the conditional expectation with respect to Ft. By Lemma 12.5 and the assumption that 0  tiY~ti  2ti, we have

exp

tiY~ti 1 + ti

 1 + tiY~ti .

Taking the product of these inequalities over i,

Et-1 exp

k tiY~ti i=1 1 + ti

k

k

 Et-1

(1 + tiY~ti)  1 + Et-1

tiY~ti

i=1

i=1

k

k

= 1 + tiyti  exp

tiyti ,

(12.10)

i=1

i=1

where the second inequality follows from

ki=1(1 + ai) =

b{0,1}k

k i=1

abi i

and

the assumption that for S  [k] with |S| > 1, Et-1[ iS Y~ti]  0, the third one

follows from the assumption that Et-1[Y~ti] = yti, while the last one follows from

1 + x  exp(x). Define

Zt = exp

k
ti
i=1

Y~ti 1 + ti

-

yti

and let Mt = Z1 . . . Zt, t  [n] with M0 = 1. By (12.10), Et-1[Zt]  1. Therefore

E[Mt] = E[Et-1[Mt]] = E[Mt-1Et-1[Zt]]  E[Mt-1]  · · ·  E[M0] = 1 .

Setting t = n and combining the above display with Markov's inequality leads to P (log(Mn)  log(1/)) = P (Mn  1)  E [Mn]   .

12.3 Notes

170

12.3

Notes

1 An alternative to the somewhat custom-made Lemma 12.2 is to use a Bernstein-

type bound that simply bounds the deviation of a martingale from its mean

in terms of its quadratic variation. The slight disadvantage of this is that this

way we lose a factor of two. If this is not a concern, one may even prefer this

approach due to its greater transparency. For details, see Exercise 12.1.

2 An upper bound on the expected regret of Exp3-IX can be obtained by

integrating the tail:





Rn  E[(R^n)+] =

P (R^n)+  x dx 

P R^n  x dx ,

0

0

where the first equality follows from Proposition 2.8. The result is completed

using either the high-probability bound in Theorem 12.1 and by straightforward

integration. We leave the details to the reader in Exercise 12.7.

3 The analysis presented here uses a fixed learning rate that depends on the

horizon. Replacing  and  with t = log(k)/(kt) and t = t/2 leads to an anytime algorithm with about the same regret [Koca´k et al., 2014, Neu, 2015a].

4 There is another advantage of the modified importance-weighted estimators

used by Exp3-IX, which leads to an improved regret in the special case that

one of the arms has small losses. Specifically, it is possible to show that

Rn = O

k min Lni log(k) .
i[k]

In the worst case, Lni is linear in n and the usual bound is recovered. But if the optimal arm enjoys low cumulative regret, then the above can be a big improvement over the bounds given in Theorem 12.1. Bounds of this kind are called first-order bounds. We refer the interested reader to the papers by Allenberg et al. [2006], Abernethy et al. [2012] and Neu [2015b] and Exercise 28.14. 5 Another situation where one might hope to have a smaller regret is when the rewards/losses for each arm do not deviate too far from their averages. Define the quadratic variation by

n
Qn =

xt - µ 2 ,

where

µ

=

1 n

n

xt .

t=1

t=1

Hazan

and

Kale

[2011]

gave

an

algorithm

for

which

Rn

=

O(k2

 Qn

),

which

can

be better than the worst-case bound of Exp3 or Exp3-IX when the quadratic

variation is very small. The factor of k2 is suboptimal and can be removed

using a careful instantiation of the mirror descent algorithm [Bubeck et al.,

2018]. We do not cover this exact algorithm in this book, but the techniques

based on mirror descent are presented in Chapter 28.

6 An alternative to the algorithm presented here is to mix the probability

distribution computed using exponential weights with the uniform distribution,

12.4 Bibliographic Remarks

171

while biasing the estimates. This leads to the Exp3.P algorithm due to Auer et al. [2002b], who considered the case where  is given and derived a bound that is similar to Eq. (12.6) of Theorem 12.1. With an appropriate modification of their proof, it is possible to derive a weaker bound similar to Eq. (12.5), where the knowledge of  is not needed by the algorithm. This has been explored by Beygelzimer et al. [2010] in the context of a related algorithm, which will be considered in Chapter 18. One advantage of this approach is that it generalises to the case where the loss estimators are sometimes negative, a situation that can arise in more complicated settings. For technical details, we advise the reader to work through Exercise 12.3.

12.4

Bibliographic Remarks
The Exp3-IX algorithm is due to Koc´ak et al. [2014], who also introduced the biased loss estimators. The focus of that paper was to improve algorithms for more complex models with potentially large action sets and side information, though their analysis can still be applied to the model studied in this chapter. The observation that this algorithm also leads to high-probability bounds appeared in a follow-up paper by Neu [2015a]. High-probability bounds for adversarial bandits were first provided by Auer et al. [2002b] and explored in a more generic way by Abernethy and Rakhlin [2009]. The idea to reduce the variance of importanceweighted estimators is not new and seems to have been applied in various forms [Uchibe and Doya, 2004, Wawrzynski and Pacut, 2007, Ionides, 2008, Bottou et al., 2013]. All of these papers are based on truncating the estimators, which makes the resulting estimator less smooth. Surprisingly, the variance-reduction technique used in this chapter seems to be recent [Koca´k et al., 2014].

12.5

Exercises

12.1 (Bernstein-type inequality and Lemma 12.3) Using the Berstein-type inequality stated in Exercise 5.15, show the following:

(a)

For

any



 (0, 1),

with

probability

at

least

1 - ,

L^ni - Lni

<

1 

log(1/).

(b) For any   (0, 1), with probability at least 1 - , i L^ni - i Lni <

1 

log(1/).

12.2 Prove the claims made in Note 3.

Hint The source for this exercise is theorem 1 of the paper by Neu [2015a]. You can also read ahead and use the techniques from Exercise 28.13.
12.3 (Exp3.P) In this exercise we ask you to analyse the Exp3.P algorithm, which as we mentioned in the notes is another way to obtain high probability

12.5 Exercises

172

bounds. The idea is to modify Exp3 by biasing the estimators and introducing

some forced exploration. Let Y^ti = Atiyti/Pti - /Pti be a biased version of the

loss-based importance-weighted estimator that was used in the previous chapter.

Define L^ti =

t s=1

Y^si

and

consider

the

policy

that

samples

At



Pt,

where

Pti

=

(1

-

)P~ti

+

 k

with

P~ti =

exp -L^t-1,i

.

k j=1

exp

- L^ t-1,j

(a) Let   (0, 1) and i  [k]. Show that with probability 1 - , the random regret R^ni against i (cf. (12.2)) satisfies

R^ni

<

n

nk

+ (1 - )

P~tj (Y^tj

t=1 j=1

- yti) +

n t=1

 PtAt

+

n

log(1/) 2

.

(b) Show that

nk

nk

n

P~tj (Y^tj - yti) =

P~tj (Y^tj - Y^ti) + (Y^ti - yti) .

t=1 j=1

t=1 j=1

t=1

(c) Show that

n

k

P~tj (Y^tj

- Y^ti)



log(k) 

+

n

k
P~tj Y^t2j .

t=1 j=1

t=1 j=1

(d) Show that

n t=1

k
P~tj Y^t2j
j=1



nk22 

+

n t=1

1 PtAt

.

(e) Suppose that  = k and  = . Apply the result of Exercise 5.15 to show that for any   (0, 1), the following hold:

P

n t=1

1 PtAt

 2nk +

k 

log

1 

 .

P

n

Y^ti

- yti



1 

log

1 

t=1

 .

(f) Combining the previous steps, show that there exists a universal constant
C > 0 such that for any   (0, 1), for an appropriate choice of ,  and , with probability at least 1 -  it holds that the random regret R^n of Exp3.P
satisfies

R^n  C nk log(k/) .

(g) In which step did you use the modified estimators? (h) Show a bound where the algorithm parameters , ,  can only depend on
n, k, but not on . (i) Compare the bounds with the analogous bounds for Exp3-IX in Theorem 12.1.

12.5 Exercises

173

12.4 (Generic Exp3.P analysis) This exercise is concerned with a
generalisation of the core idea underlying Exp3.P of the previous exercise in that
rather than giving explicit expressions for the biased loss estimates, we focus
on the key properties required by the analysis of Exp3.P. To reduce clutter, we assume for the remainder that t ranges in [n] and a  [k]. Let (, F, F, P) be a filtered probability space with F = (Ft)nt=0. Let (Zt), (Z^t), (Z~t), (t) be sequences of random elements in Rk, where Z~t = Z^t - t and (Zt), (t) are F-predictable, whereas (Z^t) and therefore also (Z~t) are F-adapted. You should think of Z^t as the estimate of Zt that uses randomisation, and t is the bias as in the previous exercise. Given positive constant , define the probability vector Pt  Pk-1 by

Pta =

exp -

t-1 s=1

Z~sa

.

k b=1

exp

-

t-1 s=1

Z~sb

Let Et-1[·] = E [· | Ft-1]. Assume the following hold for all a  [k]:

(a) |Z^ta|  1 , (c) Et-1[Z^t2a]  ta almost surely ,

(b) ta  1 , (d) Et-1[Z^ta] = Zta almost surely .

Let A = argmina[k]

nk

n t=1

Zta

and

Rn

=

Pta(Zta - ZtA ).

t=1 a=1

(a) Show that

nk

Pta(Zta - ZtA )

t=1 a=1

nk

nk

n

=

Pta(Z~ta - Z~tA ) +

Pta(Zta - Z~ta) + (Z~tA - ZtA ) .

t=1 a=1

t=1 a=1

t=1

(A)

(B)

(C)

(b) Show that

(A)



log(k) 

+



n

k

n

PtaZ^t2a + 3

k
Ptata .

t=1 a=1

t=1 a=1

(c) Show that with probability at least 1 - ,

(B)



2

n t=1

k a=1

Ptata

+

log(1/) 

.

(d) Show that with probability at least 1 - k,

(C)



log(1/) 

.

12.5 Exercises

174

(e) Conclude that for any   1/(k + 1), with probability at least 1 - (k + 1),

Rn



3 log(1/) 

+



n

k

n

PtaZ^t2a + 5

k
Ptata .

t=1 a=1

t=1 a=1

Hint This is a long and challenging exercise. You may find it helpful to use the result in Exercise 5.15. The solution is also available.

12.5 (Implementation) Consider the Bernoulli bandit with k = 5 arms and n = 104 with means µ1 = 1/2 and µi = 1/2 -  for i > 1. Plot the regret of Exp3 and Exp3-IX for   [0, 1/2]. You should get a plot similar to that of Fig. 12.1.
Does the result surprise you?

Regret

300 250 200 150 100
0

0.1 0.2 0.3 0.4 0.5 

Exp3 Exp3-IX

Figure 12.1 Comparison between Exp3 and Exp3-IX on Bernoulli bandit
12.6 (Implementation: Variance of Exp3-IX) Repeat the experiment that led to Fig. 11.4 but with Exp3 swapped to Exp3-IX. Use the confidence parameter independent value of  and  from Theorem 12.1. You should get a figure similar to Fig. 12.2. Compare the new and the old figures and summarise your findings, including the outcome of the results of Exercise 12.5.
12.7 (Expected regret of Exp3-IX) In this exercise, you will complete the steps explained in Note 2 to prove a bound on the expected regret of Exp3-IX. (a) Find a choice of  and universal constant C > 0 such that
Rn  C kn log(k) . (b) What happens as  grows? Write a bound on the expected regret of Exp3-IX
in terms of  and k and n.

12.5 Exercises

175

Regret

-400 -500 -600 -700 -800
 Figure 12.2 Box and whisker plot of the regret of Exp3-IX for the same setting as those used to produce Fig. 11.4. For details of the experimental settings, see the text of Exercise 11.6.

0.28 0.285 0.29 0.295
0.3

Part IV
Lower Bounds for Bandits with Finitely Many Arms

177
Until now, we have indulged ourselves by presenting algorithms and upper bounds on their regret. As satisfying as this is, the real truth of a problem is usually to be found in the lower bounds. There are several reasons for this:
1 An upper bound does not tell you much about what you could be missing out on. The only way to demonstrate that your algorithm really is (close to) optimal is to prove a lower bound showing that no algorithm can do better.
2 The second reason is that lower bounds are often more informative in the sense that it usually turns out to be easier to get the lower bound right than the upper bound. History shows a list of algorithms with steadily improving guarantees until eventually someone hits upon the idea for which the upper bound matches some known lower bound.
3 Finally, thinking about lower bounds forces you to understand what is hard about the problem. This is so useful that the best place to start when attacking a new problem is usually to try and prove lower bounds. Too often we have not heeded our own advice and started trying to design an algorithm, only to discover later that had we tackled the lower bound first, then the right algorithm would have fallen in our laps with almost no effort at all.
So what is the form of a typical lower bound? In the chapters that follow, we will see roughly two flavours. The first is the worst-case lower bound, which corresponds to a claim of the form
`For any policy you give me, I will give you an instance of a bandit problem  on which the regret is at least L' .
Results of this kind have an adversarial flavour, which makes them suitable for understanding the robustness of a policy. The second type is a lower bound on the regret of an algorithm for specific instances. These bounds have a different form that usually reads like the following:
`If you give me a reasonable policy, then its regret on any instance  is at least L()' .
The statement only holds for some policies ­ the `reasonable' ones, whatever that means. But the guarantee is also more refined because bound controls the regret for these policies on every instance by a function that depends on this instance. This kind of bound will allow us to show that the instance-dependent bounds for stochastic bandits of O( i:i>0 i + log(n)/i) are not improvable. The inclusion of the word `reasonable' is unfortunately necessary. For every bandit instance  there is a policy that just chooses the optimal action in . Such policies are not reasonable because they have linear regret for bandits with a different optimal arm. There are a number of ways to define `reasonable' in a way that is simultaneously rigorous and, well, reasonable.
The contents of this part is roughly as follows. First we introduce the definition of worst-case regret and discuss the line of attack for proving lower bounds (Chapter 13). The next chapter takes us on a brief excursion into information theory, where we explain the necessary mathematical tools (Chapter 14). Readers

178
familiar with information theory could skim this chapter. The final three chapters are devoted to applying information theory to prove lower bounds on the regret for both stochastic and adversarial bandits.

13 Lower Bounds: Basic Ideas

The worst-case regret of a policy  on a set of stochastic bandit environments E is

Rn(, E) = sup Rn(, ) .
E

Let  be the set of all policies. The minimax regret is

Rn (E)

=

inf


Rn(,

E

)

=

inf


sup
E

Rn(,

)

.

A policy is called minimax optimal for E if Rn(, E) = Rn (E). The value Rn (E) is of interest by itself. A small value of Rn (E) indicates that the underlying bandit problem is less challenging in the worst-case sense. A core activity in bandit theory is to understand what makes Rn (E) large or small, often focusing on its behaviour as a function of the number of rounds n.

Minimax optimality is not a property of a policy alone. It is a property of a policy together with a set of environments and a horizon.

Finding a minimax policy is generally too computationally expensive to be practical. For this reason, we almost always settle for a policy that is nearly minimax optimal.
One of the main results of this part is a proof of the following theorem, which together with Theorem 9.1 shows that Algorithm 7 from Chapter 9 is minimax optimal up to constant factors for 1-subgaussian bandits with suboptimality gaps in [0, 1].

Theorem 13.1. Let Ek be the set of k-armed Gaussian bandits with unit variance

and means µ  [0, all k > 1 and n 

1]k. Then there k, it holds that

exists a Rn (E k)

universal  c kn.

constant

c

>

0

such

that

for

We will prove this theorem in Chapter 15, but first we give an informal justification.

13.1 Main Ideas Underlying Minimax Lower Bounds

180

13.1

Main Ideas Underlying Minimax Lower Bounds

Let X1, . . . , Xn be a sequence of independent Gaussian random variables with

unknown mean µ and known variance 1. Assume you are told that µ takes on

one of two values: µ = 0 or µ =  for some known  > 0. Your task is to guess

the

value

of

µ

based

on

your

observation

of

X1, . . . , Xn.

Let

µ^

=

1 n

n i=1

Xi

be

the sample mean, which is Gaussian with mean µ and variance 1/n. While it is

not immediately obvious how easy this task is, intuitively we expect the optimal

decision is to predict that µ = 0 if µ^ is closer to 0 than to , and otherwise to

predict µ = . For large n we expect our prediction will probably be correct.

Supposing that µ = 0 (the other case is symmetric), then the prediction will be

wrong only if µ^  /2. Using the fact that µ^ is Gaussian with mean µ = 0 and

variance 1/n, combined with known bounds on the Gaussian tail probabilities

(see Eq. (13.4)), leads to



1

n2 + n2 + 16

8 

exp

-

n2 8

 n2 +

P

µ^



 2

1 n2 + 32/

8 

exp

-

n2 8

.

(13.1)

The upper and lower bounds only differ in the constant in the square root of the denominator. One might believe that the decision procedure could be improved, but the symmetry of the problem makes this seem improbable. The formula exhibits the expected behaviour, which is that once n is large relative to 8/2, then the probability that this procedure fails drops exponentially with further increases in n. But the lower bound also shows that if n is small relative to 8/2, then the procedure fails with constant probability.
The problem described is called hypothesis testing, and the ideas underlying the argument above are core to many impossibility results in statistics. The next task is to reduce our bandit problem to hypothesis testing. The high-level idea is to select two bandit problem instances in such a way that the following two conditions hold simultaenously:

1 Competition: An action, or, more generally, a sequence of actions that is good for one bandit is not good for the other.
2 Similarity: The instances are `close' enough that the policy interacting with either of the two instances cannot statistically identify the true bandit with reasonable statistical accuracy.

The two requirements are clearly conflicting. The first makes us want to choose instances with means µ, µ  [0, 1]k that are far from each other, while the second
requirement makes us want to choose them to be close to each other. The lower
bound will follow by optimising this trade-off. Let us start to make things concrete by choosing bandits  = (Pi)ki=1 and

13.1 Main Ideas Underlying Minimax Lower Bounds

181

 = (Pi )ik=1, where Pi = N (µi, 1) and Pi = N (µi, 1) are Gaussian and µ, µ  [0, 1]k. We will also assume that n is larger than k by some suitably
large constant factor. In order to prove a lower bound, it suffices to show that for
every strategy , there exists a choice of µ and µ such that 
max {Rn(, ), Rn(,  )}  c kn ,

where c > 0 is a universal constant. Let   (0, 1/2] be a constant to be tuned subsequently and choose µ = (, 0, 0, . . . , 0), which means that the first arm is optimal in instance  and

Rn(, ) = (n - E[T1(n)]) ,

(13.2)

where the expectation is taken with respect to the induced measure on the sequence of outcomes when  interacts with . Now we need to choose µ to satisfy the two requirements above. Since we want  and  to be hard to distinguish and yet have different optimal actions, we should make µ as close to µ except in a coordinate where  expects to explore the least. To this end, let

i = argminj>1 E[Tj(n)]

be the suboptimal arm in  that  expects to play least often. From n = E[T1(n)] + j>1 E[Tj(n)]  (k - 1)E[Ti(n)] we see that

E[Ti(n)]



k

n -

1

must hold. Then, define µ  Rk by

µj =

µj , 2 ,

if j = i ; otherwise .

The regret in this bandit is

Rn(,  ) = E [T1(n)] + 2E [Tj(n)]  E [T1(n)] ,
j/1,i

(13.3)

where E [·] is the expectation operator on the sequence of outcomes when  interacts with  . So now we have the following situation: the strategy  interacts with either  or  , and when interacting with , it expects to play arm i at most n/(k - 1) times. But the two instances only differ when playing arm i. The time has come to tune . Because the strategy expects to play arm i only about n/(k - 1) times, taking inspiration from the previous discussion on distinguishing samples from Gaussian distributions with different means, we will choose

=

1 E[Ti(n)]



k

- n

1

.

If we are prepared to ignore the fact that Ti(n) is a random variable and take for granted the claims in the first part of the chapter, then with this choice of ,

13.2 Notes

182

the strategy cannot distinguish between instances  and  , and in particular we expect that E[T1(n)]  E [T1(n)]. If E[T1(n)] < n/2, then by Eq. (13.2) we have

Rn(, )



n 2

k

- n

1

=

1 2

n(k - 1) .

On the other hand, if E[T1(n)]  n/2, then

Rn(, 

)



E

[T1(n)]



E[Ti(n)]



1 2

n(k - 1) ,

which completes our heuristic argument that there exists a universal constant

c > 0 such that

 Rn (Ek)  c nk .

We have been sloppy in many places. The claims in the first part of the chapter have not been proven yet, and Ti(n) is a random variable. Before we can present the rigourous argument, we need a chapter to introduce some ideas from information theory. Readers already familiar with these concepts can skip to Chapter 15 for the proof of Theorem 13.1.

13.2

Notes
1 The worst-case regret has a game-theoretic interpretation. Imagine a game between a protagonist and an antagonist that works as follows: for k > 1 and n  k the protagonist proposes a bandit policy . The antagonist looks at the policy and chooses a bandit  from the class of environments considered. The utility for the antagonist is the expected regret, and for the protagonist it is the negation of the expected regret, which makes this a zero-sum game. Both players aim to maximise their pay-offs. The game is completely described by n and E. One characteristic value in a game is its minimax value. As described above, this is a sequential game (the protagonist moves first, then the antagonist). The minimax value of this game from the perspective of the antagonist is exactly Rn (E), while for the protagonist, it is sup inf (-Rn(, )) = -Rn (E).
2 We mentioned that finding the minimax optimal policy is usually computationally infeasible. In fact it is not clear we should even try. In classical statistics, it often turns out that minimising the worst case leads to a flat risk profile. In the language of bandits, this would mean that the regret is the same for every bandit (where possible). What we usually want in practice is to have low regret against `easy' bandits and larger regret against `hard' bandits. The analysis in Part II suggests that easy bandits are those where the suboptimality gaps are large or very small. There is evidence to suggest that the exact minimax optimal strategy may not exploit these easy instances, so in practice one might prefer to find a policy that is nearly minimax optimal and has much smaller regret on easy bandits. We will tackle questions of this nature in Chapter 16.

13.3 Bibliographic Remarks

183

3 The regret on a class of bandits E is a multi-objective criterion. Some policies will be good for some instances and bad on others, and there are clear tradeoffs. One way to analyse the performance in a multi-objective setting is called Pareto optimality. A policy is Pareto optimal if there does not exist another policy that is a strict improvement ­ more precisely, if there does not exist a  such that Rn( , )  Rn(, ) for all   E and Rn( , ) < Rn(, ) for at least one instance   E.
4 When we say a policy is minimax optimal up to constant factors for finite-armed 1-subgaussian bandits with suboptimality gaps in [0, 1], we mean there exists a C > 0 such that

Rn(, Ek) Rn (E k)



C

for

all

k

and

n,

where Ek is the set of k-armed 1-subgaussian bandits with suboptimality gaps

in [0, 1]. We often say a policy is minimax optimal up to logarithmic factors,

by which we mean that

Rn(, Ek) Rn (E k)



C(n, k)

for

all

k

and

n,

where C(n, k) is logarithmic in n and k. We hope the reader will forgive us for not always specifying in the text exactly what is meant and promise that statements of theorems will always be precise.

13.3

Bibliographic Remarks

The bound on Gaussian tails used in Eq. (13.1) is derived from §7.1.13 of the reference book by Abramowitz and Stegun [1964], which bounds

exp(-x2) 


exp(-t2)dt 

exp(-x2)

for all x  0 .

x + x2 + 2 x

x + x2 + 4/

(13.4)

13.4

Exercises
13.1 (Minimax risk for hypothesis testing) Let Pµ = N (µ, 1) be the Gaussian measure on (R, B(R)) with mean µ  {0, } and unit variance. Let X : R  R be the identity random variable (X() = ). For decision rule d : R  {0, }, define the risk
R(d) = max Pµ(d(X) = µ) ,
µ{0,}
Prove that R(d) is minimised by d(x) = argminµ~{0,µ} |X - µ~| . 13.2 (Pareto optimal policies) Let k > 1 and E = ENk (1) be the set of Gaussian bandits with unit variance. Find a Pareto optimal policy for this class.

13.4 Exercises

184

Hint Think about simple policies (not necessarily good ones) and use the definition.

14 Foundations of Information Theory ()

To make the arguments in the previous chapter rigourous and generalisable to other settings, we need some tools from information theory and statistics. The most important of these is the relative entropy, also known as the Kullback­ Leibler divergence named for Solomon Kullback and Richard Leibler (KL divergence, for short).

14.1

Entropy and Optimal Coding
Alice wants to communicate with Bob. She wants to tell Bob the outcome of a sequence n of independent random variables sampled from known distribution Q. Alice and Bob agree to communicate using a binary code that is fixed in advance in such a way that the expected message length is minimised. The entropy of Q is the expected number of bits necessary per random variable using the optimal code as n tends to infinity. The relative entropy between distributions P and Q is the price in terms of expected message length that Alice and Bob have to pay if they believe the random variables are sampled from Q when in fact they are sampled from P .
Let P be a measure on [N ] with -algebra 2[N] and X : [N ]  [N ] be the identity random variable, X() = . Alice observes a realisation of X and wants to communicate the result to Bob using a binary code that they agree upon in advance. For example, when N = 4, they might agree on the following code: 1  00, 2  01, 3  10, 4  11. Then if Alice observes a 3, she sends Bob a message containing 10. For our purposes, a code is a function c : [N ]  {0, 1}, where {0, 1} is the set of finite sequences of zeros and ones.
Of course c must be injective so that no two numbers (or symbols) have the same code. We also require that c be prefix free, which means that no code is a prefix of any other. This is justified by supposing that Alice would like to tell Bob about multiple samples. Then Bob needs to know where the message for one symbol starts and ends.
Using a prefix code is not the only way to enforce unique decodability, but all uniquely decodable codes have equivalent prefix codes (see Note 1).

14.1 Entropy and Optimal Coding

186

The easiest choice is to use log2(N ) bits no matter the value of X. This simple code is sometimes effective, but is not entirely satisfactory if X is far from uniform. To understand why, suppose that N is extremely large and P (X = 1) = 0.99, and the remaining probability mass is uniform over [N ] \ {1}. Then it seems preferable to have a short code for one and slightly longer codes for the alternatives. With this in mind, a natural objective is to find a code that minimises the expected code length. That is,

N
c = argminc pi (c(i)) ,
i=1

(14.1)

111 L 10101 B 011000 E 010 D 01101 V 1100000 T 1101 C 00001 K 11000011 A 1011 U 00000 X 110000100 O 1001 F 110011 J 1100001011 I 1000 M 110010 Q 11000010101 N 0111 W 110001 Z 11000010100 S 0011 Y 101001 H 0010 P 101000 R 0001 G 011001
Figure 14.1 A Huffman code for the English alphabet, including space.

where the argmin is taken over valid codes and (·) is a function that returns the length of a code. The optimisation problem in (14.1) can be solved using Huffman coding, and the optimal value satisfies

N
H2(P )  pi (c(i))  H2(P ) + 1 ,
i=1

(14.2)

where H2(P ) is the entropy of P ,

H2(P ) =

pi log2

i[N ]:pi>0

1 pi

.

When pi = 1/N is uniform, the naive idea of using a code of uniform length is recovered, but for non-uniform distributions, the code adapts to assign shorter codes to symbols with larger probability. It is worth pointing out that the sum is only over outcomes that occur with non-zero probability, which is motivated by observing that limx0+ x log(1/x) = 0 or by thinking of the entropy as an expectation of the log probability with respect to P , and expectations should not change when the value of the random variable is perturbed on a measure zero set.
It turns out that H2(P ) is not just an approximation on the expected length of the Huffman code, but is itself a fundamental quantity. Imagine that Alice wants to transmit a long string of symbols sampled from P . She could use a Huffman code to send Bob each symbol one at a time, but this introduces rounding errors that accumulate as the message length grows. There is another scheme called arithmetic coding for which the average number of bits per symbol approaches H2(P ) and the source coding theorem says that this is unimprovable.
The definition of entropy using base 2 makes sense from the perspective of sending binary message. Mathematically, however, it is more convenient to define

14.2 Relative Entropy

187

the entropy using the natural logarithm:

H(P ) =

pi log

i[N ]:pi>0

1 pi

.

(14.3)

This is nothing more than a scaling of the H2. Measuring information using base 2 logarithms has a unit of bits, and for the natural logarithm the unit is nats. By slightly abusing terminology, we will also call H(P ) the entropy of P .

14.2

Relative Entropy

Suppose that Alice and Bob agree to use a code that is optimal when X is sampled from distribution Q. Unbeknownst to them, however, X is actually sampled from distribution P . The relative entropy between P and Q measures how much longer the messages are expected to be using the optimal code for Q than what would be obtained using the optimal code for P . Letting pi = P (X = i) and qi = Q(X = i), assuming Shannon coding, working out the math while dropping · leads to the definition of relative entropy as

D(P, Q) =

pi log

i[N ]:pi>0

1 qi

-

pi log

i[N ]:pi>0

1 pi

=

pi log

i[N ]:pi>0

pi qi

(14.4)

From the coding interpretation, one conjectures that D(P, Q)  0. Indeed, this is easy to verify using Jensen's inequality. Still poking around the definition, what happens when qi = 0 and pi = 0? This means that symbol i is superfluous and the value of D(P, Q) should not be impacted by introducing superfluous symbols. And again, it is not by the definition of the expectations. We also see that the sufficient and necessary condition for D(P, Q) <  is that for each i with qi = 0, we also have pi = 0. The condition we discovered is equivalent to saying that P is absolutely continuous with respect to Q. Note that absolute continuity only implies a finite relative entropy when X takes on finitely many values (Exercise 14.2).
This brings us back to defining relative entropy between probability measures P and Q on arbitrary measurable spaces (, F). When the support of P is uncountable, defining the entropy via communication is hard because infinitely many symbols are needed to describe some outcomes. This seems to be a fundamental difficulty. Luckily, the impasse gets resolved automatically if we only consider relative entropy. While we cannot communicate the outcome, for any finite discretisation of the possible outcomes, the discretised values can be communicated finitely, and all our definitions will work. Formally, a discretisation to [N ] is specified by a F /2[N]-measurable map X :   [N ]. Then the entropy of P relative Q can be defined as

D(P, Q) = sup sup D(PX , QX ) ,
N N+ X

(14.5)

14.2 Relative Entropy

188

where PX is the push-forward of P on [N ] defined by PX (A) = P (X  A). The inner supremum is over all F/2N -measurable maps. Informally we take all possible
discretisations X (with no limit on the `fineness' of the discretisation) and define D(P, Q) as the excess information when expecting to see X with X  QX , while in reality X  PX . As we shall see soon, this is indeed a reasonable definition.

Theorem 14.1. Let (, F) be a measurable space, and let P and Q be measures

on this space. Then,

  log D(P, Q) =  ,

dP dQ

()

dP () ,

if P Q ; otherwise .

Note that the relative entropy between P and Q can still be infinite even when

P Q. Note also that in the case of discrete measures, the above expression

reduces to (14.4). For calculating relative entropies densities one often uses

densities: If  is a common dominating -finite measure for P and Q (that is,

P the

 and Q chain rule

 both hold), then letting

gives

dP dQ dQ d

=

dP d

,

which

lets

p=

dP d

and

us write

q

=

dQ d

,

if

also

P

Q,

D(P, Q) =

p log

p q

d .

(14.6)

This is probably the best-known expression for relative entropy and is often used as a definition. Note that for probability measures, a common dominating -finite measure can always be bound. For example,  = P + Q always dominates both P and Q.
Relative entropy is a kind of `distance' measure between distributions P and Q. In particular, D(P, Q) = 0 whenever P = Q, and otherwise D(P, Q) > 0. However, strictly speaking, the relative entropy is not a distance because it satisfies neither the triangle inequality nor is it symmetric. Nevertheless, it serves the same purpose.
The relative entropy between many standard distributions is often quite easy to compute. For example, the relative entropy between two Gaussians with means µ1, µ2  R and common variance 2 is

D(N (µ1, 2), N (µ2, 2))

=

(µ1 - µ2)2 22

.

The dependence on the difference in means and the variance is consistent with our intuition. If µ1 is close to µ2, then the `difference' between the distributions should be small, but if the variance is very small, then there is little overlap, and the difference is large. The relative entropy between two Bernoulli distributions with means p, q  [0, 1] is

D(B(p), B(q)) = p log

p q

+ (1 - p) log

1-p 1-q

,

where 0 log(·) = 0. Due to its frequent appearance at various places, D(B(p), B(q))

14.2 Relative Entropy

189

gets the honour of being abbreviated to d(p, q), which we have met before in Definition 10.1.
We are nearing the end of our whirlwind tour of relative entropy. It remains to state the key lemma that connects the relative entropy to the hardness of hypothesis testing.

Theorem 14.2 (Bretagnolle­Huber inequality). Let P and Q be probability measures on the same measurable space (, F), and let A  F be an arbitrary event. Then,

P (A)

+ Q(Ac)



1 2

exp (- D(P, Q))

,

where Ac =  \ A is the complement of A.

(14.7)

The proof may be found at the end of the chapter, but first some interpretation and a simple application. Suppose that D(P, Q) is small; then P is close to Q in some sense. Since P is a probability measure, we have P (A) + P (Ac) = 1. If Q is close to P , then we might expect that P (A) + Q(Ac) should be large. The purpose of the theorem is to quantify just how large. Note that if P is not absolutely continuous with respect to Q, then D(P, Q) = , and the result is vacuous. Also note that the result is symmetric. We could replace D(P, Q) with D(Q, P ), which sometimes leads to a stronger result because the relative entropy is not symmetric.
Returning to the hypothesis-testing problem described in the previous chapter, let X be normally distributed with unknown mean µ  {0, } and variance 2 > 0. We want to bound the quality of a rule for deciding what is the real mean from a single observation. The decision rule is characterised by a measurable set A  R on which the predictor guesses µ =  (it predicts µ = 0 on the complement of A). Let P = N (0, 2) and Q = N (, 2). Then the probability of an error under P is P (A), and the probability of error under Q is Q(Ac). The reader surely knows what to do next. By Theorem 14.2, we have

P (A)

+ Q(Ac)



1 2

exp (- D(P, Q))

=

1 2

exp

-

2 22

.

If we assume that the signal-to-noise ratio is small, 2/2  1, then

P (A)

+

Q(Ac)



1 2

exp

-

1 2



3 10

,

which implies max {P (A), Q(Ac)}  3/20. This means that no matter how we chose our decision rule, we simply do not have enough data to make a decision for which the probability of error on either P or Q is smaller than 3/20.

Proof of Theorem 14.2 For reals a, b, we abbreviate max {a, b} = a  b and min {a, b} = a  b. The result is trivial if D(P, Q) = . On the other hand, by Theorem 14.1, D(P, Q) <  implies that P Q. Let  = P + Q. Then P, Q , which by Theorem 2.13 ensures the existence of the Radon­Nikodym derivatives

14.3 Notes

190

p=

dP d

and q =

dQ d

.

By

Eq.

(14.6),

D(P,

Q)

=

p log

p q

d. For brevity, when

writing integrals with respect to , in this proof, we will drop d. Thus, we will

write, for example, p log(p/q) for the above integral.

Instead of (14.7), we prove the stronger result that

p



q



1 2

exp(- D(P, Q)) .

(14.8)

This indeed is sufficient since p  q = A p  q + Ac p  q  A p + Ac q = P (A) + Q(Ac). We start with an inequality attributed to French mathematician Lucien Le Cam, which lower-bounds the left-hand side of Eq. (14.8). The inequality states that

p



q



1 2

pq

2
.

(14.9)

Starting from the right-hand side above, using pq = (p  q)(p  q) and Cauchy­ Schwarz we get

pq

2
=

2
(p  q)(p  q) 

pq

pq .

Now, using p  q + p  q = p + q, the proof is finished by substituting p  q = 2 - p  q  2 and dividing both sides by two. It remains to lower-bound
the right-hand side of (14.9). For this, we use Jensen's inequality. First, we write (·)2 as exp(2 log(·)) and then move the log inside the integral:

pq

2
= exp

2 log

pq

= exp 2 log p
p>0

q p

 exp

2

p
p>0

1 2

log

q p

= exp

-

p log

pq>0

p q

= exp -

p log

p q

= exp (- D(P, Q)) .

In the fourth and the last step, we used that since P Q, q = 0 implies p = 0, and so p > 0 implies q > 0, and eventually pq > 0. The result is completed by chaining the inequalities.

14.3

Notes

1 A code c : N+  {0, 1} is uniquely decodable if i1, . . . , in  c(i1) · · · c(in) is injective, where on the right-hand side the codes are simply concatenated.
Kraft's inequality states that for any uniquely decodable code c,


2- (c(i))  1 .
i=1

(14.10)

14.3 Notes

191

Furthermore, for any ( n)n=1 satisfying

 i=1

2-

 1, there exists a prefix

code c : N+  {0, 1} such that (c(i)) = i. The second part justifies our

restriction to prefix codes rather than uniquely decodable codes in the definition

of the entropy.

2 The supremum in the definition given in Eq. (14.5) may often be taken over

a smaller set. Precisely, let (X , G) be a measurable space and suppose that

G = (F) where F is a field. Note that a field is defined by the same axioms

as a -algebra except that being closed under countable unions is replaced by

the condition that it be closed under finite unions. Then, for measures P and

Q on (X , G), it holds that

D(P, Q) = sup D(Pf , Qf ) ,
f

where the supremum is over F /2[n]-measurable functions. This result is known as Dobrushin's theorem.
3 How tight is Theorem 14.2? We remarked already that D(P, Q) = 0 if and only if P = Q. But in this case, Theorem 14.2 only gives

1

=

P (A)

+

Q(Ac)



1 2

exp (- D(P, Q))

=

1 2

,

which does not seem so strong. From where does the weakness arise? The answer is in Eq. (14.9), which can be refined by

pq

2


pq

pq = pq 2- pq .

By solving the quadratic inequality, we have P (A) + Q(Ac)  p  q  1 - 1 -

pq 2

 1 - 1 - exp (- D(P, Q)) ,

(14.11)

which gives a modest improvement on Theorem 14.2 that becomes more pronounced when D(P, Q) is close to zero, as demonstrated by Fig. 14.2. This stronger bound might be useful for fractionally improving constant factors in lower bounds, but we do not know of any application for which it is really crucial, and the more complicated form makes it cumbersome to use. Part of the reason for this is that the situation where D(P, Q) is small is better dealt with using a different inequality, as explained in the next note.
4 Another inequality from information theory is Pinsker's inequality, which states for measures P and Q on the same probability space (, F) that

(P, Q) = sup P (A) - Q(A) 
AF

1 2

D(P,

Q)

.

(14.12)

The quantity on the left-hand side is called the total variation distance

14.3 Notes

192

1

x/2 

1- 1-x

1 - log(1/x)/2

0.5

0

-0.5

0

1

x

Figure 14.2 Tightening the inequality of Le Cam

between P and Q, which is a distance on the space of probability measures on a probability space. From this we can derive for any measurable A  F that

P (A) + Q(Ac)  1 -

1 2

D(P,

Q)

=

1

-

1 2

log

1 exp(- D(P, Q))

.

(14.13)

Examining Fig. 14.2 shows that this is an improvement on Eq. (14.11) when D(P, Q) is small. However, we also see that in the opposite case, when D(P, Q) is large, Eq. (14.13) is worse than Eq. (14.11), or the inequality in Theorem 14.2. 5 We saw the total variation distance in Eq. (14.12). There are two other `distances' that are occasionally useful. These are the Hellinger distance and the -squared distance, which, using the notation in the proof of Theorem 14.2, are defined by

h(P, Q) =

(p - q)2 = 2 1 - pq

(14.14)

2(P, Q) =

(p - q)2 q

=

p2 q

-1.

(14.15)

The Hellinger distance is bounded and exists for all probability measures P and Q. A necessary condition for the 2-distance to exist is that P Q. Like
the total variation distance, the Hellinger distance is actually a distance (it is symmetric and satisfies triangle inequality), but the 2-`distance' is not. It is
possible to show (Tsybakov [2008], chapter 2) that

(P, Q)2  h(P, Q)2  D(P, Q)  2(P, Q) .

(14.16)

All the inequalities are tight for some choices of P and Q, but the examples

14.4 Bibliographic Remarks

193

do not chain together, as evidenced by Pinsker's inequality, which shows that (P, Q)2  D(P, Q)/2 (which is also tight for some P and Q). 6 The entropy for distribution P was defined as H(P ) in Eq. (14.3). If X is a random variable, then H(X) is defined to be the entropy of the law of X. This is a convenient notation because it allows one to write H(f (X)) and H(XY ) and similar expressions.

14.4

Bibliographic Remarks
There are many references for information theory. Most well known (and comprehensive) is the book by Cover and Thomas [2012]. Another famous book is the elementary and enjoyable introduction by MacKay [2003]. The approach we have taken for defining and understanding the relative entropy is inspired by an excellent shorter book by Gray [2011]. Theorem 14.1 connects our definition of relative entropies to densities (the `classic definition'). It can be found in §5.2 of the aforementioned book. Dobrushin's theorem is due to him [Dobrushin, 1959]. An alternative source is lemma 5.2.2 in the book of Gray [2011]. Theorem 14.2 is due to Bretagnolle and Huber [1979]. We also recommend the book by Tsybakov [2008] as a good source for learning about information theoretic lower bounds in statistical settings.

14.5

Exercises

14.1 Let P be a probability distribution on N+ and pi = P ({i}). Show that for any prefix code c : N+  {0, 1}, it holds that

pi (c(i))  H2(P ) .
i=1
Hint Use Kraft's inequality from Note 1.
14.2 Find probability measures P and Q on N+ with P Q and D(P, Q) = .

14.3 Prove the inequality in Eq. (14.10) for prefix free codes c.

Hint Consider an infinite sequence of independent Bernoulli random variables (Xn) n=1 where Xn  B(1/2). Viewing X as an infinite binary string, what is the probability that X has a prefix that is a code for some symbol?
14.4 Let (, F) be a measurable space, and let P, Q : F  [0, 1] be probability measures. Let a < b and X :   [a, b] be a F-measurable random variable. Prove that

X()dP () - X()dQ()  (b - a)(P, Q) .





14.5 Exercises

194

14.5 (Entropy inequalities) Prove that each of the inequalities in Eq. (14.16) is tight.

14.6 (Counting measure absolute continuity and derivatives) Let  be
a countable set and p :   [0, 1] be a distribution on  so that  p() = 1. Let P be the measure associated with p, which means that P (A) = A p(). Recall that the counting measure µ is the measure on (, 2) given by µ(A) = |A|
if A is finite and µ(A) =  otherwise.

(a) Show that P is absolutely continuous with respect to µ. (b) Show that the Radon­Nykodim dP/dµ exists and that dP/dµ() = p().

14.7 (Relative entropy for Gaussian distributions) For each i  {1, 2}, let µi  R, i2 > 0 and Pi = N (µi, i2). Show that

D(P1, P2)

=

1 2

log

22 12

+

12 22

-1

+

(µ1 - µ2)2 222

.

14.8 Let  be the Lebesgue measure on (R, B(R)). Find

(a) a probability measure (R, B(R)) that is not absolutely continuous with respect to ; and
(b) a probability measure P on (R, B(R)) that is absolutely continuous to  with D(P, Q) =  where Q = N (0, 1) is the standard Gaussian measure.

14.9 (Data processing inequality) Let P and Q be measures on (, F), and let G be a sub--algebra of F and PG and QG be the restrictions of P and Q to (, G). Show that D(PG, QG)  D(P, Q).
14.10 Let (, F) be a measurable space and P, Q : B(R) ×   [0, 1] be a pair of probability kernels from (, F) to (R, B(R)). Prove that

V = {   : D(P (· | ), Q(· | )) = }  F .

Hint Apply Dobrushin's theorem to the field of finite unions of rational-valued intervals in R.

14.11 (Chain rule) Let P and Q be measures on (Rn, B(Rn)), and for t  [n], let Xt(x) = xt be the coordinate project from Rn  R. Then let Pt and Qt be regular versions of Xt given X1, . . . , Xt-1 under P and Q, respectively. Show that

n
D(P, Q) = EP [D(Pt(· | X1, . . . , Xt-1), Qt(· | X1, . . . , Xt-1))] .
t=1

(14.17)

Hint This is a rather technical exercise. You will likely need to apply a
monotone class argument [Kallenberg, 2002, theorem 1.1]. For the definition
of a regular version, see [Kallenberg, 2002, theorem 5.3] or Theorem 3.11. Briefly, Pt is a probability kernel from (Rt-1, B(Rt-1)) to (R, B(R)) such that

14.5 Exercises

195

Pt(A | x1, . . . , xt-1) = P (Xt  A | X1, . . . , Xt-1) with P -probability one for all A  B(R).

14.12 (Chain rule (cont.)) Let P and Q be measures on (Rn, B(Rn)), and for t  [n], let Xt(x) = xt be the coordinate project from Rn  R. Then let Pt and Qt be regular versions of Xt given X1, . . . , Xt-1 under P and Q, respectively. Let  be a stopping time adapted to the filtration generated by X1, . . . , Xn with   [n] almost surely. Show that



D(P|F , Q|F ) = EP

D(Pt(· | X1, . . . , Xt-1), Qt(· | X1, . . . , Xt-1)) .

t=1

15 Minimax Lower Bounds

After the short excursion into information theory, let us return to the world of k-armed stochastic bandits. In what follows, we fix the horizon n > 0 and the number of actions k > 1. This chapter has two components. The first is an exact calculation of the relative entropy between measures in the canonical bandit model for a fixed policy and different bandits. In the second component, we prove a minimax lower bound that formalises the intuitive arguments given in Chapter 13.

15.1

Relative Entropy Between Bandits

The following result will be used repeatedly. Some generalisations are provided in the exercises.

Lemma 15.1 (Divergence decomposition). Let  = (P1, . . . , Pk) be the reward distributions associated with one k-armed bandit, and let  = (P1, . . . , Pk) be the reward distributions associated with another k-armed bandit. Fix some policy  and let P = P and P = P  be the probability measures on the canonical bandit model (Section 4.6) induced by the n-round interconnection of  and 
(respectively,  and  ). Then,

k
D(P , P ) = E [Ti(n)] D(Pi, Pi ) .
i=1

(15.1)

Proof Assume that D(Pi, Pi ) <  for all i  [k]. It follows that Pi Pi . Define

=

k i=1

Pi

+

Pi

,

which

is

the

measure

defined

by

(A)

=

k i=1

(Pi(A)

+

Pi

(A))

for any measurable set A. Theorem 14.1 shows that, as long as

dP dP

< +,

D(P , P ) = E log

dP dP

.

Recalling that  is the counting measure over [k], we find that the Radon­Nikodym derivative of P with respect to the product measure ( × )n is given in Eq. (4.7) as
n
p(a1, x1, . . . , an, xn) = t(at | a1, x1, . . . , at-1, xt-1)pat (xt) .
t=1

15.2 Minimax Lower Bounds

197

The density of P is identical except that pat is replaced by pat . Then

log

dP dP

(a1, x1,

.

.

. , an,

xn)

=

n t=1

log

pat (xt) pat (xt)

,

where we used the chain rule for Radon­Nikodym derivatives and the fact that the terms involving the policy cancel. Taking expectations of both sides,

E

log

dP dP

(A1, X1, . . . , An, Xn)

n
= E
t=1

log

pAt (Xt) pAt (Xt)

,

and

E

log

pAt (Xt) pAt (Xt)

= E

E

log

pAt (Xt) pAt (Xt)

At

= E D(PAt , PAt ) ,

where in the second equality we used that under P(·|At), the distribution of Xt is dPAt = pAt d. Plugging back into the previous display,

E

log

dP dP

(A1,

X1, .

.

.,

An,

Xn)

n
= E
t=1

log

pAt (Xt) pAt (Xt)

n

k

n

= E D(PAt , PAt ) = E

I {At = i} D(PAt , PAt )

t=1

i=1

t=1

k
= E [Ti(n)] D(Pi, Pi ) .
i=1

When the right-hand side of (15.1) is infinite, by our previous calculation, it is not hard to see that the left-hand side will also be infinite.

We note in passing that the divergence decomposition holds regardless of whether the action set is discrete or not. In its more general form, the sum over the actions must be replaced by an integral with respect to an appropriate non-negative measure, which generalises the expected number of pulls of arms. For details, see Exercise 15.8.

15.2

Minimax Lower Bounds

Recall that ENk (1) is the class of Gaussian bandits with unit variance, which can be parameterised by their mean vector µ  Rk. Given µ  Rk, let µ be the Gaussian bandit for which the ith arm has reward distribution N (µi, 1).

Theorem 15.2. Let k > 1 and n  k - 1. Then, for any policy , there exists a mean vector µ  [0, 1]k such that

Rn(, µ)



1 27

(k - 1)n .

15.2 Minimax Lower Bounds

198

Figure 15.1 The idea of the minimax lower bound. Given a policy and one environment, the evil antagonist picks another environment so that the policy will suffer a large regret in at least one environment.

Since µ  ENk (1), it follows that the minimax regret for ENk (1) is lower-bounded by the right-hand side of the above display as soon as n  k - 1:

Rn (ENk (1))



1 27

(k - 1)n .

The idea of the proof is illustrated in Fig. 15.1.

Proof Fix a policy . Let   [0, 1/2] be some constant to be chosen later. As
suggested in Chapter 13, we start with a Gaussian bandit with unit variance
and mean vector µ = (, 0, 0, . . . , 0). This environment and  give rise to the distribution Pµ, on the canonical bandit model (Hn, Fn). For brevity we will use Pµ in place of Pµ,, and expectations under Pµ will be denoted by Eµ. To choose the second environment, let

i = argminj>1 Eµ[Tj(n)] .

Since

k j=1

Eµ[Tj

(n)]

=

n,

it

holds

that

Eµ[Ti(n)]



n/(k

- 1).

The

second

bandit

is also Gaussian with unit variance and means

µ = (, 0, 0, . . . , 0, 2, 0, . . . , 0) ,

where specifically µi = 2. Therefore, µj = µj except at index i and the optimal arm in µ is the first arm, while in µ arm i is optimal. We abbreviate Pµ = Pµ ,. Lemma 4.5 and a simple calculation lead to

Rn(,

µ)



Pµ(T1(n)



n/2)

n 2

and

Rn(, µ

)

>

Pµ

(T1(n)

>

n/2)

n 2

.

Then, applying the Bretagnolle­Huber inequality from the previous chapter

15.3 Notes

199

(Theorem 14.2),

Rn(, µ) + Rn(, µ

)

>

n 2

(Pµ(T1(n)



n/2) + Pµ

(T1(n)

>

n/2))



n 4

exp(- D(Pµ, Pµ

)) .

(15.2)

It remains to upper-bound D(Pµ, Pµ ). For this, we use Lemma 15.1 and the definitions of µ and µ to get

D(Pµ, Pµ

)

=

Eµ[Ti(n)] D(N (0, 1), N (2, 1))

=

Eµ[Ti(n)]

(2)2 2



2n2 k-1

.

Plugging this into the previous display, we find that

Rn(, µ) + Rn(, µ

)

n 4

exp

-

2n2 k-1

.

The result is completed by choosing  = (k - 1)/4n  1/2, where the inequality follows from the assumptions in the theorem statement. The final steps are lower bounding exp(-1/2) and using 2 max(a, b)  a + b.

We encourage readers to go through the alternative proof outlined in Exercise 15.2, which takes a slightly different path.

15.3 Notes
1 We used the Gaussian noise model because the KL divergences are so easily calculated in this case, but all that we actually used was that D(Pi, Pi ) = O((µi - µi)2) when the gap between the means  = µi - µi is small. While this is certainly not true for all distributions, it very often is. Why is that? Let {Pµ : µ  R} be some parametric family of distributions on  and assume that distribution Pµ has mean µ. Assuming the densities are twice differentiable and that everything is sufficiently nice that integrals and derivatives can be exchanged (as is almost always the case), we can use a Taylor expansion about

15.3 Notes

200

µ to show that

D(Pµ, Pµ+) 

 

D(Pµ,

Pµ+)

=0



+

1 2

2 2

D(Pµ, Pµ+)

=0

2

=

 

log


dPµ dPµ+

dPµ

=0



+

1 2

I

(µ)2

=-



 

log

dPµ+ dPµ

=0

dPµ

+

1 2

I

(µ)2

=-



 dPµ+  dPµ

dPµ +
=0

1 2

I

(µ)2

=

-

 



dPµ+ dPµ

dPµ

=0



+

1 2

I

(µ)2

=

-

 



dPµ+

+
=0

1 2

I

(µ)2

=

1 2

I

(µ)2

,

where I(µ), introduced in the second line, is called the Fisher information of the family (Pµ)µ at µ. Note that if  is a common dominating measure for (Pµ+) for  small, dPµ+ = pµ+d and we can write

I(µ) = -

2 2

log

pµ+

=0

pµd ,

which is the form that is usually given in elementary texts. The upshot of all

this is that D(Pµ, Pµ+) for  small is indeed quadratic in , with the scaling provided by I(µ), and as a result the worst-case regret is always O( nk),

provided the class of distributions considered is sufficiently rich and not too

bizarre.



2 We have now shown a lower bound that is ( nk), while many of the upper

bounds were O(log(n)). There is no contradiction because the logarithmic

bounds depended on the inverse suboptimality gaps, which may be very large.

3 Our lower bound was only proven for n  k - 1. In Exercise 15.3, we ask you to show that when n < k - 1, there exists a bandit such that

Rn



n(2k

- n - 1) 2k

>

n 2

.

4 The method used to prove Theorem 15.2 can be viewed as a generalisation and strengthening of Le Cam's method in statistics. Recall that Eq. (15.2) establishes that for any µ and µ ,

inf


sup


Rn

(,



)



n 8

exp(- D(Pµ, Pµ

)) .

To explain Le Cam's method, we need a little notation. Let X be an outcome space, P a set of measures on X and  : P  , where (, d) is a metric space.

15.4 Bibliographic Remarks

201

An estimator is a function ^ : X n  . Le Cam's method is used for proving minimax lower bounds on the expected error of the estimator, which is

inf
^

sup
P P

EX1 ,...,Xn P

n

d(^(X1, . . . , Xn), (P ))

.

(15.3)

The idea is to choose P0, P1  P to maximise d((P0), (P1)) exp(-n D(P0, P1)), on the basis that for any P0, P1  P,

Eq.

(15.3)



 8

exp (-n D(P0, P1))

,

(15.4)

where  = d((P0), (P1)). There are two differences compared to the bandit lower bound: (i) we deal with the sequential setting, and (ii) having chosen P0 we choose P1 in a way that depends on the algorithm. This provides a much needed extra boost, without which the method would be unable to capture

how the characteristics of P are reflected in the minimax risk (or regret, in our

case).

15.4

Bibliographic Remarks
The first work on lower bounds that we know of was the remarkably precise minimax analysis of two-armed Bernoulli bandits by Vogel [1960]. The Bretagnolle­ Huber inequality (Theorem 14.2) was first used for bandits by Bubeck et al. [2013b]. As mentioned in the notes, the use of this inequality for proving lower bounds is known as Le Cam's method in statistics [Le Cam, 1973]. The proof of Theorem 15.2 uses the same ideas as Gerchinovitz and Lattimore [2016], while the alternative proof in Exercise 15.2 is essentially due to Auer et al. [1995], who analysed the more difficult case where the rewards are Bernoulli (see Exercise 15.4). Yu [1997] describes some alternatives to Le Cam's method for the passive, statistical setting. These alternatives can be (and often are) adapted to the sequential setting.

15.5

Exercises

15.1 (Le Cam's method) Establish the claim in Eq. (15.4).

15.2 (Alternative proof of Theorem 15.2) Here you will prove Theorem 15.2
with a different method. Let c > 0 and  = 2c k/n, and for each i  {0, 1, . . . , k}, let µ(i)  Rk satisfy µj(i) = I {i = j} . Further abbreviate the notation in the proof of Theorem 15.2 by letting Ei[·] = Eµ(i) [·].

(a) Use Pinsker's inequality (Eq. 14.12) and Lemma 15.1 and the result of Exercise 14.4 to show

Ei[Ti(n)]  E0[Ti(n)] + n

1 4

2E0[Ti(n)]

=

E0[Ti(n)]

+

c

nkE0[Ti(n)] .

15.5 Exercises

202

(b) Using the previous part, Jensen's inequality and the identity

k i=1

E0[Ti(n)]

=

n, show that

k

k

Ei[Ti(n)]  n + c

i=1

i=1

nkE0[Ti(n)]  n + ckn .

(c) Let Ri = Rn(, Gµ(i) ). Find a choice of c > 0 for which

k

k

Ri =  (n - Ei[Ti(n)])   (nk - n - ckn)

i=1

i=1

= 2c

k n

(nk

-

n

-

ckn)



nk 8

k n

(d) Conclude that there exists an i  [k] such that

Ri



1 8

 kn

.

The method used in this exercise is borrowed from Auer et al. [2002b] and is closely related to the lower-bound technique known as Assouad's method in statistics [Yu, 1997].

15.3 (Lower bound for small horizons) Let k > 1 and n < k. Prove that
for any policy  there exists a Gaussian bandit with unit variance and means µ  [0, 1]k such that Rn(, µ)  n(2k - n - 1)/(2k) > n/2.

15.4 (Lower bounds for Bernoulli bandits) Recall from Table 4.1 that

EBk is the set of k-armed Bernoulli bandits. Show that there exists a universal

constant c > 0 such that for any 2  k  n, it holds that:



Rn (EBk)

=

inf


sup
 EBk

Rn(,

)



c

nk .

Hint Use the fact that KL divergence is upper bounded by the -squared distance (Eq. (14.16)).

15.5 In Chapter 9 we proved that if  is the MOSS policy and   ESkG(1), then





Rn(, )  C kn +

i ,

i:i >0

where C > 0 is a universal constant. Prove that the dependence on the sum cannot be eliminated.

Hint You will have to use that Ti(t) is an integer for all t.
15.6 (Lower bound for explore-then-commit) Let ETCnm be the explorethen-commit policy with inputs n and m respectively (Algorithm 1). Prove that

15.5 Exercises

203

for all m, there exists a µ  [0, 1]k such that Rn(ETCnm, µ)  c min n, n2/3k1/3 ,
where c > 0 is a universal constant.

15.7 (Stopping-time version of divergence decomposition) Consider the setting of Lemma 15.1, and let Ft = (A1, X1, . . . , At, Xt) and  be an (Ft)-measurable stopping time. Then, for any random element X that is F measurable,
k
D(PX , P X )  E [Ti( )] D(Pi, Pi ) ,
i=1
where PX and P X are the laws X under  and  respectively.

15.8 (Divergence decomposition for more general action spaces) The purpose of this exercise is to show that the divergence decomposition lemma (Lemma 15.1) continues to hold for more general action spaces (A, G). Starting from the set-up of Section 4.7, let P = P and P = P  be the measures on the canonical bandit model induced by the interconnection of  and  (respectively,  and  ).
(a) Prove that

D(P , P ) = D(Pa, Pa) dG (a) ,
A
where G is a measure on (A, G) defined by G(B) = E[ (b) Prove that

(15.5)

n t=1

I

{At



B}].

n

D(P , P ) = E

D(PAt , PAt ) .

t=1

Hint Use an appropriately adjusted form of the chain rule for relative entropy from Exercise 14.11.

16 Instance-Dependent Lower Bounds

In the last chapter, we proved a lower bound on the minimax regret for subgaussian bandits with suboptimality gaps in [0, 1]. Such bounds serve as a useful measure of the robustness of a policy, but are often excessively conservative. This chapter is devoted to understanding instance-dependent lower bounds, which try to capture the optimal performance of a policy on a specific bandit instance.
Because the regret is a multi-objective criteria, an algorithm designer might try and design algorithms that perform well on one kind of instance or another. An extreme example is the policy that chooses At = 1 for all t, which suffers zero regret when the first arm is optimal and linear regret otherwise. This is a harsh trade-off, with the price for reducing the regret from logarithmic to zero on just a few instances being linear regret on the remainder. Surprisingly, this is the nature of the game in bandits. One can assign a measure of difficulty to each instance such that policies performing overly well relative to this measure on some instances pay a steep price on others. The situation is illustrated in Fig. 16.1.

n

over-specialised

reasonable, not instance optimal

n

minisntaimncaex ooppttiimmaall

Regret

Instances
Figure 16.1 On the x-axis, the instances are ordered according to the measure of difficulty, and the y-axis shows the regret (on some scale). In the previous chapter, we proved that no policy can be entirely below the horizontal `minimax optimal' line. The results in this chapter show that if the regret of a policy is below the `instance optimal' line at any point, then it must have regret above the shaded region for other instances. For example, the `overly specified' policy.

16.1 Asymptotic Bounds

205

In finite time, the situation is a little messy, but if one pushes these ideas to the limit, then for many classes of bandits one can define a precise notion of instance-dependent optimality.

16.1

Asymptotic Bounds

We need to define exactly what is meant by a reasonable policy. If one is only concerned with asymptotics, then a rather conservative definition suffices.

Definition 16.1. A policy  is called consistent over a class of bandits E if for all   E and p > 0, it holds that

lim
n

Rn(, ) np

=

0.

The class of consistent policies over E is denoted by cons(E).

(16.1)

Theorem 7.1 shows that UCB is consistent over ESkG(1). The strategy that always chooses the first action is not consistent on any class E unless the first
arm is optimal for every   E.

Consistency is an asymptotic notion. A policy could be consistent and yet play At = 1 for all t  10100. For this reason, an assumption of consistency is insufficient to derive non-asymptotic lower bounds. In Section 16.2, we introduce a finite-time version of consistency that allows us to prove finitetime instance-dependent lower bounds.

Recall that a class E of stochastic bandits is unstructured if E = M1 × · · · × Mk with M1, . . . , Mk sets of distributions. The main theorem of this chapter is a generic lower bound that applies to any unstructured class of stochastic bandits.
After the proof, we will see some applications to specific classes. Let M be a set of distributions with finite means, and let µ : M  R be the function that maps P  M to its mean. Let µ  R and P  M have µ(P ) < µ and define

dinf (P, µ, M)

=

inf {D(P, P
P M

)

:

µ(P

)

>

µ}

.

Theorem 16.2. Let E = M1 × · · · × Mk and   cons(E) be a consistent policy over E. Then, for all  = (Pi)ki=1  E, it holds that

lim inf
n

Rn log(n)



c(, E)

=

i:i >0

i dinf (Pi, µ, Mi)

,

(16.2)

where i is the suboptimality gap of the ith arm in  and µ is the mean of the optimal arm.

Proof Let µi be the mean of the ith arm in  and di = dinf (Pi, µ, Mi). The

16.1 Asymptotic Bounds

206

result will follow from Lemma 4.5, and by showing that for any suboptimal arm

i it holds that

lim inf
n

E  [Ti (n)] log(n)



1 di

.

Fix a suboptimal arm i, and let  > 0 be arbitrary and  = (Pj)jk=1  E be a bandit with Pj = Pj for j = i and Pi  Mi be such that D(Pi, Pi )  di +  and µ(Pi ) > µ, which exists by the definition of di. Let µ  Rk be the vector of means of distributions of  . By Lemma 15.1, we have D(P, P )  E[Ti(n)](di + ),
and by Theorem 14.2, for any event A,

P(A) + P

 (Ac )



1 2

exp (- D(P, P

 ))



1 2

exp (-E[Ti(n)](di

+ ))

.

Now choose A = {Ti(n) > n/2}, and let Rn = Rn(, ) and Rn = Rn(,  ). Then,

Rn

+

Rn



n 2

(P  (A)i

+

P

 (Ac )(µi

-

µ))



n 2

min {i, µi

-

µ} (P(A)

+

P

 (Ac ))



n 4

min {i, µi

-

µ} exp (-E[Ti(n)](di

+

))

.

Rearranging and taking the limit inferior leads to

lim inf
n

E  [Ti (n)] log(n)



1 di + 

lim inf
n

log

n min{i,µi-µ}
4(Rn +Rn )
log(n)

=

1 di + 

1

-

lim sup
n

log

(Rn + Rn) log(n)

=

di

1 +



,

where the last equality follows from the definition of consistency, which says
that for any p > 0, there exists a constant Cp such that for sufficiently large n, Rn + Rn  Cpnp, which implies that

lim sup
n

log (Rn + Rn) log(n)



lim sup
n

p log(n) + log(Cp) log(n)

=

p,

which gives the result since p > 0 was arbitrary and by taking the limit as  tends to zero.

Table 16.1 provides explicit formulas for dinf (P, µ, M) for common choices of M. The calculation of these quantities are all straightforward (Exercise 16.1). The lower bound and definition of c(, E) are quite fundamental quantities in
the sense that for most classes E, there exists a policy  for which

lim
n

Rn(, ) log(n)

=

c(, E)

for all   E .

(16.3)

This justifies calling a policy asymptotically optimal on class E if Eq. (16.3)
holds. For example, UCB from Chapter 8 and KL-UCB from Chapter 10 are asymptotically optimal for ENk (1) and EBk, respectively.

16.2 Finite-Time Bounds

207

M {N (µ, 2) : µ  R}

P N (µ, 2)

{N (µ, 2) : µ  R, 2  (0, )} N (µ, 2)

{B(µ) : µ  [0, 1]}

B(µ)

{U(a, b) : a, b  R}

U(a, b)

dinf (P, µ, M)
(µ - µ)2 22

1 2

log

1

+

(µ

- µ)2 22

µ log

µ µ

+ (1 - µ) log

1-µ 1 - µ

log

1

+

2((a

+ b)/2 - b-a

µ)2

Table 16.1 Expressions for dinf for different parametric families when the mean of P is less than µ.

16.2

Finite-Time Bounds

By making a finite-time analogue of consistency, it is possible to prove a finitetime instance-dependent bound. First, a lemma that summarises what can be obtained by chaining the Bretagnolle­Huber inequality (Theorem 14.2) with the divergence decomposition lemma (Lemma 15.1).

Lemma 16.3. Let  = (Pi) and  = (Pi ) be k-armed stochastic bandits that differ only in the distribution of the reward for action i  [k]. Assume that i is
suboptimal in  and uniquely optimal in  . Let  = µi( ) - µi(). Then, for any policy ,

log E[Ti(n)] 

min{-i ( ),i ( )} 4

+ log(n) - log(Rn() + Rn( )) .

D(Pi, Pi )

(16.4)

The lemma holds for finite n and any  and can be used to derive finitetime instance-dependent lower bounds for any environment class E that is rich enough. The following result provides a finite-time instance-dependence bound for Gaussian bandits where the asymptotic notion of consistency is replaced by an assumption that the minimax regret is not too large. This assumption alone is enough to show that no policy that is remotely close to minimax optimal can be much better than UCB on any instance.

Theorem 16.4. Let   ENk be a k-armed Gaussian bandit with mean vector µ  Rk and suboptimality gaps   [0, )k. Let

E() = {  ENk : µi( )  [µi, µi + 2i]} .

Suppose C > 0 and p  (0, 1) are constants and  is a policy such that

16.3 Notes

208

Rn(,  )  Cnp for all n and   E(). Then, for any   (0, 1],

Rn(, )



2 (1 + )2

i:i >0

(1 - p) log(n) + log

i 8C

i

+
.

(16.5)

Proof Let i be suboptimal in , and choose   E() such that µj( ) = µj() for j = i and µj( ) = µi + i(1 + ). Then, by Lemma 16.3 with  = i(1 + ),

E  [Ti (n)]



2 i2(1 +

)2

=

2 2i (1 +

)2

log

n 2C np

+ log

min { - i, i} 4

(1 - p) log (n) + log

i 8C

.

Plugging this into the basic regret decomposition identity (Lemma 4.5) gives the result.

When p = 1/2, the leading term in this lower bound is approximately half that of the asymptotic bound. This effect may be real. The class of policies considered is larger than in the asymptotic lower bound, and so there is the possibility that the policy that is best tuned for a given environment achieves a smaller regret.

16.3

Notes
1 We mentioned that for most classes E there is a policy satisfying Eq. (16.3). Its form is derived from the lower bound, and by making some additional assumptions on the underlying distributions. For details, see the article by Burnetas and Katehakis [1996], which is also the original source of Theorem 16.2.
2 The analysis in this chapter only works for unstructured classes. Without this assumption a policy can potentially learn about the reward from one arm by playing other arms and this greatly reduces the regret. Lower bounds for structured bandits are more delicate and will be covered on a case-by-case basis in subsequent chapters.
3 The classes analysed in Table 16.1 are all parametric, which makes the calculation possible analytically. There has been relatively little analysis in the non-parametric case, but we know of three exceptions for which we simply refer the reader to the appropriate source. The first is the class of distributions with bounded support: M = {P : Supp(P )  [0, 1]}, which has been analysed exactly [Honda and Takemura, 2010]. The second is the class of distributions with semi-bounded support, M = {P : Supp(P )  (-, 1]} [Honda and Takemura, 2015]. The third is the class of distributions with bounded kurtosis, M = {P : KurtXP [X]  } [Lattimore, 2017].

16.4 Bibliographic Remarks

209

16.4

Bibliographic Remarks
Asymptotic optimality via a consistency assumption first appeared in the seminal paper by Lai and Robbins [1985], which was later generalised by Burnetas and Katehakis [1996]. In terms of upper bounds, there now exist policies that are asymptotic optimal for single-parameter exponential families [Capp´e et al., 2013]. Until recently, there were no results on asymptotic optimality for multi-parameter classes of reward distributions. There has been some progress on this issue recently for the Gaussian distribution with unknown mean and variance [Cowan et al., 2018] and for the uniform distribution [Cowan and Katehakis, 2015]. There are plenty of open questions related to asymptotically optimal strategies for non-parametric classes of reward distributions. When the reward distributions are discrete and finitely supported, an asymptotically optimal policy is given by Burnetas and Katehakis [1996], though the precise constant is hard to interpret. A relatively complete solution is available for classes with bounded support [Honda and Takemura, 2010]. Already for the semi-bounded case, things are getting murky [Honda and Takemura, 2015]. One of the authors thinks that classes with bounded kurtosis are quite interesting, but here things are only understood up to constant factors [Lattimore, 2017]. An asymptotic variant of Theorem 16.4 is by Salomon et al. [2013]. Finite-time instance-dependent lower bounds have been proposed by several authors, including Kulkarni and Lugosi [2000], for two arms, and Garivier et al. [2019] and Lattimore [2018], for the general case. As noted earlier, neither ETC policies, nor elimination-based algorithms are able to achieve asymptotic optimality: as shown by Garivier et al. [2016b], these algorithms (no matter how they are tuned) must incur an additional multiplicative penalty of a factor of two on the standard Gaussian bandit problems as compared to the optimal asymptotic regret.

16.5

Exercises

16.1 (Relative entropy calculations) Verify the calculations in Table 16.1.

16.2 (Rademacher noise) Let R(µ) be the shifted Rademacher distribution, which for µ  R and X  R(µ) is characterised by P (X = µ + 1) = P (X = µ - 1) = 1/2.

(a) Show that dinf (R(µ), µ, M) =  for any µ < µ. (b) Design a policy  for bandits with shifted Rademacher rewards such that
the regret is bounded by

k
Rn(, )  3 i
i=1

for all n and   Mk .

(c) The results from parts (a) and (b) seem to contradict the heuristic analysis in Note 1 at the end of Chapter 15. Explain.

16.5 Exercises

210

16.3 (Asymptotic lower bound for exponential families) Let M = {P :   } be an exponential family with sufficient statistic equal to the identity and E = Mk and  be a consistent policy for E. Prove that the asymptotic upper
bound on the regret proven in Exercise 10.4 is tight.

16.4 (Unknown subgaussian constant) Let M = P : there exists a 2  0 such that P is 2-subgaussian .

(a) Find a distribution P such that P / M. (b) Suppose that P  M has mean µ  R. Prove that dinf (P, µ, M) = 0 for all
µ > µ.
(c) Let E = {(Pi) : Pi  M for all 1  i  k}. Prove that if k > 1, then for all consistent policies ,

lim inf
n

Rn(, ) log(n)

=



for all   E .

(d) Let f : N  [0, ) be any increasing function with limn f (n)/ log(n) = . Prove there exists a policy  such that

lim sup
n

Rn(, ) f (n)

=

0

for all   E ,

where E is as in the previous part. (e) Conclude that there exists a consistent policy for E.

16.5 (Minimax lower bound) Use Lemma 16.3 to prove Theorem 15.2, possibly with different constants.

16.6 (Refining the lower-order terms) Let k = 2, and for   EN2 let () = max{1(), 2()}. Suppose that  is a policy such that for all   EN2 with ()  1, it holds that

Rn(, )



C log(n) ()

.

(16.6)

(a) Give an example of a policy satisfying Eq. (16.6).

(b) Assume that i = 2 is suboptimal for  and that   (0, 1) be such that

E  [T2 (n)]

=

1 2()2

log().

Let



be the alternative environment where

µ1( ) = µ1() and µ2( ) = µ1() + 2(). Show that

exp(- D(P, P

 ))

=

1 

.

(c) Let A be the event that T2(n)  n/2. Show that

P  (A)



2C log(n) n()2

and

P

 (A)



1 2

-

2C log(n) n()2

.

(d) Show that

Rn(, 

)



n() 2

1 2

-

2C log(n) n()2

.

16.5 Exercises

211

(e)

Show

that



n()2 8C log(n)

and

conclude

that

Rn(, )



1 2()

log

n()2 8C log(n)

.

(f) Generalise the argument to an arbitrary number of arms.

In Exercise 7.6 you showed that there exists a bandit policy  such that for some universal constant C > 0 and for any   E[k0,b] k-armed bandit with rewards taking values in [0, b], the regret Rn(, ) of  on  after n rounds
satisfies

Rn(, )  C
i:i >0

i +

b

+

i2 i

log(n)

,

where i = i() is the action gap of action i and i2 = i2() is the variance of the reward of arm i. In particular, this is the inequality shown in

Eq. (7.14). The next exercise asks you to show that the appearance of both

b

and

i2 i

is

necessary

in

this

bound.

16.7 (Sharpness of Eq. (7.14)) Let k > 1, b > 0 and c > 0 be arbitrary. Show that there is no policy  for which either

lim sup
n

Rn(, ) log(n)



cb,

  E[k0,b]

or

lim sup
n

Rn(, ) log(n)



c
i:i >0

i2 ( ) i()

,

  E[k0,b]

would hold true.

(16.7) (16.8)

The intuition underlying this result is the following: Eq. (16.7) cannot hold because this would mean that for some policy, the regret is logarithmic with a constant independent of the gaps, while intuitively, if the variance is constant, the coefficient of the logarithmic regret must increase as the gaps get close. Similarly, Eq. (16.8) cannot hold either because we expect a logarithmic regret with a coefficient proportional to the inverse gap even as the variance gets zero, as the case of Bernoulli bandits shows. This exercise is due to Audibert et al. [2007].

16.8 (Lower bound on regret variance) Let k > 1 and E  ENk be the set of k-armed Gaussian bandits with mean rewards in [0, 1] for all arms. Suppose

16.5 Exercises

212

that  is a policy such that for all   E,

lim sup
n

Rn(, ) log(n)



i:i >0

2(1 + i

p)

.

Prove that

lim sup sup
n E

log(V[R^n(, )]) (1 - p) log(n)



1,

where R^n(, ) = nµ() -

n t=1

µAt

().

17 High-Probability Lower Bounds

The lower bounds proven in the last two chapters were for stochastic bandits.
In this chapter, we prove high probability lower bounds for both stochastic and adversarial bandits. Recall that for adversarial bandit x  [0, 1]n×k, the random
regret is

n

R^n

=

max
i[k]

t=1

xti

-

xtAt

and the (expected) regret is Rn = E[R^n]. To set expectations, remember that in Chapter 12 we proved two high-probability upper bounds on the regret of Exp3-
IX. In the first, we showed there exists a policy  such that for all adversarial bandits x  [0, 1]n×k and   (0, 1), it holds with probability at least 1 -  that

R^n = O

kn log(k) +

kn log(k)

log

1 

.

(17.1)

We also gave a version of the algorithm that depended on   (0, 1) for which with probability at least 1 - ,

R^n = O

kn log

k 

.

(17.2)

The important difference is the order of quantifiers. In the first, we have a single algorithm and a high-probability guarantee that holds simultaneously for any confidence level. The second algorithm needs the confidence level to be specified in advance. The price for using the generic algorithm appears to be
log(1/)/ log(k), which is usually quite small but not totally insignificant. We will see that both bounds are tight up to constant factors, which implies that knowing the desired confidence level in advance really does help. One reason why choosing the confidence level in advance is not ideal is that the resulting high-probability bound cannot be integrated to prove a bound in expectation. For algorithms satisfying (17.1), the expected regret can be bounded by



Rn 

P R^n  u du = O( kn log(k)) .

0

(17.3)

17.1 Stochastic Bandits

214

On the other hand, if the high-probability bound only holds for a single , as in (17.2), then it seems hard to do much better than

Rn  n + O

kn log

k 

,

which with the best choice of  leads to a bound of O( kn log(n)).

17.1

Stochastic Bandits
For simplicity, we start with the stochastic setting before explaining how to convert the arguments to the adversarial model. There is no randomness in the expected regret, so in order to derive a high-probability bound, we define the random pseudo-regret by
k
R¯n = Ti(n)i ,
i=1
which is a random variable through the pull counts Ti(n).
For all results in this section, we let Ek  ENk denote the set of k-armed Gaussian bandits with suboptimality gaps bounded by one. For µ  [0, 1]d we let µ  Ek be the Gaussian bandit with means µ.

Theorem 17.1. Let n  1 and k  2 and B > 0 and  be a policy such that for any   Ek,

Rn(, )  B (k - 1)n . Let   (0, 1). Then there exists a bandit  in Ek such that

(17.4)

P

R¯n(, )



1 4

min

n,

1 B

(k - 1)n log

1 4

 .

Proof Let   (0, 1/2] be a constant to be tuned subsequently and  = µ where the mean vector µ  Rd is defined by µ1 =  and µi = 0 for i > 1. Abbreviate Rn = Rn(, ) and P = P and E = E. Let i = argmini>1 E[Ti(n)]. Then, by
Lemma 4.5 and the assumption in Eq. (17.4),

E[Ti(n)]



Rn (k - 1)



B 

k

n -

1

.

(17.5)

Define alternative bandit  = µ where µ  Rd is equal to µ except µi = µi +2. Abbreviate P = P  and R¯n = R¯n(, ) and R¯n = R¯n(,  ). By Lemma 4.5, the

17.1 Stochastic Bandits

215

Bretagnolle­Huber inequality (Theorem 14.2) and the divergence decomposition (Lemma 15.1), we have

P

R¯n



n 2

+P

R¯n



n 2

P

Ti(n)



n 2

+P

Ti(n)

<

n 2



1 2

exp (- D(P, P

))



1 2

exp

-2B

n k-1

 2 ,

where the last line follows by choosing

 = min

1 2

,

1 2B

k

- n

1

log

1 4

.

The result follows since max{a, b}  (a + b)/2.
Corollary 17.2. Let n  1 and k  2. Then, for any policy  and   (0, 1) such that

n 

n(k - 1) log

1 4

,

there exists a bandit problem   Ek such that

(17.6)

P

R¯n(, )



1 4

min

n,

n(k - 2

1)

log

1 4

 .

(17.7)

Proof We prove the result by contradiction. Assume that the conclusion does
not hold for  and let   (0, 1) satisfy (17.6). Then, for any bandit problem   Ek, the expected regret of  is bounded by

Rn(, )  n +

n(k

- 2

1)

log

1 4



2n(k - 1) log

1 4

.

Therefore,  satisfies the conditions of Theorem 17.1 with B = 2 log(1/(4)), which implies that there exists some bandit problem   Ek such that (17.7)
holds, contradicting our assumption.

Corollary 17.3. Let k  2 and p  (0, 1) and B > 0. Then, there does not exist a policy  such that for all n  1,   (0, 1) and   Ek,

P

R¯n(, )  B

(k - 1)n logp

1 

< .

Proof We proceed by contradiction. Suppose that such a policy exists. Choosing  sufficiently small and n sufficiently large ensures that

1 B

log

1 4

 B logp

1 

and

1 B

n(k - 1) log

1 4

 n.

17.2 Adversarial Bandits

216

Now, by assumption, for any   Ek we have



Rn(, ) 

P R¯n(, )  x dx

0 
 B n(k - 1) exp -x1/p

0

dx  B

n(k - 1) .

Therefore, by the Theorem 17.1, there exists a bandit   Ek such that

P

R¯n(, )  B

n(k - 1) log

1 

P

R¯n(, )



1 4

min

n,

1 B

n(k - 1) log

1 4

 ,

which contradicts our assumption and completes the proof.

We suspect there exists a policy  and universal constant B > 0 such that for all   Ek,

P

R¯n(,

)



 B kn

log

1 

 .

17.2

Adversarial Bandits

We now explain how to translate the ideas in the previous section to the adversarial model. Let  = (t)tn=1 be a fixed policy, and recall that for x  [0, 1]n×k, the random regret is

n

R^n

=

max
i[k]

t=1

(xti

-

xtAt )

.

Let Fx be the cumulative distribution function of the law of R^n when policy  interacts with the adversarial bandit x  [0, 1]n×k.

Theorem 17.4. Let c, C > 0 be sufficiently small/large universal constants and
k  2, n  1 and   (0, 1) be such that n  Ck log(1/(2)). Then there exists a reward sequence x  [0, 1]n×k such that

1 - Fx

c

nk log

1 2

 .

The proof is a bit messy, but is not completely without interest. For the sake of brevity, we explain only the high-level ideas and refer you elsewhere for the gory details. There are two difficulties in translating the arguments in the previous section to the adversarial model. First, in the adversarial model, we need the

17.2 Adversarial Bandits

217

rewards to be bounded in [0, 1]. The second difficulty is we now analyse the
adversarial regret rather than the random pseudo-regret. Given a measure Q, let X  [0, 1]n×k and (At)nt=1 be a collection of random variables on a probability space (, F , PQ) such that

(a) PQ(X  B) = Q(B) for all B  B([0, 1]n×k); and (b) PQ(At | A1, X1, . . . , At-1, Xt-1) = t(At | A1, X1, . . . , At-1, Xt-1) almost
surely, where Xs = XtAs .

Then the regret is a random variable R^n :   R defined by

n

R^n

=

max
i[k]

(Xti
t=1

-

XtAt )

.

Suppose we sample X  [0, 1]n×k from distribution Q on ([0, 1]n×k, B([0, 1]k)).

Claim 17.5. Suppose that X  Q, where Q is a measure on [0, 1]n×k with the Borel -algebra and that EQ[1 - FX (u)]  . Then there exists an x  [0, 1]n×k such that 1 - Fx(u)  .

The next step is to choose Q and argue that EQ[1 - FX (u)]   for sufficiently

large u. To do this, we need a truncated normal distribution. Defining clipping

function

 1 if x > 1

clip[0,1](x) = x0

if x < 0 otherwise .

Let  and  be positive constants to be chosen later and (t)tn=1 a sequence of independent random variables with t  N (1/2, 2). For each i  [k], let Qi be the distribution of X  [0, 1]n×k, where
 clip[0,1](t + ) if j = 1

Xtj

=

cclliipp[[00,,11]]((tt

+ )

2)

if j = i and i = 1 otherwise .

Notice that under any Qi for fixed t, the random variables Xt1, . . . , Xtk are not
independent, but for fixed j, the random variables X1j, . . . , Xnj are independent and identically distributed. Let PQi be the law of X1, A1, . . . , An, Xn when policy  interacts with adversarial bandit sampled from X  Qi.

Claim 17.6. If  > 0 and  = 

k-1 2n

log

1 8

, then there exists an arm i such

that

PQi (Ti(n) < n/2)  2 .
The proof of this claim follows along the same lines as the theorems in the previous section. All that changes is the calculation of the relative entropy. The last step is to relate Ti(n) to the random regret. In the stochastic model, this was

17.3 Notes

218

straightforward, but for adversarial bandits there is an additional step. Notice that under Qi, it holds that Xti - XtAt  0 and that if Xti, XtAt  (0, 1) and At = i, then Xti - XtAt  . From this we conclude that

n
R^n   n - Ti(n) - I {exists j  [k] : Xtj  {0, 1}} .
t=1

(17.8)

The following claim upper-bounds the number of rounds in which clipping occurs with high probability.

Claim 17.7. If  = 1/10 and  < 1/8 and n  32 log(1/), then

PQi

n

I {exists

j



[k]

:

Xtj



{0, 1}}



n 4

 .

t=1

Combining Claim 17.6 and Claim 17.7 with Eq. (17.8) shows there exists an arm i such that

PQi

R^n



n 4

 ,

which by the definition of  and Claim 17.5 implies Theorem 17.4.

17.3

Notes

1 The adversarial bandits used in Section 17.2 had the interesting property that

the same arm has the best reward in every round (not just the best mean).

This cannot be exploited by an algorithm, however, because it only gets a

single observation in each round.

2 In Theorem 17.4, we did not make any assumptions on the algorithm. If we had assumed the algorithm enjoyed an expected regret bound of Rn  B kn, then we could conclude that for each sufficiently small   (0, 1) there exists

an adversarial bandit such that

P

R^n



c B

 kn

log

1 2

 ,

which shows that our high-probability upper bounds for Exp3-IX are nearly tight.

17.4

Bibliographic Remarks
The results in this chapter are by Gerchinovitz and Lattimore [2016], who also provide lower bounds on what is achievable when the loss matrix exhibits nice structure such as low variance or similarity between losses of the arms.

17.5 Exercises

219

17.5

Exercises
17.1 Prove each of the claims in Section 17.2.

Part V
Contextual and Linear Bandits

221
The algorithms introduced so far work well in stationary environments with only a few actions. Real-world problems are seldom this simple. For example, a bandit algorithm designed for targeted advertising may have thousands of actions. Even more troubling, the algorithm has access to contextual information about the user and the advertisement. Ignoring this information would make the problem highly non-stationary, but algorithms introduced in the previous chapter cannot make use of side information.
Large action sets are usually dealt with by introducing structure that allows the algorithm to generalise from one action to another. For example, advertisements can usually be associated with features describing their topic. Then the reward can be described as a function of the features, usually assumed to be nice in some way (linear or smooth, for example). Contextual information is dealt with in a similar fashion by assuming the mean reward of an action is a function of the context features and action features. As we explain, this leads to a model where the action set is essentially changing in each round.
Of course the world is messy in other ways. Rewards are often delayed, and may be unattributed, or the world may be non-stationary. The first of these issues is discussed briefly in the introduction to Part VII while non-stationarity is the subjection of Chapter 31.
Except for the first chapter, which is generic, the focus of this part will be on the special case that the expected reward of each arm is a linear function of some feature vector in a way that will be made precise in Chapter 19. Along the way, we will discuss many generalisations and give references to the literature. One aspect that will play a far larger role is computation. While finite-armed bandits with few arms present no computation difficulties, when the number of actions is very large or the information structure of the feedback model is not so easily separable, then computation can be a serious challenge.

18 Contextual Bandits

In many bandit problems, the learner has access to additional information that may help predict the quality of the actions. Imagine designing a movie recommendation system where users sequentially request recommendations for which movie to watch next. It would be inadvisable to ignore demographic information about the user making the request, or other contextual history such as previously watched movies or ratings. None of the algorithms presented so far make use of this kind of additional information. Indeed, they optimise a benchmark (the regret) that also disregards such contextual data. Essentially they would try to identify the best single movie in hindsight. In this chapter, we present an augmented framework and regret definition that better models real-world problems where contextual information is available.
Whenever you design a new benchmark, there are several factors to consider. Competing with a poor benchmark does not make sense, since even an algorithm that perfectly matches the benchmark will perform poorly. At the same time, competing with a better benchmark can be harder from a learning perspective, and this penalty must be offset against the benefits.
The trade-off just described is fundamental to all machine learning problems. In statistical estimation, the analoguous trade-off is known as the bias-variance trade-off. We will not attempt to answer the question of how to resolve this tradeoff in this chapter because first we need to see how to effectively compete with improved benchmarks. The good news is that many of the techniques developed earlier are easily generalised.

18.1

Contextual Bandits: One Bandit per Context
While contextual bandits can be studied in both the adversarial and stochastic frameworks, in this chapter we focus on the k-armed adversarial model. As usual, the adversary secretly chooses (xt)nt=1, where xt  [0, 1]k with xti the reward associated with arm i in round t. The adversary also secretly chooses a sequence of contexts (ct)tn=1, where ct  C with C a set of possible contexts. In each round,

18.1 Contextual Bandits: One Bandit per Context

223

Adversary secretly chooses rewards (xt)tn=1 with xt  [0, 1]k Adversary secretly chooses contexts (ct)nt=1 with ct  C For rounds t = 1, 2, . . . , n:
Learner observes context ct  C where C is an arbitrary fixed set of contexts. Learner selects distribution Pt  Pk-1 and samples At from Pt. Learner observes reward Xt = xtAt .
Figure 18.1 Interaction protocol for k-armed contextual bandits.

the learner observes ct, chooses an action At and receives reward xtAt . The interaction protocol is shown in Fig. 18.1.

A natural way to define the regret is to compare the rewards collected by

the learner with the rewards collected by the best context-dependent policy in

hindsight:





Rn = E  max

(xti - Xt) .

cC i[k] t[n]:ct=c

(18.1)

If the set of possible contexts is finite, then a simple approach is to use a separate

instance of Exp3 for each context. Let





Rnc = E max

(xti - Xt)

i[k]

t[n]:ct =c

be the regret due to context c  C. When using a separate instance of Exp3 for each context, we can use the results of Chapter 11 to bound

n
Rnc  2 k I {ct = c} log(k) ,
t=1

(18.2)

where the sum inside the square root counts the number of times context c  C is observed. Because this is not known in advance, it is important to use an anytime version of Exp3 for which the above regret bound holds without needing to tune a learning rate that depends on the number of times the context is observed (see Exercise 28.13). Substituting (18.2) into the regret leads to

Rn = Rnc  2

cC

cC

n
k log(k) I {ct = c} .
t=1

(18.3)

The magnitude of the right-hand side depends on the distribution of observed contexts. On one extreme, there is only one observed context, and the bound is the same as the standard finite-armed bandit problem. The other extreme occurs

18.2 Bandits with Expert Advice

224

when all contexts are observed equally often, in which case we have

Rn  2 nk|C| log(k) .

(18.4)

Jensen's inequality applied to Eq. (18.3) shows that this really is the worst case (Exercise 18.1).

The regret in Eq. (18.4) is different than the regret studied in Chapter 11. If

we ignore the context and run the standard Exp3 algorithm, then we would have

n

n

E

Xt

t=1



max
i[k]

t=1

xti

-

2

kn log(k) .

Using one version of Exp3 per context leads to

n

E

Xt

t=1

 max

xti - 2

cC i[k] t[n]:ct=c

kn|C| log(k) .

Which of these bounds is preferable depends on the magnitude of n and how useful the context is. When n is very large, the second bound is more likely to be preferable. On the other hand, the second bound is completely vacuous when n  4k|C| log(k).

18.2

Bandits with Expert Advice

When the context set C is large, using one bandit algorithm per context will almost always be a poor choice because the additional precision is wasted unless the amount of data is enormous. Fortunately, however, it is seldom the case that the context set is both large and unstructured. To illustrate a common situation, we return to the movie recommendation theme, where the actions are movies and the context contains user information such as age, gender and recent movie preferences. In this case, the context space is combinatorially large, but there is a lot of structure inherited from the fact that the space of movies is highly structured and users with similar demographics are more likely to have similar preferences.
We start by rewriting Eq. (18.1) in an equivalent form. Let  be the set of all functions from C  [k]. Then,

n

Rn = E

max


(xt(ct)
t=1

-

Xt)

.

(18.5)

The discussion above suggests that a slightly smaller set  may lead to more

reward. In what follows, we describe some of the most common ideas of how to

do this.

18.2 Bandits with Expert Advice

225

Figure 18.2 Prediction with expert advice. The experts, upon seeing a foot give expert advice on what socks should fit it best. If the owner of the foot is happy, the recommendation system earns a cookie!

Partitions Let P  2C be a partition of C, which means that sets (or parts) in P are disjoint and P P P = C. Then define  to be the set of functions from C to [k] that are constant on each part in P. In this case, we can run a version of Exp3 for each part, which means the regret depends on the number of parts |P| rather than on the number of contexts.

Similarity Functions Let s : C × C  [0, 1] be a function measuring the similarity between pairs of contexts on the [0, 1]-scale. Then let  be the set of functions  : C  [k] such that the average dissimilarity

1 |C|2

(1 - s(c, d))I {(c) = (d)}

c,dC

is below a user-tuned threshold   (0, 1). It is not clear anymore that we can control the regret (18.5) using some simple meta-algorithm on Exp3, but keeping the regret small is still a meaningful objective.

From Supervised Learning to Bandits with Expert Advice Yet another option is to run your favorite supervised learning method, training on batch data to find a collection of predictors 1, . . . , M : C  [k]. Then we could use a bandit algorithm to compete with the best of these in an online fashion. This has the advantage that the offline training procedure can use the power of batch data and the whole army of supervised learning, without relying on potentially inaccurate evaluation methods that aim to pick the best of the pack. And why pick if one does not need to?
The possibilities are endless, but ultimately we always end up with a set of functions  with the goal of competing with the best of them. This suggests we

18.2 Bandits with Expert Advice

226

Adversary secretly chooses rewards x  [0, 1]n×k Experts secretly choose predictions E(1), . . . , E(n) For rounds t = 1, 2, . . . , n:
Learner observes predictions of all experts, E(t)  [0, 1]M×k. Learner selects a distribution Pt  Pk-1. Action At is sampled from Pt and the reward is Xt = xtAt .
Figure 18.3 Interaction protocol for bandits with expert advice.
should think more generally about some subset  of functions without considering the internal structure of . In fact, once  has been chosen, the contexts play very little role. All we need in each round is the output of each function.

18.2.1

Bandits with Expert Advice Framework
The bandits with expert advice setting is a k-armed adversarial bandit, but with M experts making recommendations to the learner. At the beginning of each round, the experts announce their predictions about which actions are the most promising. For the sake of generality, the experts report a probability distribution over the actions. The interpretation is that the expert, if the decision were left to them, would choose the action for the round at random from the probability distribution it reported. As discussed before, in an adversarial setting it is natural to consider randomised algorithms, hence one should not be too surprised that the experts are also allowed to randomise. An application to an important practical problem is illustrated in Fig. 18.2.
The predictions of the M experts in round t are represented by a matrix E(t)  [0, 1]M×k, where the mth row Em(t) is a probability vector over [m] representing the recommendations of expert m in round t. Since Em(t) is a row vector, for a k-dimensional vector x, the expression Em(t)xt is well defined. The learner and the environment interact according to the protocol in Fig. 18.3.
The regret measures the cumulative rewards collected by the learner relative to the best expert in hindsight:

n

n

Rn = E

max
m[M ]

t=1

Em(t)xt

-

t=1

Xt

.

(18.6)

This framework assumes the experts are oblivious in the sense that their predictions do not depend on the actions of the learner.

18.3 Exp4

227

18.3

Exp4

The number 4 in Exp4 is not just an increased version number, but indicates the four e's in the long name of the algorithm, which is exponential weighting for exploration and exploitation with experts. The idea of the algorithm is very simple. Since exponential weighting worked so well in the standard bandit problem, we aim to adopt it to the problem at hand. However, since the goal is to compete with the best expert in hindsight, it is not the actions that we will score, but the experts. Exp4 thus maintains a probability distribution Qt over experts and uses this to come up with the next action in the obvious way, by first choosing an expert Mt at random from Qt and then following the chosen expert's advice to choose At  EM (t)t . The reader is invited to check for themself that this is the same as sampling At from Pt = QtE(t) where Qt is treated as a row vector. Once the action is chosen, one can use their favorite reward estimation procedure to estimate the rewards for all the actions, which is then used to estimate how much total reward the individual experts would have made so far. The reward estimates are then used to update Qt using exponential weighting. The pseudocode of Exp4 is given in Algorithm 11.

1: Input: n, k, M , , 

2: Set Q1 = (1/M, . . . , 1/M )  [0, 1]1×M (a row vector)

3: for t = 1, . . . , n do

4: Receive advice E(t)

5: Choose the action At  Pt, where Pt = QtE(t)

6: Receive the reward Xt = xtAt

7:

Estimate

the

action

rewards:

X^ti

=

1

-

I{At =i} Pti +

(1

-

Xt)

8: Propagate the rewards to the experts: X~t = E(t)X^t

9: Update the distribution Qt using exponential weighting:

Qt+1,i =

exp(X~ti)Qti j exp(X~tj )Qtj

for all i  [M ]

10: end for

Algorithm 11: Exp4.

The algorithm uses O(M ) memory and O(M + k) computation per round (when sampling in two steps). Hence it is only practical when both M and k are reasonably small.

18.4

Regret Analysis
We restrict our attention to the case when  = 0, which is the original algorithm. The version where  > 0 is called Exp4-IX and its analysis is left for Exercise 18.3.

18.4 Regret Analysis

228

Theorem 18.1. Let  = 0 and  = 2 log(M )/(nk), and denote by Rn the expected regret of Exp4 defined in Algorithm 11 after n rounds. Then,

Rn  2nk log(M ) .

(18.7)

After translating the notation, the proof of the following lemma can be extracted from the analysis of Exp3 in the proof of Theorem 11.2 (Exercise 18.2).

Lemma 18.2. For any m  [M ], it holds that

n
X~tm
t=1

-

nM
QtmX~tm
t=1 m=1



log(M ) 

+

 2

nM
Qtm(1 - X^tm)2 .
t=1 m=1

Proof of Theorem 18.1 Let Ft = (E(1), A1, E(2), A2, . . . , At-1, E(t)) and abbreviate Et[·] = E[ · | Ft]. Let m be the index of the best-performing expert in
hindsight:

n
m = argmaxm[M] Em(t)xt ,
t=1

(18.8)

which is not random by the assumption that the experts are oblivious. Applying Lemma 18.2 shows that

n

n

X~tm -

M

QtmX~tm



log(M ) 

+

 2

M

M
Qtm(1 - X~tm)2 .

t=1

t=1 m=1

t=1 m=1

(18.9)

When  = 0 the estimator X^ti is unbiased so that Et[X^t] = xt and

Et[X~t] = Et[E(t)X^t] = E(t)E[X^t] = E(t)xt .

(18.10)

Taking the expectation of both sides of Eq. (18.9) and using the tower rule for conditional expectation and the fact that Qt is Ft-measurable leads to

Rn



log(M ) 

+

 2

n t=1

M
E
m=1

Qtm(1 - X~tm)2

.

(18.11)

Like in Chapter 11, it is more convenient to work with losses. Let Y^ti = 1 - X^ti,

yti = 1 - xti and Y~tm = 1 - X~tm. Note that Y~t = E(t)Y^t and recall the notation

Ati = I {At = i}, which

means that Y^ti =

Ati yti Pti

and

 Et[Y~t2m] = Et 

Em(t)At ytAt PtAt

2

k

=

i=1

Em(t)iyti Pti

2



k i=1

Em(t)i Pti

.

(18.12)

Therefore, using the definition of Pti,

E

M
Qtm(1 - X~tm)2
m=1

E

M
Qtm
m=1

k i=1

Em(t)i Pti

k
=E
i=1

M m=1

QtmEm(t)i

Pti

= k.

18.5 Notes

229

Substituting into Eq. (18.11) leads to

Rn



log(M ) 

+

nk 2

=

2nk log(M ) .

Let us see how this theorem can be applied to the contextual bandit where C is a
finite set and  is the set of all functions from C  [k]. To each of these functions   , we associate an expert m with Em(t)i = I {(ct) = i}. Then M = kC, and Theorem 18.1 says that

Rn  2nk|C| log(k) ,

which is the same bound we derived using an independent copy of Exp3 for each context. More generally, if C is arbitrary (possibly infinite) and  is a finite set of functions from C to [k], then the theorem ensures that

Rn  2nk log(||) .

These results seem quite promising already, but in fact there is another improvement possible. The intuition is that learning should be easier if the experts have a high degree of agreement. One way to measure this is by

tk

Et

=

s=1

i=1

max
m[M

]

Em(si)

.

In Exercise 18.7, you will show that if all experts make identical recommendations, then Et = t and that no matter how the experts behave,

En  n min(k, M ) .

(18.13)

In this sense En/n can be viewed as the effective number of experts, which depends on the degree of disagreement in the expert's recommendations. By modifying the algorithm to use a time varying learning rate, one can prove the following theorem.

Theorem 18.3. Assume the same conditions as in Theorem 18.1, except let t = log(M )/Et. Then there exists a universal constant C > 0 such that

Rn  C En log(M ) .

(18.14)

The proof of Theorem 18.3 is not hard and is left to Exercise 18.4. The bound tells us that Exp4 with the suggested learning rate is able to adapt to degree of disagreement between the experts, which seems like quite an encouraging result. As a further benefit, the learning rate does not depend on the horizon so the algorithm is anytime.

18.5

Notes
1 The most important concept in this chapter is that there are trade-offs when choosing the competitor class. A large class leads to a more meaningful definition

18.5 Notes

230

of the regret, but also increases the regret. This is similar to what we have observed in stochastic bandits. Tuning an algorithm for a restricted environment class usually allows faster learning, but the resulting algorithms can fail when interacting with an environment that does not belong to the restricted class.
2 The Exp4 algorithm serves as a tremendous building block for other bandit problems by defining your own experts. An example is the application of Exp4 to non-stationary bandits that we explore in Chapter 31, which is one of the rare cases where Exp4 can be computed efficiently with a combinatorially large number of experts. When Exp4 does not have an efficient implementation, it often provides a good starting place to derive regret bounds without worrying about computation (for an example, see Exercise 18.5).
3 The bandits with expert advice framework is clearly more general than contextual bandits. With the terminology of the bandits with expert advice framework, the contextual bandit problem arises when the experts are given by static C  [k] maps.
4 A significant challenge is that a naive implementation of Exp4 has running time O(M + k) per round, which can be enormous if either M or k is large. In general there is no solution to this problem, but in some cases the computation can be reduced significantly. One situation where this is possible is when the learner has access to an optimisation oracle that for any context/reward sequence returns the expert that would collect the most reward in this sequence (this is equivalent to solving the offline problem Eq. (18.8)). In Chapter 30 we show how to use an offline optimisation oracle to learn efficiently in combinatorial bandit problems. The idea is to solve a randomly perturbed optimisation problem (leading to the so-called follow-the-perturbed-leader class of algorithms) and then show that the randomness in the outputs provides sufficient exploration. However, as we shall see there, these algorithms will have some extra information, which makes estimating the rewards possible.
5 In the stochastic contextual bandit problem, it is assumed that the context/reward pairs form a sequence of independent and identically distributed random variables. Let  be a set of functions from C to [k] and suppose the learner has access to an optimisation oracle capable of finding
t
argmax xs(cs)
s=1
for any sequence of reward vectors x1, . . . , xt and contexts c1, . . . , ct. A simple and efficient algorithm that exploits such an oracle is based on explore-thencommit, which has O(n2/3) regret (Exercise 18.8). There is a more sophisticated algorithm that is still polynomial-time and for which the regret is about the same as the result in Theorem 18.1 [Agarwal et al., 2014]. The algorithm computes importance-weighted estimates of the rewards in each round. These are used to estimate the regret of all the experts. Based on this, a distribution over the experts (with a small support) is computed by solving a feasibility

18.6 Bibliographic Remarks

231

problem. The distribution is constrained so that the importance weights will not be too large, while the regret estimates averaged over the chosen distribution will stay small. To reduce the computation cost, this distribution is updated periodically with the length of the interval between the updates exponentially growing. The significance of this result is that it reduces contextual bandits to (cost-sensitive) empirical risk minimisation (ERM), which means that any advance in solving cost-sensitive ERM problems automatically translates to bandits. 6 The development of efficient algorithms for ERM is a major topic in supervised learning. Note that ERM can be NP-hard even in simple cases like linear classification [Shalev-Shwartz and Ben-David, 2014, §8.7]. 7 The bound on the regret stated in Theorem 18.3 is data dependent. Note that in adversarial bandits the data and instance are the same thing, while in stochastic bandits the instance determines the probability distributions associated with each arm and the data corresponds to samples from those distributions. In any case a data/instance-dependent bound should usually be preferred if it is tight enough to imply the worst-case optimal bounds. 8 There are many points we have not developed in detail. One is high-probability bounds, which we saw in Chapter 12 and can also be derived here. We also have not mentioned lower bounds. The degree to which the bounds are tight depends on whether or not there is additional structure in the experts. In later chapters we will see examples when the results are essentially tight, but there are also cases when they are not. 9 Theorem 18.3 is the first result where we used a time-varying learning rate. As we shall see in later chapters, time-varying learning rates are a powerful way to make online algorithms adapt to specific characteristics of the problem instance.

18.6

Bibliographic Remarks
For a good account on the history of contextual bandits, see the article by Tewari and Murphy [2017]. The Exp4 algorithm was introduced by Auer et al. [2002b], and Theorem 18.1 essentially matches theorem 7.1 of their paper (the constant in Theorem 18.1 is slightly smaller). McMahan and Streeter [2009] noticed that neither the number of experts nor the size of the action set are what really matters for the regret, but rather the extent to which the experts tend to agree. McMahan and Streeter [2009] also introduced the idea of finding the distribution to be played to be maximally `similar' to Pt(i) while ensuring sufficient exploration of each of the experts. The idea of explicitly optimising a probability distribution with these objectives in mind is at the heart of several subsequent works [e.g. Agarwal et al., 2014]. While Theorem 18.3 is inspired by this work, the result appears to be new and goes beyond the work of McMahan and Streeter [2009] because it shows that all one needs is to adapt the learning rate based on the degree of agreement

18.7 Exercises

232

amongst the experts. Neu [2015a] proves high-probability bounds for Exp4-IX. You can follow in his footsteps by solving Exercise 18.3. Another way to get high-probability bounds is to generalise Exp3.P, which was done by Beygelzimer et al. [2011]. As we mentioned in Note 5, there exist efficient algorithms for stochastic contextual bandit problems when a suitable optimisation oracle is available [Agarwal et al., 2014]. An earlier attempt to address the problem of reducing contextual bandits to cost-sensitive ERM is by Dud´ik et al. [2011]. The adversarial case of static experts is considered by Syrgkanis et al. [2016], who prove suboptimal (worse than n) regret bounds under various conditions for follow-the-perturbed-leader for the transductive setting when the contexts are available at the start. The case when the contexts are independent and identically distributed, but the reward is adversarial is studied by Lazaric and Munos [2009] for the finite expert case, while Rakhlin and Sridharan [2016] considers the case when an ERM oracle is available. The paper of Rakhlin and Sridharan [2016] also considers the more realistic case when only an approximation oracle is available for the ERM problem. What is notable about this work is that they demonstrate regret bounds with a moderate blow-up, but without changing the definition of the regret. Kakade et al. [2008] consider contextual bandit problems with adversarial context-loss sequences, where all but one action suffers a loss of one in every round. This can also be seen as an instance of multi-class classification with bandit feedback where labels to be predicted are identified with actions and the only feedback received is whether the label predicted was correct, with the goal of making as few mistakes as possible. Since minimising the regret is in general hard in this non-convex setting, just like most of the machine learning literature on classification, Kakade et al. [2008] provide results in the form of mistake bounds for linear classifiers where the baseline is not the number of mistakes of the best linear classifier, but is a convex upper bound on it. The recent book by Shalev-Shwartz and Ben-David [2014] lists some hardness results for ERM. For a more comprehensive treatment of computation in learning theory, the reader can consult the book by Kearns and Vazirani [1994].

18.7

Exercises

18.1 Let C be a finite context set, and let c1, . . . , cn  C be an arbitrary sequence of contexts.

(a) Show that

n
I {ct = c}  n|C|.

cC t=1

(b) Assume that n is an integer multiple of |C|. Show that the choice that

maximises the right-hand side of the previous inequality is the one when

each context occurs n/|C| times.

18.2 Prove Lemma 18.2.

18.7 Exercises

233

18.3 In this exercise you will prove an analogue of Theorem 12.1 for Exp4-IX. In the contextual setting, the random regret is

n

R^n

=

max
m[M ]

t=1

Em(t)xt - Xt

.

Design an algorithm that accepts a parameter   (0, 1) such that

P R^n  C

nk log(m) +

nk log(m)

log

1 

 .

18.4 Prove Theorem 18.3.

Hint The key idea is to modify the analysis of Exp3 to handle decreasing learning rates. Of course you can do this directly yourself, or you can peek ahead to Chapter 28, and specifically Exercises 28.12 and 28.13.

18.5 Let x1, . . . , xn be a sequence of reward vectors chosen in advance by an adversary with xt  [0, 1]k. Furthermore, let o1, . . . , on be a sequence of
observations, also chosen in advance by an adversary with ot  [O] for some fixed O  N+. Then let H be the set of functions  : [O]m  [k] where m  N+. In each round the learner observes ot and should choose an action At based on
o1, A1, X1, . . . , ot-1, At-1, Xt-1, ot, and the regret is

n

Rn

=

max
H

xt(ot,ot-1,...,ot-m) - xtAt ,

t=1

where ot = 1 for t  0. This means the learner is competing with the best predictor in hindsight that uses only the last m observations. Prove there exists an algorithm such that

E[Rn]  2knOm log(k) .

18.6 In this problem we consider non-oblivious experts. Consider the following modified regret definition:

n

n

Rn

=

max
m[M ]

E

Em(t)xt -

Xt

t=1

t=1

.

Show the following:

(a) Rn  Rn regardless of whether the experts are oblivious or not. (b) Theorem 18.1 remains valid for non-oblivious experts if in Eq. (18.7) we
replace Rn with Rn. In particular, explain how to modify the proof. (c) Research question: give a non-trivial bound on Rn.

18.7 Prove Eq. (18.13).

18.8 (Explore-then-commit) Consider a stochastic contextual bandit environment where (Ct)tn=1 is a sequence of contexts sampled from distribution

18.7 Exercises

234

 on C and the rewards are (Xt)nt=1, where the conditional law of Xt given Ct and At is PCtAt . The mean reward when choosing action i  [k] having observed context c  C is µ(c, i) = x dPci(x). Let  be a subset of functions from C to
[k]. The regret is

n

Rn = n sup µ() - E

Xt ,



t=1

where µ() = µ(c, (c))d(c). Consider a variation of explore-then-commit, which explores uniformly at random for the first m rounds. Then define

µ^()

=

k m

m

I {At = (Ct)} Xt .

t=1

For rounds t > m, the algorithm chooses At = ^(Ct), where

n
^ = argmax µ^() = argmax X^t(Ct) ,
t=1

where X^ti = kI {At = (Ct)} Xt. When no maximiser exists you may assume that µ^(^)  sup µ^() -  for any  > 0 of your choice. Show that when  is finite, then for appropriately tuned m the expected regret of this algorithms
satisfies

Rn = O n2/3(k log(||))1/3 .

This algorithm is the explore-then-commit version of the epoch-greedy
algorithm by Langford and Zhang [2008]. You should not worry too much about these details, but of course C should be associated with a -algebra and the family of distributions (Pca : c  C, a  [k]) should be a probability kernel from C × [k] to R.

18.9 Consider a stochastic contextual bandit problem with the same set-up as the previous exercise and k = 2 arms. As before, let  be a set of functions from C to [k]. Design a policy such that

n

Rn

=

n

max


µ()

-

E

Xt
t=1

C

ndk log

n d

,

where C > 0 is a universal constant and d = VC() is the VC dimension of .

Hint Use an initial period of exploration to choose a finite `representative' subset of , and then run Exp4 on this subset. The result that you need to know in connection to the VC dimension is known as Sauer's lemma, which states that if  has VC dimension d, then for any sequence c = (ci)m i=1  C, the cardinality of the set c = {((c1), . . . , (cm)) :   } is at most (em/d)d. You may also find it

18.7 Exercises

235

useful that an i.i.d. sequence C1, . . . , Cn is `exchangeable': for any set A  Cn and any  : [n]  [n] bijection, P ((C1, . . . , Cn)  A) = P (C(1), . . . , C(n))  A . This property helps you to argue that the finite subset of  obtained by choosing functions from  that all disagree on the first m elements on the contexts will be representative of the behaviour of functions in  on the rest of the contexts.
We did not talk about VC dimension in this book. An introduction is given by Shalev-Shwartz and Ben-David [2014], or there is the classic text by Vapnik [1998]. The application to bandits is due to Beygelzimer et al. [2011].

19 Stochastic Linear Bandits

Contextual bandits generalise the finite-armed setting by allowing the learner to make use of side information. This chapter focusses on a specific type of contextual bandit problem in the stochastic set-up where the reward is assumed to have a linear structure that allows for learning to transfer from one context to another. This leads to a useful and rich model that will be the topic of the next few chapters. To begin, we describe the stochastic linear bandit problem and start the process of generalising the upper confidence bound algorithm.

19.1

Stochastic Contextual Bandits

The stochastic contextual bandit problem mirrors the adversarial contextual bandit set-up discussed in Chapter 18. At the beginning of round t, the learner observes a context Ct  C, which may be random or not. Having observed the context, the learner chooses their action At  [k] based on the information available. So far everything is the same as the adversarial setting. The difference comes from the assumption that the reward Xt satisfies

Xt = r(Ct, At) + t ,
where r : C × [k]  R is called the reward function and t is the noise, which we will assume is conditionally 1-subgaussian. Precisely, let

Ft = (C1, A1, X1, . . . , Ct-1, At-1, Xt-1, Ct, At)

be the -field summarising the information available just before Xt is observed. Then, we assume that

E [exp(t) | Ft]  exp

2 2

almost surely .

The noise could have been chosen to be -subgaussian for any known 2, but like in earlier chapters, we save ourselves some ink by fixing its value to 2 = 1.
Remember from Chapter 5 that subgaussian random variables have zero mean, so the assumption also implies that E [t | Ft] = 0 and E [Xt | Ft] = r(Ct, At).

19.1 Stochastic Contextual Bandits

237

If F  G are -algebras, and E[exp() | G]  exp(2/2) almost surely, then by the tower rule, E[exp() | F]  exp(2/2) almost surely. Hence, the condition that t is subgaussian with respect to Ft can be `relaxed' to the condition that it be subgaussian with respect to any -algebra containing Ft.

If r was given, then the action in round t with the largest expected return is At  argmaxa[k] r(Ct, a). Notice that this action is now a random variable because it depends on the context Ct. The loss due to the lack of knowledge of r
makes the learner incur the (expected) regret

n

n

Rn = E

max r(Ct, a) - Xt .

t=1 a[k]

t=1

Like in the adversarial setting, there is one big caveat in this definition of the regret. Since we did not make any restrictions on how the contexts are chosen, it could be that choosing a low-rewarding action in the first round might change the contexts observed in subsequent rounds. Then the learner could potentially achieve an even higher cumulative reward by choosing a `suboptimal' arm initially. As a consequence, this definition of the regret is most meaningful when the actions of the learner do not (greatly) affect subsequent contexts.
One way to eventually learn an optimal policy is to estimate r(c, a) for each (c, a)  C × [k] pair. As in the adversarial setting, this is ineffective when the number of context-action pairs is large. In particular, the worst-case regret over all possiblecontextual problems with M contexts and mean reward in [0, 1] is at least ( nM k). While this may not look bad, M is often astronomical (for example, 2100). The argument that gives rise to the mentioned lower bound relies on designing a problem where knowledge of r(c, ·) for context c provides no useful information about r(c , ·) for some different context c . Fortunately, in most interesting applications, the set of contexts is highly structured, which is often captured by the fact that r(·, ·) changes `smoothly' as a function of its arguments.
A simple, yet interesting assumption to capture further information about the dependence of rewards on context is to assume that the learner has access to a map  : C × [k]  Rd, and for an unknown parameter vector   Rd, it holds that

r(c, a) = , (c, a) , for all (c, a)  C × [k] .

(19.1)

The map  is called a feature map, which is the standard nomenclature in machine learning. The idea of feature maps is best illustrated with an example. Suppose the context denotes the visitor of a website selling books, the actions are books to recommend and the reward is the revenue on a book sold. The features could indicate the interests of the visitors as well as the domain and topic of the

19.2 Stochastic Linear Bandits

238

book. If the visitors and books are assigned to finitely many categories, indicator variables of all possible combinations of these categories could be used to create the feature map. Of course, many other possibilities exist. For example, you can train a neural network (deep or not) on historical data to predict the revenue and use the nonlinear map that we obtained by removing the last layer of the neural network. The subspace  spanned by the feature vectors {(c, a)}c,a in Rd is called the feature space.
If · is a norm on Rd then, an assumption on  implies smoothness of r. In particular, from H¨older's inequality,
|r(c, a) - r(c , a )|   (c, a) - (c , a )  ,
where ·  denotes the dual of · . Restrictions on  have a similar effect to assuming that the dimensionality d is finite. In fact, one may push this to the extreme and allow d to be infinite, an approach that can buy tremendous flexibility and makes the linearity assumption less limiting.

19.2

Stochastic Linear Bandits

Stochastic linear bandits arise from realising that under Eq. (19.1), all that
matters is the feature vector that results from choosing a given action and not
the `identity' of the action itself. This justifies studying the following simplified model: in round t, the learner is given the decision set At  Rd, from which it chooses an action At  At and receives reward

Xt = , At + t ,

where t is 1-subgaussian given A1, A1, X1, . . . , At-1, At-1, Xt-1, At and At. The random (pseudo-)regret and regret are defined by

n

R^n

=

t=1

max
aAt

, a - At

,

n

n

Rn = E R^n = E

max
t=1 aAt

, a

- Xt
t=1

,

respectively. Different choices of At lead to different settings, some of which we have seen before. For example, if (ei)i are the unit vectors and At = {e1, . . . , ed}, then the resulting stochastic linear bandit problem reduces to the finitearmed setting. On the other hand, if At = {(Ct, i) : i  [k]}, then we have a contextual linear bandit. Yet another possibility is a combinatorial action set At  {0, 1}d. Many combinatorial problems (such as matching, least-cost problems in directed graphs and choosing spanning trees) can be written as linear optimisation problems over some combinatorial set A obtained from considering incidence vectors often associated with some graph. Some of these topics will be covered later in Chapter 30.

19.2 Stochastic Linear Bandits

239

As we have seen in earlier chapters, the UCB algorithm is an attractive approach for finite-action stochastic bandits. Its best variants are nearly minimax optimal, instance optimal and exactly optimal asymptotically. With these merits in mind, it seems quite natural to try and generalise the idea to the linear setting.
The generalisation is based on the view that UCB implements the `optimism in the face of uncertainty' principle, which is to act in each round as if the environment is as nice as plausibly possible. In finite-action stochastic bandits, this means choosing the action with the largest upper confidence bound. In the case of linear bandits, the idea remains the same, but the form of the confidence bound is more complicated because rewards received yield information about more than just the arm played.
The first step is to construct a confidence set Ct  Rd based on (A1, X1, . . . , At-1, Xt-1) that contains the unknown parameter vector  with high probability. Leaving the details of how the confidence set is constructed aside for a moment, and assuming that the confidence set indeed contains , for any given action a  Rd, let

UCBt(a)

=

max
Ct

, a

(19.2)

be an upper bound on the mean pay-off , a of a. The UCB algorithm that uses the confidence set Ct at time t then selects

At = argmaxaAt UCBt(a) .

(19.3)

UCB applied to linear bandits is known by various names, including LinRel
(linear reinforcement learning), LinUCB and OFUL (optimism in the f ace of
uncertainty for linear bandits). We will not be very dogmatic of this name and
call algorithms with the above construct instances of LinUCB. The main question is how to choose the confidence set Ct  Rd. As usual, there
are conflicting desirable properties:

(a) Ct should contain  with high probability.
(b) Ct should be as small as possible.
At first sight it is not at all obvious what Ct should look like. After all, it is a subset of Rd, not just an interval like the confidence intervals about the empirical estimate of the mean reward for a single action that we saw in the previous chapters. While we specify the analytic form of a possible construction for Ct here, there are some details in choosing some of the parameters in this construction. As they are both delicate and important, we dedicate the next chapter to discussing them.
Following the idea for UCB, we need an analogue for the empirical estimate of the unknown quantity, which in this case is . There are several principles one might use for deriving such an estimate. For now we use the regularised

19.2 Stochastic Linear Bandits

240

least-squares estimator, which is

t

^t = argminRd

(Xs -

, As

)2 + 



2 2

,

s=1

(19.4)

where   0 is called the penalty factor. Choosing  > 0 helps because it
ensures that the loss function has a unique minimiser even when A1, . . . , At do not span Rd, which simplifies the math. The solution to Eq. (19.4) is obtained easily by differentiation and is

t
^t = Vt-1 AsXs ,
s=1
where (Vt)t are d × d matrices given by

(19.5)

t
V0 = I and Vt = V0 + AsAs .
s=1

(19.6)

So ^t is an estimate of , which makes it natural to choose Ct to be centered at ^t-1. For what follows, we will simply assume that the confidence set Ct is closed and satisfies

Ct  Et =

  Rd :

 - ^t-1

2 Vt-1



t

,

(19.7)

where (t)t is an increasing sequence of constants with 1  1. The set Et is an ellipsoid centred at ^t-1 and with principle axis being the eigenvectors of Vt with corresponding lengths being the reciprocal of the eigenvalues. Notice that as t grows, the matrix Vt has increasing eigenvalues, which means the volume of the ellipse is also shrinking (at least, provided t does not grow too fast). As noted beforehand, the next chapter will be devoted to show that Ct = Et is a natural choice for carefully chosen t. In the rest of this chapter, we simply examine the consequence of using a confidence set satisfying Eq. (19.7) and assume all the desirable properties.

The impatient reader who is puzzled of the form Et may briefly think of the case when s  N (0, 2), A1, . . . , At-1 are deterministic and span Rd so that we can take  = 0. In this case, one easily computes that with V = Vt-1, Z = V 1/2(^t-1 - )  N (0, I), or that Z 2 is the sum of d, independent standard normal random variables, and thus it follows the 2-distribution
(with d degrees of freedom), from which one can find the appropriate value
of t-1. As we shall see, the expression one can get from this calculation, will, more or less, be still correct in the general case.

19.3 Regret Analysis

241

19.3

Regret Analysis

We prove a regret bound for LinUCB under the assumption that the confidence intervals indeed contain the true parameter with high probability and boundedness conditions on the action set and rewards.

Assumption 19.1. The following hold:

(a) 1  1  2  . . . n.

(b) maxt[n] supa,bAt , a - b  1.

(c)

a 2  L for all a 

n t=1

At

.

(d) There exists a   (0, 1) such that with probability 1 - , for all t  [n],

  Ct where Ct satisfies Eq. (19.7).

Theorem 19.2. Under the conditions of Assumption 19.1 with probability 1 - , the regret of LinUCB satisfies

R^n 

8nn log

det Vn det V0



8dnn log

d + nL2 d

.

Theorem 20.5 in the next chapter shows that n may be chosen to be

 n = m2 +

2 log

1 

+ d log

d + nL2 d

,

(19.8)

where m2 is an upper bound on  2. By choosing  = 1/n, we obtain the following corollary bounding the expected regret.

Corollary 19.3. Under the conditions of Assumption 19.1, the expected regret of LinUCB with  = 1/n is bounded by
 Rn  Cd n log(nL) ,
where C > 0 is a suitably large universal constant.

The proof of Theorem 19.2 depends on the following lemma, often called the elliptical potential lemma.

Lemma 19.4. Let V0  Rd×d be positive definite and a1, . . . , an  Rd be a sequence of vectors with at 2  L <  for all t  [n], Vt = V0 + st asas . Then,

n

t=1

1

a2
t Vt--11

 2 log

det Vn det V0

 2d log

trace V0 + nL2 d det(V0)1/d

.

Proof Using that for any u  0, u  1  2 ln(1 + u), we get

n

t=1

1

a2
t Vt--11

2

t

log

1+

a2
t Vt--11

.

19.3 Regret Analysis

242

We now argue that this last expression is log

det Vn det V0

. For t  1, we have

Vt = Vt-1 + atat = Vt1-/12(I + Vt--11/2atat Vt--11/2)Vt1-/12 .

Now, since the determinant is a multiplicative map,

det(Vt) = det(Vt-1) det I + Vt--11/2atat Vt--11/2

= det(Vt-1)

1+

a2
t Vt--11

,

where the second equality follows because the matrix I + yy has eigenvalues

1+

y

2 2

and

1

as

well

as

the

fact

that

the

determinant

of

a

matrix

is

the

product

of its eigenvalues. Putting things together, we see that

n

det(Vn) = det(V0)
t=1

1+

a2
t Vt--11

,

(19.9)

which is equivalent to the first inequality that we wanted to prove. To get the second inequality, note that by the inequality of arithmetic and geometric means,

d
det(Vn) = i 

1 d

trace

Vn

d


i=1

where 1, . . . , d are the eigenvalues of Vn.

trace V0 + nL2 d

d
,

Proof of Theorem 19.2 By part (d) of Assumption 19.1, it suffices to prove the bound on the event that   Ct for all rounds t  [n]. Let At = argmaxaAt , a be an optimal action for round t and rt be the instantaneous regret in round t
defined by

rt = , At - At . Let ~t  Ct be the parameter in the confidence set for which ~t, At = UCBt(At). Then, using the fact that   Ct and the definition of the algorithm leads to
, At  UCBt(At )  UCBt(At) = ~t, At .

Using Cauchy­Schwarz inequality and the assumption that   Ct and facts that ~t  Ct and Ct  Et leads to

rt = , At - At  ~t - , At  At Vt--11 ~t -  Vt-1  2 At Vt--11 t .

(19.10)

By part (b) we also have rt  2, which, combined with n  max{1, t}, yields

rt  2  2 t At  2 Vt--11 n 1  At Vt--11 . Then, by Cauchy­Schwarz inequality,

n
R^n = rt 
t=1

n

n

n rt2  2
t=1

nn
t=1

1

At

2 Vt--11

.

(19.11)

19.4 Notes

243

The result is completed using Lemma 19.4, which depends on part (c) of Assumption 19.1.

19.3.1

Computation

An obvious question is whether or not the optimisation problem in Eq. (19.3) can be solved efficiently. First note that the computation of At can also be written as

(At, ~t) = argmax(a,)At×Ct , a .

(19.12)

This is a bilinear optimisation problem over the set At × Ct. In general, not much can be said about the computational efficiency of solving this problem. There are two notable special cases, however.

(a) Suppose that a() = argmaxaAt , a can be computed efficiently for any  and that Ct = co(1, . . . , m) is the convex hull of a finite set. Then At can be computed by finding a(1), . . . , a(m) and choosing At = a(i), where i maximises i, a(i) .
(b) Assume that Ct = Et is the ellipsoid given in Eq. (19.7) and At is a small finite set. Then the action At from Eq. (19.12) can be found using

At = argmaxaAt ^t-1, a + t a , Vt--11

(19.13)

which may be solved by simply iterating over the arms and calculating the term inside the argmax. Further implementation issues are explored in Exercise 19.8.

19.4

Notes
1 It was mentioned that  may map its arguments to an infinite dimensional space. There are several issues that arise in this setting. The first is whether or not the algorithm can be computed efficiently. This is usually tackled via the kernel trick, which assumes the existence of an efficiently computable kernel function  : (C × [k]) × (C × [k])  R such that
(c, a), (c , a ) = ((c, a), (c , a )) .
The trick is to rewrite all computations in terms of the kernel function so that (c, a) is neither computed, nor stored. The second issue is that the claim made in Theorem 19.2 depends on the dimension d and becomes vacuous when d is large or infinite. This dependence arises from Lemma 19.4. It is possible to modify this result by replacing d with a data-dependent quantity that measures the `effective dimension' of the image of the data under . The final challenge is to define an appropriate confidence set. See the bibliographic remarks for further details and references.

19.4 Notes

244

2 The bound given in Theorem 19.2 is essentially a worst-case style of bound, with little dependence on the parameter  or the geometry of the action set. Instance-dependent bounds for linear bandits are still an open topic of research, and the asymptotics are only understood in the special case where the action set is finite and unchanging (Chapter 25).
3 Theorem 20.5 in the next chapter shows that (t)nt=1 as defined in Eq. (19.8) can be replaced with a data-dependent quantity that is strictly smaller:

t1/2

=

 m2 

+

2 log

1 

+ log

det(Vt-1) d

.

(19.14)

Empirically this choice is never worse than the value suggested in Eq. (19.8) and sometimes better, typically by a modest amount. 4 The application of Cauchy­Schwarz in Eq. (19.11) often loses a logarithm, as it does, for example, when rt = 1/t. Recently, however, a lower bound for contextual linear bandits has been derived by constructing a sequence for which this Cauchy­Schwarz is tight, as well as Lemma 19.4 [Li et al., 2019b]. 5 In the worst case, the bound in Theorem 19.2 is tight up to logarithmic factors. More details are in Chapter 24, which is devoted to lower bounds for stochastic linear bandits. The environments for which the lower bound nearly matches the upper bound have action sets that are either infinite or exponentially large in the dimension. When |At|  k for all rounds t, there are algorithms for which the regret is

Rn = O dn log3(nk) .

The special case where the action set does not change with time is treated in Chapter 22, where references to the literature are also provided.
6 The calculation in Eq. (19.13) shows that LinUCB has more than just a passing resemblance to the UCB algorithm introduced in Chapter 7. The term ^t-1, a may beinterpreted as an empirical estimate of the reward from choosing action a, and t a Vt--11 is a bonus term that ensures sufficient exploration. If the penalty term vanishes ( = 0) and At = {e1, . . . , ed} for all t  [n], then ^i becomes the empirical mean of action ei, and the matrix Vt is diagonal, with its ith diagonal entry being the number of times action ei is used up to and including round t. Then the bonus term has order

t ei = Vt--11

t Ti(t -

1)

,

where Ti(t - 1) is the number of times action ei has been chosen before the tth round. So UCB for finite-armed bandits is recovered by choosing t = 2 log(·), where the term inside the logarithm can be chosen in a variety of ways as discussed in earlier chapters. Notice now that the simple analysis given in this chapter leads to a regret bound of O( dn log(·)), which is quite close to the

19.5 Bibliographic Remarks

245

highly specialised analysis given in Chapters 7 to 9. Note however that the dimension-free choice of t does not satisfy Eq. (19.7), but this happens to be unnecessary for the proof of Theorem 19.2 to go through. 7 An extension of considerably interest of the linear model is the generalised linear model where the reward is

Xt = µ( , At ) + t ,

(19.15)

where µ-1 : R  R is called the link function. A common choice is the sigmoid function: µ(x) = 1/(1 + exp(-x)) Bandits with rewards from a generalised linear model have been studied by Filippi et al. [2010], who prove a bound with a similar form as Theorem 19.2. Unfortunately, however, the bound depends in a slightly unpleasant manner on the form of the link function, and it seems there may be significant room for improvement. You will analyse and algorithm for generalised linear bandits in Exercise 19.6. 8 Beyond optimism, there are at least three other principles for constructing algorithms for stochastic linear bandits. The first is Thompson sampling, which is a randomised Bayesian algorithm discussed at length in Chapter 36. The second is a class of algorithms designed to achieve asymptotic optimality in the special cases where the action set is fixed, or sampled i.i.d. from a fixed distribution with finite support. These algorithms are fall into the class of `optimisation-based' algorithms that estimate the unknown parameter and then solve an optimisation problem to determine an optimal allocation over the actions [Lattimore and Szepesv´ari, 2017, Ok et al., 2018, Combes et al., 2017, Hao et al., 2020]. A downside of optimisation-based approaches is that so far the results have a very asymptotic nature and the algorithms are not very practical. These ideas are discussed a little more in Chapter 25, where we prove asymptotic lower bounds for linear bandits. The third design principle is called information-directed sampling, which has a Bayesian version [Russo and Van Roy, 2014a] and frequentist analogue [Kirschner and Krause, 2018]. In rough terms, these algorithms choose a distribution over actions that minimises the ratio of a squared expected instantaneous regret and the information gain about the optimal action, which in the frequentist version is replaced by a potential function that mimics the information gain.

19.5

Bibliographic Remarks
Stochastic linear bandits were introduced by Abe and Long [1999]. The first paper to consider algorithms based on the optimism principle for linear bandits is by Auer [2002], who considered the case when the number of actions is finite. The core ideas of the analysis of optimistic algorithms (and more) is already present in this paper. An algorithm based on confidence ellipsoids is described in the papers by Dani et al. [2008], Rusmevichientong and Tsitsiklis [2010] and AbbasiYadkori et al. [2011]. The regret analysis presented here, and the discussion of the

19.6 Exercises

246

computational questions, stresses that an expected

riesglraertgeolfyO~b(adsedn)oncatnhebefoarcmheiervoefdtrheegsaerwdloersksso, fwthhiechshaalpsoe

of the decision sets At as long as the means are guaranteed to lie in a bounded

interval. Rusmevichientong and Tsitsiklis [2010] consider both optimistic and

explore-then-commit strategies, which they call `phased exploration and greedy

exploitation' (PEGE). They focus on the case where At is the unit ball or some

other compact set with a smooth boundary and show that PEGE is optimal up to

logarithmic factors. The observation that explore-then-commit works for the unit

ball (and other action sets with a smooth boundary) was independently made

by Abbasi-Yadkori et al. [2009], further expanded in [Abbasi-Yadkori, 2009a].

Generalised linear models are credited to Nelder and Wedderburn [1972]. We

mentioned already that LinUCB was generalised to this model by Filippi et al.

[2010]. A more computationally efficient algorithm has recently been proposed by

Jun et al. [2017]. Nonlinear structured bandits where the pay-off function belongs

to a known set have also been studied [Anantharam et al., 1987, Russo and Van

Roy, 2013, Lattimore and Munos, 2014]. Kernelised versions of UCB have been

given by Srinivas et al. [2010], Abbasi-Yadkori [2012] and Valko et al. [2013b].

We mentioned early in the chapter that making assumptions on the norm  is

related to smoothness of the reward function with smoother functions leading

to stronger guarantees. For an example of where this is done, see the paper on

`spectral bandits' by Valko et al. [2014] and Exercise 19.7.

19.6

Exercises

19.1 (Least-squares solution) Prove that the solution given in Eq. (19.5) is indeed the minimiser of Eq. (19.4).

19.2 (Action selection with ellipsoidal confidence sets) Show that the action selection in LinUCB can indeed be done as shown in Eq. (19.13) when Ct = Et is an ellipsoid given in Eq. (19.7).

19.3 (Elliptical potentials: You cannot have more than O(d) big

intervals) Let V0 = I and a1, . . . , an  Rd be a sequence of vectors with

at 2  L for all t  [n]. Then let Vt = V0 +

t s=1

asas

and show that the

number of times at Vt--11  1 is at most

3d log(2)

log

1

+



L2 log(2)

.

19.6 Exercises

247

The proof of Theorem 19.2 depended on part (b) of Assumption 19.1, which asserts that the mean rewards are bounded by one. Suppose we replace this assumption with the relaxation that there exists a B > 0 such that
max sup , a - b  B .
t[n] a,bAt
Then, Exercise 19.3 allows you to bound the number of rounds when xt Vt--11  1, and in these rounds the naive bound of rt  B is used. For the remaining rounds, the analysis of Theorem 19.2 goes through unaltered.
As a consequence we see that the dependence on B is an additive constant term that does not grow with the horizon.

19.4 (Computation cost savings with fixed large action set) When the action set At = A is fixed and |A| = k, the total computation cost of LinUCB after n rounds is O(kd2n) in n rounds if the advice on implementation of Exercise 19.8 is used. This can be reduced to O(k log(n) + d2n) with almost no increase of the regret, a significant reduction when k d2. For this, LinUCB
should be modified to work in phases, where in a given fixed it uses the same
action computed in the usual way at the beginning of the phase. A phase ends
when log det Vt() increases by log(1 + ).

(a) Prove that if 0  B

A then supx=0

x x

2 A 2 B



det det

A B

.

(b) Let Assumption 19.1 hold. Let R^n(n) be the regret bound of LinUCB

stated Theorem 19.2. Show that with probability 1 -  the random pseudoregret R^n of the phased version of LinUCB, as described above, satisfies R^n  R^n((1 + )n).

19.5 (Lipschitz reward functions) Consider the k-armed stochastic contextual setting of Section 19.1, and assume that C = [0, 1] and that the reward functions r(·, i) : C  [0, 1] are L-Lipschitz:

|r(x, i) - r(y, i)|  L|x - y| for all x, y  [0, 1] , i  [k] .

(a) Construct an algorithm whose regret Rn after n rounds is O((Lk log k)1/3n2/3). (b) Show that the minimax optimal regret is of the order ((Lk)1/3n2/3). (c) Generalise the result to the case when C = [0, 1]d and in the definition
of Lipschitzness we use the Euclidean norm. Show the dependence on the dimension in the lower and upper bounds. Discuss the influence of the choice of the norm.
Hint Consider discretising C. Alternatively, use Exp4.

19.6 Exercises

248

This exercise is inspired by the work of Perchet and Rigollet [2013], who focus on improving the regret bound by adaptive discretisation when a certain margin condition holds. There are many variations of the problem of the previous exercise. For starters, the domain of contexts could be more general: one may consider higher-order smoothness, continuous action and context spaces. What is the role of the context distribution? In some applications, the context distribution can be estimated for free, in which case you might assume the context distribution is known. How to take a known context distribution into account? To whet your appetite, if the context distribution is concentrated on a handful of contexts, the discretisation should respect which contexts the distribution is concentrated on. Instead of discretisation, one may also consider function approximation. An interesting approach that goes beyond discretisation is by Combes et al. [2017] (see also Magureanu et al. 2014). The approach in these papers is to derive an asymptotic, instance-dependent lower bound, which is then used to guide the algorithm (much like in the track-and-stop algorithm in Section 33.2). An open problem is to design algorithms that are simultaneously near minimax optimal and asymptotically optimal. As described in Part II, this problem is now settled for finite-armed stochastic bandits, the only case where we can say this in the whole literature of bandits.

19.6 (Generalised linear bandits) In this exercise you will design and analyse an algorithm for the generalised linear bandit problem mentioned in Note 7. Let  be a convex compact subset of Rd and assume that   . The only difference relative to the standard model is that the reward is
Xt = µ( , At ) + t ,
where µ : R  R is a continuously differentiable function such that

c1 = min

1, min min µ ( , a )
atn=1At 

>0

and

c2 = max

1, max max µ ( , a )
atn=1At 

< .

That c1 > 0 is assumed implies that µ is increasing on the relevant area of its domain. Like in the standard model, for each t  1, t is 1-subgaussian given A1, X1, . . . , At-1, Xt-1, At, and you may as well assume that rewards and feature vectors are bounded:

max µ(
a,bnt=1 At

, a

) - µ(

, b

)1

and

max
atn=1 At

a 2  L and

 2  m2 .

Recall that  is the regularisation parameter in the definition of Vt (see Eq. (19.6))

19.6 Exercises

249

and let

t
gt() =  + µ( , As )As ,
s=1

Lt() =

t

gt() - XsAs

.

s=1

Vt-1

(a) Let t be as in Eq. (19.8) and define a confidence set Ct by

Ct =    : Lt-1()  t1-/21 .

Show that   Ct for all t with probability at least 1 - . (b) Prove that for all ,   , c1  -  Vt  gt() - gt( ) . Vt-1 (c) Consider the algorithm that chooses

At

=

argmaxaAt

max µ(
Ct

, a

).

Prove that on the event that   Ct, for At = argmaxaAt µ( , a ),

rt

=

µ(

, At

) - µ(

, At

)



2c2t1-/21 c1

At

. Vt--11

(d) Prove that with probability at least 1 - , the random regret R^n =

n t=1

rt

is bounded by

R^n



c2 c1

8ndn log

1

+

nL2 d

.

Hint For (a), you should peek into the future and use Theorem 20.4. The mean value theorem will help with Part (b).

19.7 (Spectral bandits) The regret of LinUCB can be improved considerably

if an appropriate norm of  is known to be small. In this exercise you will

investigate this phenomenon. Suppose that V0 is positive definite with eigenvalues

1, . . other

. , d, respective eigenvectors quantities are left unchanged,

v1, . . . , vd, and Vt but the alternative

= V0 value

+ of

V0stm=1eaAnssAtsh.atA^ltl

is heavily regularised in the direction of each vi for which i is large. Without loss of generality, assume that (i)id=1 is increasing and let  = 1 be the smallest eigenvalue. Define the `effective dimension' by

deff = max

i



[d]

:

(i -

1)i



n log(1 + nL2/)

 [d] .

(a) Prove that log

det(Vt ) det(V0 )

 2deff log

1

+

nL2 

.

(b) Let m > 0 be a user-defined constant and

t1/2 = m +

2 log

1 

+ log

det(Vt) det(V0)

and let Ct = { :

 - ^t-1

2 Vt-1



t-1}.

Assume

that

 V0  m and

prove that   Ct for all t with probability at least 1 - .

19.6 Exercises

250

(c) Prove that if  V0  m, then with probability at least 1 - , the random regret of LinUCB in this setting is bounded by

R^n 

8ndeff log

1

+

nL2 

.

(d) Show that with an appropriate choice of ,

E[R^n] = O

 deff n

log(nL2)

,

(19.16)

where the last equality suppresses dependence on m and  = 1.

(e) The result of the previous display explains the definition of the `effective

dimension' deff. When V0 Corollary 19.3 states that

=I for

,

whichmgi,vEes[R^rnis]e=toOu(dnifonrmlogr(engLu2l)a)r.isGativioenn,

Eq. (19.16), for a fixed n, deff can be thought of as replacing the dimension

d when V0 is chosen as any positive definite matrix with V0 I. It follows then that when deff  d, the upper bound for non-uniform regularisation will

be smaller. Given this, explain the potential pros and cons of non-uniform

regularisation. What happens when  V0  m fails to hold? Show a bound on the degradation of the expected regret as a function of max(0,  V0 -m).

Hint For Part (b), you should peek into the next chapter and modify Theorem 20.5.

Valko et al. [2014] had a particular application in mind when designing

the algorithm in Exercise 19.7. Consider a large graph with k vertices

and similarity matrix between the vertices W  [0, )k×k. The graph

Laplacian is the matrix L = D - W , where D is diagonal with Dii =

k j=1

Wij

.

Let

µ



[0, 1]k

be

an

unknown

reward

function

and

consider

a

bandit algorithm with k actions corresponding to the vertices of the graph.

Without further assumptions, this is a finite-armed bandit, which for large

k is hopeless without further assumptions. Valko et al. [2014] assume the

rewards for well-connected vertices are similar ­ a kind of smoothness. Let

L = Q Q be the spectral decomposition of L and  = Q µ. Then,

1 2

Wij (µi - µj )2 =



2 

.

i,j[k]

The left-hand side measures the variability of µ, weighted by connectivity of the graph. Hence, assuming that   is small corresponds to assuming that µ changes only a little between well-connected vertices. Valko et al. [2014] then let V0 =  + I and analyse/implement the algorithm described in Exercise 19.7. A more detailed exposition is by Valko [2016].

19.8 (Implementation) If the action set is the same in every round, then the assumptions are satisfied for the various versions of UCB discussed in Chapters 7

19.6 Exercises

251

Expected regret

LinUCB

4,000

LinUCB

40

UCB

UCB

30

2,000

20
0 0.2 0.4 0.6 0.8 1 

0 0 200 400 600 800 1,000 k

Figure 19.1 The plot on the left compares the regret of UCB (Algorithm 6) and LinUCB on a Gaussian bandit with k = 2, n = 1000 and varying suboptimality gaps . The plot on the right compares the same algorithms on a linear bandit with actions uniformly distributed on the sphere and with d = 5 and n = 5000. The parameter  is also uniformly generated on the sphere.

to 9. How does LinUCB compare to UCB? Implement the version of LinUCB using the value of t given in Eq. (19.8) and/or Eq. (19.14) and compare it the version of UCB given in Algorithm 6. In particular:
(a) Compare LinUCB with UCB on the 2-armed bandit with n = 1000 where the reward distributions are Gaussian with unit variance and mean µ = (0, -) where   [0, 1], which for LinUCB corresponds to using At = {e1, e2} with d = 2.
(b) Now compare LinUCB with UCB on k-armed stochastic linear bandits where the d = 5 and At = A is composed of k unit vectors sampled from the uniform distribution on the sphere (sample these vectors once). The unknown parameter  should also lie on the unit sphere and the noise should be standard Gaussian. Plot the expected regret as a function of k ranging from 2 to 1000 with a horizon of n = 5000.
(c) What conclusions can you draw from the experimental results you obtained? (d) Show how one can use the Sherman-Morrison formula to implement
LinUCB using O(kd2) computation cost per round.
For parts (a) and (b) you should produce something comparable to Fig. 19.1.

20 Confidence Bounds for Least Squares Estimators

In the last chapter, we derived a regret bound for a version of the upper confidence
bound algorithm that depended on a particular kind of confidence set. The purpose
of this chapter is to justify these choices. Suppose a bandit algorithm has chosen actions A1, . . . , At  Rd and received
the rewards X1, . . . , Xt with Xs = , As + s where s is zero-mean noise. Recall from the previous chapter that the penalised least-squares estimate of  is the minimiser of

t

Lt() =

(Xs -

, As

)2 + 



2 2

,

s=1

where   0 is the penalty factor. This is minimised by

t
^t = Vt()-1 XsAs
s=1

t
with Vt() = I + AsAs .
s=1

(20.1)

It is convenient for the remainder to abbreviate Vt = Vt(0). Designing confidence sets for  when A1, . . . , At have been chosen by a bandit algorithm is a surprisingly delicate matter. The difficulty stems from the fact that the actions are neither fixed nor independent but are intricately correlated via the rewards. We spend the first section of this chapter building intuition by making some simplifying assumptions. Eager readers may skip directly to Section 20.1. For the rest of this section, we assume the following:

1 No regularisation:  = 0 and Vt is invertible. 2 Independent subgaussian noise: (s)s are independent and 1-subgaussian. 3 Fixed design: A1, . . . , At are deterministically chosen without the knowledge of
X1, . . . , Xt.
None of these assumptions is plausible in the bandit setting, but the simplification eases the analysis and provides insight.

The assumption that  = 0 means that in this section, ^t is just the ordinary
least squares estimator of . The requirement that Vt be non-singular means that (As)ts=1 must span Rd, and so t must be at least d.

Confidence Bounds for Least Squares Estimators

253

Comparing  and ^t in the direction x  Rd, we have

^t - , x = =

t

t

x, Vt-1 AsXs -  = x, Vt-1 As

s=1

s=1

t

t

x, Vt-1 Ass =

x, Vt-1As s .

s=1

s=1

As  + s

- 

Since (s)s are independent and 1-subgaussian, by Lemma 5.4 and Theorem 5.3,

 P  x, ^t -  

t

2

x, Vt-1As 2 log

s=1



1 

  .

A little linear algebra shows that

t s=1

x, Vt-1As 2 =

x

2 Vt-1

and so

P

^t - , x 

2

x

2 Vt-1

log

1 

 .

(20.2)

If we only care about confidence bounds for one or a few vectors x, we could stop here. For large action sets (with more than (2d) actions), one approach is to convert this bound to a bound on ^t -  Vt . To begin this process, notice that

^t - 

Vt =

^t - , Vt1/2X

,

where

X

=

Vt1/2(^t - ) ^t -  Vt

.

The problem is that X is random, while we have only proven (20.2) for

deterministic x. The standard way of addressing problems like this is to use

a covering argument. First we identify a finite set C  Rd such that whatever

value X takes, there exists some x  C that is -close to X. Then a union

bound and a triangle inequality allows one to finish. By its definition, we have

X

2 2

=

X

X = 1, which means that X  Sd-1 = {x  Rd :

x 2 = 1}. Using

that X  Sd-1, we see it suffices to cover Sd-1. The following lemma provides

the necessary guarantees on the size of the covering set.

Lemma 20.1. There exists a set C  Rd with |C|  (3/)d such that for all x  Sd-1 there exists a y  C with x - y 2  .

The proof of this lemma requires a bit work, but nothing really deep is needed. This work is deferred to Exercises 20.3 and 20.4. Let C be the covering set given by the lemma, and define event

E = exists x  C : Vt1/2x, ^t -  

2 log

|C| 

.

Using the fact that Vt1/2x Vt-1 = x 2 = 1, and a union bound combined with Eq. (20.2) shows that P (E)  . When E does not occur, Cauchy­Schwarz shows

20.1 Martingales and the Method of Mixtures

254

that

^t - 

Vt

=

max
xSd-1

Vt1/2x, ^t - 

= max min
xSd-1 yC

Vt1/2(x - y), ^t -  + Vt1/2y, ^t - 

< max min
xSd-1 yC

^t -  Vt x - y 2 +

2 log

|C| 

  ^t -  Vt +

2 log

|C| 

.

Rearranging yields

^t - 

Vt

<

1 1-

2 log

|C| 

.

Now there is a tension in the choice of  > 0. The term in the denominator suggests that  should be small, but by Lemma 20.1 the cardinality of C grows rapidly as  tends to zero. By lazily choosing  = 1/2,

P

^t -  Vt  2

2

d log(6) + log

1 

 .

(20.3)

Except for constants and other minor differences, this turns out to be about as good as you can get. Unfortunately, however, this analysis only works because Vt was assumed to be deterministic. When the actions are chosen by a bandit algorithm, this assumption does not hold, and the ideas need to be modified.

20.1

Martingales and the Method of Mixtures

We now remove the limiting assumptions in the previous section. Of course some conditions are still required. For the remainder of this section the following is assumed:

1 There exists a   Rd such that Xt = , At + t for all t  1. 2 The noise is conditionally 1-subgaussian:

for all   R and t  1,

E [exp(t) | Ft-1]  exp

2 2

a.s. , (20.4)

where Ft-1 is such that A1, X1, . . . , At-1, Xt-1, At are Ft-1-measurable. 3 In addition, we assume that  > 0.

The inclusion of At in the definition of Ft-1 allows the noise to depend on past
choices, including the most recent action. This is often essential, as the case of Bernoulli rewards shows. We have now dropped the assumption that (At) t=1 are fixed in advance.

20.1 Martingales and the Method of Mixtures

255

The assumption that  > 0 ensures that Vt() is invertible and allows us to relax the requirement that the actions span Rd. Notice also that in this
section, we allow the interaction sequence to be infinitely long.

Since we want exponentially decaying tail probabilities, one is tempted to try the Cram´er­Chernoff method:

P

^t - 

2 Vt ()



u2

 inf E exp
>0



^t - 

2 Vt ()

-

u2

.

Sadly, we do not know how to bound this expectation. Can we still somehow use

the Cram´er­Chernoff method? We take inspiration from looking at the special

case of  = 0 one last time, assuming that Vt =

t s=1

AsAs

is invertible. Let

t
St = sAs .
s=1

Recall that ^t = Vt-1

t s=1

XsAs

=



+

Vt-1St.

Hence,

1 2

^t - 

2 Vt

=

1 2

St

2 Vt-1

=

max
xRd

x, St

-

1 2

x

2 Vt

.

The point of the second equality is to separate the martingale (St)t from Vt at
the price of the introduction of a maximum. This second equality is a special
case of (Fenchel) duality. As we shall see later in Chapter 26, for sufficiently nice convex functions f one can show that with an appropriate function f , for any x  Rd from the domain of f , f (x) = supuRd u, x - f (u). The advantage of this is that for any fixed u, x appears in a linear fashion.

The next lemma shows that the exponential of the term inside the maximum is a supermartingale even when  > 0.

Lemma 20.2. For all x  Rd the process Mt(x) = exp( x, St F-adapted non-negative supermartingale with M0(x)  1.

-

1 2

x

2 Vt

()

)

is

an

Proof of Lemma 20.2 That Mt(x) is Ft-measurable for all t and that it
is nonnegative are immediate from the definition. We need to show that E[Mt(x) | Ft-1]  Mt-1(x) almost surely. The fact that (t) is conditionally 1-subgaussian means that

E [exp (t x, At ) | Ft-1]  exp

x, At 2 2

= exp

x

2 At At

2

a.s.

20.1 Martingales and the Method of Mixtures

256

Hence

E[Mt(x) | Ft-1] = E exp

x, St

-

1 2

x

2 Vt

Ft-1

= Mt-1(x)E exp

t x, At

-

1 2

x

2 At At

 Mt-1(x) a.s.

Ft-1

Finally, note that M0(x)  1 is immediate.

For simplicity, consider now again the case when  = 0. Combining the lemma and the linearisation idea almost works. The Cram´er­Chernoff method leads to

P

1 2

^t - 

2 Vt



log(1/)

=P

exp

max
xRd

x, St

-

1 2

x

2 Vt

 E exp max
xRd

x, St

-

1 2

x

2 Vt

 1/

= E max Mt(x) .
xRd

(20.5)

Lemma 20.2 shows that E[Mt(x)]  1. This seems quite promising, but the presence of the maximum is a setback because E[maxxRd Mt(x)]  maxxRd E[Mt(x)], which is the wrong direction to be used above. This means we cannot directly use the lemma to bound Eq. (20.5). There are two ways to proceed. The first is to use a covering argument over possible near-maximisers of x, which eventually works. A more elegant way is to take inspiration from Eq. (20.5) and use Laplace's method for approximating integrals of well-behaved exponentials, as we now explain.

20.1.1

Laplace's Method ( )

We briefly review Laplace's method for one-dimensional functions. Assume that f : [a, b]  R is twice differentiable and has a unique maximum at x0  (a, b) with -q = f (x0) < 0. Laplace's method for approximating f (x0) is to compute
the integral

b
Is = exp(sf (x))dx
a

for some large value of s > 0. From a Taylor expansion, we may write

f (x)

=

f (x0)

-

q 2

(x

-

x0)2

+

R(x) ,

where R(x) = o((x - x0)2). Under appropriate technical assumptions,

b
Is  exp(sf (x0)) exp
a

-

sq(x

- 2

x0

)2

dx

as s   .

20.1 Martingales and the Method of Mixtures

257

1

1

s=1

s=3

0

-5

0

5

0

-5

0

5

Figure 20.1 The plots depict Laplace's approximation with f (x) = cos(x) exp(-x2/20), which is maximised at x0 = 0 and has q = -f (x0) = 11/10. The solid line is a plot of exp(sf (x))/ exp(sf (x0)), and the dotted line is exp(-sq(x - x0)2).

Furthermore, as s gets large,

b
exp
a

-

sq(x

- 2

x0

)2


dx  exp
-

-

sq(x

- 2

x0

)2

dx =

2 sq

and hence

Is  exp(sf (x0))

2 sq

.

It should also be clear that the fact that we integrate with respect to the Lebesgue measure does not matter much. We could have integrated with respect to any other measure as long as that measure puts a positive mass on the neighbourhood of the maximiser. The method is illustrated in Fig. 20.1. The take-home message is that if we integrate the exponential of a function that has a pronounced maximum, then we can expect that the integral will be close to the exponential function of the maximum.

20.1.2

Method of Mixtures Laplace's approximation suggests that

max
x

Mt(x)



Mt(x)dh(x) ,
Rd

(20.6)

where h is some measure on Rd chosen so that the integral can be calculated

in closed form. This is not a requirement of the method, but it does make the

argument shorter. The main benefit of replacing the maximum with an integral

is that we obtain the following lemma, which you will prove in Exercise 20.5.

Lemma 20.3. Let h be a probability measure on Rd; then, M¯t = is an F-adapted non-negative supermartingale with M¯0 = 1.

Rd Mt(x)dh(x)

20.1 Martingales and the Method of Mixtures

258

The following theorem is the key result from which the confidence set will be derived.

Theorem 20.4. For all  > 0 and   (0, 1),

P

exists t  N :

St

2 Vt ()-1



2 log

1 

+ log

det(Vt()) d

 .

The proof will be given momentarily. First, though, the implications.

Theorem 20.5. Let   (0, 1). Then, with probability at least 1 - , it holds that for all t  N,

^t - 

 Vt() < 



2+

2 log

1 

+ log

det Vt() d

.

Furthermore, if  2  m2, then P (exists t  N+ :  / Ct)   with

Ct =

  Rd :

^t-1 - 

 Vt-1() < m2  +

2 log

1 

+ log

det Vt-1() d

.

Proof We only have to compare St Vt()-1 and ^t -  Vt():

^t -  Vt() =  = 

Vt()-1St + (Vt()-1Vt - I) Vt() St Vt()-1 + ( (Vt()-1Vt - I)Vt()(Vt()-1Vt - I))1/2 St Vt()-1 + 1/2( (I - Vt()-1Vt))1/2 St Vt()-1 + 1/2  ,

and the result follows from Theorem 20.4.

Proof of Theorem 20.4 Let H = I  Rd×d and h = N (0, H-1) and

M¯ t = =

Mt(x)dh(x)
Rd
1
(2)d det(H-1)

exp
Rd

x, St

-

1 2

x

2 Vt

-

1 2

x

2 H

dx .

By Lemma 20.3, M¯t is a non-negative supermartingale, and thus the maximal inequality (Theorem 3.9) shows that

P

sup log(M¯t)  log
tN

1 

=P

sup M¯ t
tN



1 

 .

(20.7)

Now we turn to studying M¯t. Completing the square in the definition of M¯t we get

x, St

-

1 2

x

2 Vt

-

1 2

x

2 H

=

1 2

St

2 (H +Vt )-1

-

1 2

x - (H + Vt)-1St

2 H +Vt

.

The first term

St

2 (H +Vt )-1

does not depend on x and can be moved outside the

20.2 Notes

259

integral, which leaves a quadratic `Gaussian' term that may be integrated exactly and results in

M¯ t =

det(H ) det(H + Vt)

1/2
exp

1 2

St

2 (H +Vt )-1

.

(20.8)

The result follows by substituting this expression into Eq. (20.7) and rearranging.

20.2

Notes

1 Recall from the previous chapter that when At 2  L is assumed, then

det Vt() d



trace

Vt() d

d


1

+

nL2 d

d
.

(20.9)

In general, the log determinant form should be preferred when confidence intervals are used as part of an algorithm, but the right-hand side has a concrete form that can be useful when stating regret bounds.
2 Plugging the bounds of the previous note into Theorem 20.5 and choosing  = 1 gives the confidence set

Ct =

  Rd : ^t-1 -  Vt-1(1) < m2 +

2 log

1 

+ d log

1

+

nL2 d

.

The dependence of the radius on n, d and , up to constants and a log(n)

factor, is the same as what we got in the fixed design case (cf. Eq. (20.3)),

which suggests that Theorem 20.5 can be quite tight. By considering the case

when each basis vector {e1, . . . , ed} is played m times, then D =

^t - 

2 Vt

is distributed like a chi-squared distribution with d degrees of freedom. From

this, we see that the first term under the square root with the coefficient two

is stemming from variance of the noise, while the term that involved d log(n) is the bias (the expected value of D). In particular, this shows that the d

factor cannot be avoided.

3 If either of the above confidence sets is used (either the one from the theorem,

or that from Eq. (20.3)) to derive confidence bounds for the prediction error ^t - , x at some fixed x  Rd, we get a confidence width that scales with
d (e.g., Eq. (19.13)), unlike the confidence width in Eq. (20.2), which is

independent of d. It follows that if one is interested in high-probability bounds

for the mean at a fixed input x, one should avoid going through a confidence

set for the whole parameter vector. What this leaves open is whether a bound

like in Eq. (20.2) is possible at a fixed input x, but with a sequential design.

In Exercise 20.2 you will answer this question in the negative. First note that

when the actions are chosen using a fixed design, integrating Eq. (20.2) shows

20.3 Bibliographic Remarks

260

that

E[

^t - , x

2/

x

] 2
Vt-1

=

O(1).

In

the

exercise,

you

will

show

that

there

exists a sequential design such that

E

^t - , x

2/

x

2 Vt-1

= (d) ,



showing that for some sequential designs the factor d is necessary. It remains

an interesting open question to design confidence bounds for sequential design

for fixed x that adapts to the amount of dependence in the design.

4 Supermartingales arise naturally in proofs relying on the Cram´er­Chernoff

method. Just one example is the proof of Lemma 12.2. One could rewrite

most of the proofs involving sums of random variables relying on the Cram´er­

Chernoff method in a way that it would become clear that the proof hinges on

the supermartingale property of an appropriate sequence.

20.3

Bibliographic Remarks
Bounds like those given in Theorem 20.5 are called self-normalised bounds [de la Pen~a et al., 2008]. The method of mixtures goes back to the work by Robbins and Siegmund [1970]. In practice, the improvement provided by the method of mixtures relative to the covering arguments is quite large. A historical account of martingale methods in sequential analysis is by Lai [2009]. A simple proof of Lemma 20.1 appears as lemma 2.5 in the book by van de Geer [2000]. Calculating covering numbers (or related packing numbers) is a whole field by itself, with open questions even in the most obvious examples. The main reference is by Rogers [1964], which by now is a little old, but still interesting.

20.4

Exercises

20.1 (Lower bounds for fixed design) Let n = md for integer m and
A1, . . . , An be a fixed design where each basis vector in {e1, . . . , ed} is played exactly m times. Then let (t)tn=1 be a sequence of independent standard Gaussian random variables and Xt = , At + t. Finally, let ^n be the ordinary least squares estimator of   Rd. Show that

E

^n - 

2 Vn

= d.

This exercise shows that the d-dependence in Eq. (20.3) is unavoidable in general for a self-normalised bound, even in the fixed design setting.

20.2 (Lower bounds for sequential design) Let n  2d and (t)tn=1 be a sequence of independent standard Gaussian random variables. Find a sequence of

20.4 Exercises

261

random vectors (At)nt=1, with At  Rd such that Vn =

n t=1

At

At

is invertible

almost surely and At is (A1, 1, . . . , At-1, t-1)-measurable for all t and

E

^n, 1

2/

1

2 Vn-1

 cd ,

where c > 0 is a universal constant and Sn =

n t=1

tAt

and

^n

=

Vn-1Sn.

Hint Choose A1, . . . , Ad to be the standard basis vectors. Subsequently choose selected basis vectors adaptively to push the estimate of ^n, 1 away from zero.
For Exercise 20.4, where we ask you to prove Lemma 20.1, a few standard definitions will be useful.

Definition 20.6 (Covering and packing). Let A  Rd. A subset C  A is said to be an -cover of A if A  xCB(x, ), where B(x, ) = {y  Rd : x - y  } is the  ball centered at x. An -packing of A is a subset P  A such that for any x, y  P, x - y >  (note the strict inequality). The -covering number of A is N (A, ) = min{|C| : C is an -covering of A}, while the -packing number of A is M (A, ) = max{|P| : P is an -packing of A}, where we allow for both the covering and packing numbers to take on the value of +.

The definitions can be repeated for pseudo-metric spaces. Let X be a set and d : X × X  [0, ) be a function that is symmetric, satisfies the triangle inequality and for which d(x, x) = 0 for all x  X. Note that d(x, y) = 0 is allowed for distinct x and y, so d need not be a metric. The basic results concerning covering and packing stated in the next exercise remain valid with this more general definition. In applications we often need the logarithm of the covering and packing numbers, which are called the metric entropy of X at scale . As we shall see, these are often close no matter whether we consider packing or covering.

20.3 (Coverings and packings) Let A  Rd, B be the unit ball of Rd and vol(·) the usual volume (measure under the Lebesgue measure). For brevity let
N () = N (A, ) and M () = M (A, ). Show that the following hold:

(a)   N () is increasing as   0 is decreasing. (b) M (2)  N ()  M (). (c) We have

1 

d

vol(A) vol(B)



N ()



M ()



vol(A

+

 2

B)

vol(

 2

B)

()


vol(

3 2

A)

vol(

 2

B)



3 

d

vol(A) vol(B)

,

where () holds under the assumption that B  A and that A is convex and for U, V  Rd, c  R, U + V = {u + v : u  U , v  V } and cU = {cu : u  U };

20.4 Exercises

262

(d) Fix  > 0. Then N () < + if and only if A is bounded. The same holds for M ().

20.4 Use the results of the previous exercise to prove Lemma 20.1.

20.5 Prove Lemma 20.3.

Hint Use the `sections' lemma [Kallenberg, 2002, Lemma 1.26] to established that M¯t is Ft-measurable.
20.6 (Hoeffding­Azuma) Let X1, . . . , Xn be a sequence of random variables adapted to a filtration F = (Ft)t. Suppose that |Xt|  [at, bt] almost surely for arbitrary fixed sequences (at) and (bt) with at  bt for all t  [n]. Show that for any  > 0,

n

P

(Xt - E[Xt | Ft-1])  

t=1

 exp -

2n22

n t=1

(bt

-

at)2

.

Hint It may help to recall Hoeffding's lemma from Note 4 in Chapter 5, which states that for a random variable X  [a, b], the moment-generating function satisfies

MX ()  exp(2(b - a)2/8) .

20.7 (Extension of Hoeffding­Azuma) The following simple extension of Hoeffding­Azuma is often useful. Let n  N+ and (at) and (bt) be fixed
sequences with at  bt for all t  [n]. Let X1, . . . , Xn be a sequence of random variables adapted to a filtration F = (Ft)t and A be an event. Assume that P (exists t  [n] : A and Xt / [at, bt]) = 0 and  > 0, and show that

n
(a) P A  (Xt - E[Xt | Ft-1])  
t=1

 exp -

2n22

n t=1

(bt

-

at)2

.

(b) P

n
(Xt - E[Xt | Ft-1])  
t=1

 P (Ac) + exp -

2n22 nt=1(bt - at)2

.

The utility of this result comes from the fact that very often the range of some adapted sequence is itself random and could be arbitrarily large with low probability (when A does not hold). A reference for the above result is the survey by McDiarmid [1998].

20.8 Let   (0, 1) and F = (Ft)t=1 be a filtration and (Xt)t=1 be F-adapted such that
for all   R, E[exp(Xt) | Ft-1]  exp(22/2) a.s.

20.4 Exercises

263

Let Sn =

n t=1

Xt.

Show

that



P exists t : |St| 





22(t + 1) log

t2 + 1 

  .

20.9 (Law of the iterated logarithm and method of mixtures) This exercise uses the same notation as Exercise 20.8. Let f be a probability density function supported on [0, ) and

Mn =


f () exp
0

Sn

-

2n 2

d .

(a) Show that argmaxR Sn - 2n/2 = Sn/n. (b) Suppose that f () is decreasing for  > 0. Show that for any  > 0 and
n = Sn/n, that,

Mn  nf (n(1 + )) exp

(1 - 2)S2 2n

(c) Use the previous result to show that for any   (0, 1),

P

exists

n

:

Sn



inf
>0

2n (1 - 2)

log

1 

+ log

1 nf (n(1 + ))

(d) Find an f such that

 0

f ()d

=

1

and

f ()



0

for

all





R

and

log

1 f ()

= (1 + o(1)) log log

1 

as   0. (e) Use the previous results to show that

P lim sup

Sn

 1 = 1.

n 2n log log(n)

 .

The last part of the previous exercises is one-half of the statement of the law of iterated logarithm, which states that

lim sup

Sn

= 1 almost surely .

n 2n log log(n)

In other words, the magnitude of the largest fluctuations of the partial sum (Sn)n is almost surely of the order 2n log log n as n  .

20.10 Let F = (Ft)tn=0 be a filtration and X1, X2, . . . , Xn be a sequence of Fadapted random variables with Xt  {-1, 0, 1} and µt = E[Xt | Ft-1, Xt = 0],

20.4 Exercises

264

which we define to be zero whenever P (Xt = 0 | Ft-1) = 0. Then, with St =

t s=1

(Xs

-

µs|Xs|)

and

Nt

=

t s=1

|Xs|,







P exists t  n : |St| 

2Nt log

c Nt 

and Nt > 0   ,

where c > 0 is a universal constant.

This result appeared in a paper by the authors and others with the constant c = 4 2// erf( 2)  3.43 [Lattimore et al., 2018].

20.11 (Sequential likelihood ratios and confidence sets) Let (, G)

be a measurable space and (P :   ) be a probability kernel from (, G) to (R, B(R)). Assume there exists a common measure µ such that P µ for

all   , and let {p :   } be a family of densities with p = dP/dµ.

You may assume that p(x) is jointly measurable in  and x. Such a choice

is guaranteed to exist, as we explain in Note 8 at the end of Chapter 34.

Fix    and let (Xt)t=1 be a sequence of independent random variables

with law P . Let ^t   be (X1, . . . , Xt)-measurable. For   , define

Lt() =

t s=1

log(p^s-1

(Xs)/p

(Xs)).

(a) Show that P supt1 Lt()  log(1/)   for any   (0, 1).

(b) Show that t = { : Lt() < log(1/)} is a sequence of confidence sets such that P (exists t  N such that   t)  .

(c) Let  = R and G = B(R) and P = N (0, ) and µ be the Lebesgue measure.

Then

let

^t

=

0

for

t

=

0

and

1 t

t s=1

Xs

otherwise.

Write

an

expression

for Ct, and investigate how it compares to the usual confidence intervals for

Gaussian random variables.

Hint Use Cram´er­Chernoff method and observe that (exp(Lt()))t=1 is a martingale.

The quantities p (Xs)/p(Xs) are called likelihood ratios. That the product of likelihood ratios forms a martingale is a cornerstone result of classical parametric statistics. The sequential form that appears in the above exercise is based on lemma 2 of Lai and Robbins [1985], who cite Robbins and Siegmund [1972] as the original source.

21 Optimal Design for Least Squares Estimators

In the preceding chapter, we showed how to construct confidence intervals for least squares estimators when the design is chosen sequentially. We now study the problem of choosing actions for which the resulting confidence sets are small. This plays an important role in the analysis of stochastic linear bandits with finitely many arms (Chapter 22) and adversarial linear bandits (Part VI).

21.1

The Kiefer­Wolfowitz Theorem

Let 1, . . . , n be a sequence of independent 1-subgaussian random variables and

a1, . . . , an  Rd be a fixed sequence with span(a1, . . . , an) = Rd and X1, . . . , Xn

be given by Xt = , at + t for some   Rd. The least squares estimator of

 is ^ = V -1

n t=1

atXt

with V

=

n t=1

at

at

.

The least squares estimator used here is not regularised. This eases the calculations, and the lack of regularisation will not harm us in future applications.

Eq. (20.2) from Chapter 20 shows that for any a  Rd and   (0, 1),

P

^ - , a 

2

a

2 V

-1

log

1 

 .

(21.1)

For our purposes, both a1, . . . , an and a will be actions from some (possibly infinite) set A  Rd and the question of interest is finding the shortest sequence of exploratory actions a1, . . . , an such that the confidence bound in the previous display is smaller than some threshold for all a  A. To solve this exactly
is likely an intractable exercise in integer programming. Finding an accurate
approximation turns out to be efficient for a broad class of action sets, however. Let  : A  [0, 1] be a distribution on A so that aA (a) = 1 and V ()  Rd×d and g()  R be given by

V () = (a)aa ,
aA

g() = max
aA

a

2 V

()-1

.

(21.2)

21.1 The Kiefer­Wolfowitz Theorem

266

In the subfield of statistics called optimal experimental design, the distribution  is called a design, and the problem of finding a design that minimises g is called the G-optimal design problem. So how to use this? Suppose that  is a design and a  Supp() and

na =

(a)g() 2

log

1 

.

(21.3)

Then, choosing each action a  Supp() exactly na times ensures that

V=

naaa



g() 2

log

1 

V () ,

aSupp()

which by Eq. (21.1) means that for any a  A, with probability 1 - ,

^ - , a 

2

a

2 V

-1

log

1 

 .

By Eq. (21.3), the total number of actions required to ensure a confidence width of no more than  is bounded by

n=

na =

(a)g() 2

log

1 

aSupp()

aSupp()



|

Supp()|

+

g() 2

log

1 

.

The set Supp() is sometimes called the core set. The following theorem characterises the size of the core set and the minimum of g.

Theorem 21.1 (Kiefer­Wolfowitz). Assume that A  Rd is compact and span(A) = Rd. The following are equivalent:

(a)  is a minimiser of g. (b)  is a maximiser of f () = log det V (). (c) g() = d.
Furthermore, there exists a minimiser  of g such that | Supp()|  d(d + 1)/2.

A design that maximises f is known as a D-optimal design, and thus the theorem establishes the equivalence of G-optimal and D-optimal designs.

Proof We give the proof for finite A. The general case follows by passing to the
limit (Exercise 21.3). When it is convenient, distributions  on A are treated as vectors in R|A|. You will show in Exercises 21.1 and 21.2 that f is concave and that

(f ())a =

a

2 V

()-1

.

(21.4)

Also notice that

(a)

a

2 V ()-1

= trace

(a)aa V ()-1 = trace(I) = d .

aA

a

(21.5)

21.1 The Kiefer­Wolfowitz Theorem

267

(b)(a): Suppose that  is a maximiser of f . By the first-order optimality criterion (see Section 26.5), for any  distribution on A,

0  f (),  - 

=

(a)

a

- 2
V ()-1

(a)

a

2 V ()-1

aA

aA

=

(a)

a

2 V ()-1

-

d.

aA

For an arbitrary a  A, choosing  to be the Dirac at a  A proves that

a

2 V ()-1

 d. Hence g()  d. Since g()  d for all 

by Eq. (21.5), it follows

that  is a minimiser of g and that min g() = d. (c) = (b): Suppose that

g() = d. Then, for any ,

f (),  -  =

(a) a V ()-1 - d  0 .

aA

And it follows that  is a maximiser of f by the first-order optimality conditions

and the concavity of f . That (a) = (c) is now trivial. To prove the second part of the theorem, let  be a minimiser of g, which by the previous part is a maximiser of f . Let S = Supp(), and suppose that |S| > d(d + 1)/2. Since the

dimension of the subspace of d × d symmetric matrices is d(d + 1)/2, there must be a non-zero function v : A  R with Supp(v)  S such that

v(a)aa = 0 .

(21.6)

aS

Notice that for any a  S, the first-order optimality conditions ensure that

a

2 V ()-1

=d

(Exercise

21.5).

Hence

d

v(a) =

v(a)

a

2 V ()-1

= 0,

aS

aS

where the last equality follows from Eq. (21.6). Let (t) =  + tv and let

 = max{t > 0 : (t)  PA}, which exists since v = 0 and aS v(a) = 0 and Supp(v)  S. By Eq. (21.6), V ((t)) = V (), and hence f (( )) = f (),

which means that ( ) also maximises f . The claim follows by checking that | Supp((T ))| < | Supp()| and then using induction.

Geometric Interpretation

There is a geometric interpretation of the D-optimal design problem. Let  be a

D-optimal design for A and V = aA (a)aa and

E=

x  Rd :

x

2 V -1

d

,

which is a centered ellipsoid. By Theorem 21.1, it holds that A  E with the core set lying on the boundary (see Fig. 21.1). As you might guess from the figure, the ellipsoid E is the minimum volume centered ellipsoid containing A. This is known to be unique and the optimisation problem that characterises it is in fact the dual of the log determinant problem that determines the D-optimal design.

21.2 Notes

268

Figure 21.1 The minimum volume centered ellipsoid containing a point cloud. The points

on the boundary are the core set. The ellipse is E = {x :

x

2 V ()-1

= d}, where 

is an

optimal design.

21.2

Notes

1 The letter `d' in D-optimal design comes from the determinant in the objective. The `g' in G-optimal design stands for `globally optimal'. The names were coined by Kiefer and Wolfowitz, though both problems appeared in the literature before them.
2 In applications we seldom need an exact solution to the design problem. Finding a distribution  such that g()  (1 + )g() will increase the regret of our algorithms by a factor of just (1 + )1/2.
3 The computation of an optimal design for finite action sets is a convex problem for which there are numerous efficient approximation algorithms. The Frank­ Wolfe algorithm is one such algorithm, which can be used to find a near-optimal solution for modestly sized problems. The algorithm starts with an initial 0 and updates according to

k+1(a) = (1 - k)k(a) + kI {ak = a} ,

(21.7)

where ak = argmaxaA

a

2 V (k)-1

and

the

step

size

is

chosen

to

optimise

f

along the line connecting k and ak .

k = argmax[0,1] f ((1 - )k + ak ) =

1 d

ak ak

2 V (k)-1

-

1

2 V (k)-1

-

1

.

(21.8)

If 0 is chosen to be the uniform distribution over A, then the number of iterations before g(k)  (1 + )g() is at most O(d log log |A| + d/). For a slightly more sophisticated choice of initialisation the dependence on |A| can
be eliminated entirely. More importantly, this other initialisation has a core
set of size O(d) and running the algorithm in Eq. (21.7) for just O(d log log d) iterations is guaranteed to produce a design with g()  2g() and a core set
of size O(d log log d).

21.3 Bibliographic Remarks

269

4 If the action set is infinite, then approximately optimal designs can sometimes still be found efficiently. Unfortunately the algorithms in the infinite case tend to be much `heavier' and less practical.
5 The smallest ellipsoid containing some set K  Rd is called the minimum volume enclosing ellipsoid (MVEE) of K. As remarked, the D-optimal design problem is equivalent to finding an MVEE of A with the added constraint that the ellipsoid must be centred ­ or equivalently, finding the MVEE of the symmetrised set A  {-a : a  A}. The MVEE of a convex set is also called John's ellipsoid, which has many applications in optimisation and beyond.
6 In Exercise 21.6, you will generalise Kiefer­Wolfowitz theorem to sets that do not span Rd. When A is compact and dim(span(A)) = m  [d], then there exists a distribution  supported on at most m(m + 1)/2 points of A and for which g() = m = inf g().

21.3

Bibliographic Remarks
The Kiefer­Wolfowitz theorem is due to Kiefer and Wolfowitz [1960]. The algorithm in Note 3 is due to Fedorov [1972]. A similar variant was also proposed by Wynn [1970], and the name Wynn's method is sometimes used. The algorithm is a specialisation of Frank­Wolfe's algorithm, which was originally intended for quadratic programming [Frank and Wolfe, 1956]. Todd [2016] wrote a nice book about minimum volume ellipsoids and related algorithms, where you can also find many more references and improvements to the basic algorithms. Chapter 3 of his book also includes discussion of alternative initialisations and convergence rates for various algorithms. The duality between D-optimal design and the MVEE problem was shown by Silvey and Sibson [1972]. Although the connection between minimum volume ellipsoids and experimental design is well known, previous applications of these results to bandits used John's theorem without appropriate symmetrisation, which made the resulting arguments more cumbersome. For more details on finding approximately optimal designs for infinite sets, see the article by Hazan et al. [2016], references there-in and the book by Gro¨tschel et al. [2012].

21.4

Exercises
21.1 (Derivative of log determinant) Prove the correctness of the derivative in Eq. (21.4).
Hint For square matrix A let adj(A) be the transpose of the cofactor matrix of A. Use the facts that the inverse of a matrix A is A-1 = adj(A) / det(A) and

21.4 Exercises

270

that if A : R  Rd×d, then

d dt

det(A(t))

=

trace

adj(A)

d dt

A(t)

.

21.2 (Concavity of log determinant) Prove that H  log det(H) is concave where H is a symmetric, positive definite matrix.

Hint Consider t  log det(H + tZ) for Z symmetric, and show that this is a concave function.
21.3 (Kiefer­Wolfowitz for compact sets) Generalise the proof of Theorem 21.1 to compact action sets.

21.4 Prove the second inequality in Eq. (21.8).

21.5 Let  be a G-optimal design and a  Supp(). Prove that

a

2 V ()-1

= d.

21.6 Prove that if A is compact and dim(span(A)) = m  [d], then there exists a distribution  over A supported on at most m(m + 1)/2 points and for which g() = m.

21.7 (Implementation) Write a program that accepts as parameters a finite set A  Rd and returns a design  : A  [0, 1] such that g()  d +  for some given  > 0. How robust is your algorithm? Experiment with different choices of
A and d, and report your results.

Hint The easiest pure way to do this is to implement the Frank­Wolfe algorithm described in Note 3. All quantities can be updated incrementally using rank-one update formulas, and this will lead to a significant speedup. You might like to read the third chapter of the book by Todd [2016] and experiment with the proposed variants.

22 Stochastic Linear Bandits with Finitely Many Arms

The optimal design problem from the previous chapter has immediate applications to stochastic linear bandits. In Chapter 19, we developed a linear version of the upper confidence bound algorithm that achieves a regret of Rn = O(d n log(n)). The only required assumptions were that the sequence of available action sets were bounded. In this short chapter, we consider a more restricted setting where:
1 the set of actions available in round t is A  Rd and |A| = k for some natural number k;
2 the reward is Xt = , At + t where t is conditionally 1-subgaussian:
E[exp(t)|A1, 1, . . . , At-1]  exp(2/2) almost surely for all   R; and
3 the suboptimality gaps satisfy a = maxbA , b - a  1 for all a  A.
The key difference relative to Chapter 19 is that now the set of actions is finite and does not change with time. Under these conditions, it becomes possible to design a policy such that

Rn = O dn log(nk) .

For moderately sized k, this bound improves the regret by a factor of d1/2, which in some regimes is large enough to be worth the effort. The policy is an instance of phase-based elimination algorithms. As usual, at the end of a phase, arms that are likely to be suboptimal with a gap exceeding the current target are eliminated. In fact, this elimination is the only way the data collected in a phase is being used. In particular, the actions to be played during a phase are chosen based entirely on the data from previous phases: the data collected in the present phase do not influence which actions are played. This decoupling allows us to make use of the tighter confidence bounds available in the fixed design setting, as discussed in the previous chapter. The choice of policy within each phase uses the solution to an optimal design problem to minimise the number of required samples to eliminate arms that are far from optimal.

Theorem 22.1. With probability at least 1 - , the regret of Algorithm 12 satisfies

Rn  C

nd log

k log(n) 

,

22.1 Notes

272

Input A  Rd and  Step 0 Set = 1 and let A1 = A Step 1 Let t = t be the current timestep and find G-optimal design   P(A )
with Supp( )  d(d + 1)/2 that maximises

log det V ( ) subject to

 (a) = 1

aA

Step 2 Let  = 2- and

T (a) =

2d (a) 2

log

k ( + 1) 

and T = T (a)
aA

Step 3 Choose each action a  A exactly T (a) times Step 4 Calculate the empirical estimate:

t +T

^ = V -1

AtXt with V =

T (a)aa

t=t

aA

Step 5 Eliminate low rewarding arms:

A +1 =

a  A : max ^ , b - a  2
bA

.

Step 6  + 1 and Goto Step 1

Algorithm 12: Phased elimination with G-optimal exploration.

where C > 0 is a universal constant. If  = O(1/n), then E[Rn]  C nd log(kn) for an appropriately chosen universal constant C > 0.
The proof of this theorem follows relatively directly from the high-probability correctness of the confidence intervals used to eliminate low-rewarding arms. We leave the details to the reader in Exercise 22.1.

22.1

Notes

1 The assumption that the action set does not change is crucial for Algorithm 12. Several complicated algorithms have been proposed and analysed for the case where At is allowed to change from round to round under the assumption that |At|  k for all rounds. For these algorithms, it has been proven that

Rn = O nd log3(nk) .

(22.1)

When k is small, these results improve on the bound for LinUCB in Chapter 19 by a factor of up to d. 2 Algorithm 12 can be adapted to the case where k is infinite by using confidence

22.2 Bibliographic Remarks

273

intervals derived in Chapter 20. Once the dust has settled, you should find the regret is
Rn = O d n log(n) .
3 One advantage of Algorithm 12 is that it behaves well even when the linear model is misspecified. Suppose the reward is Xt = , At + t + f (At), where t is noise as usual and f : A  R is some function with f   . Then the regret of Algorithm 12 can be shown to be  Rn = O dn log(nk) + n d log(n) .
The linear dependence on the horizon should be expected when k is large. The presence of d in the second term is unfortunate, but unavoidable in many regimes as discussed by Lattimore and Szepesv´ari [2019b].

22.2

Bibliographic Remarks

The algorithms achieving Eq. (22.1) for changing action sets are SupLinRel [Auer,

2002] and SupLinUCB [Chu et al., 2011]. Both introduce phases to decouple

the dependence of the design on the outcomes. Unfortunately the analysis of

these algorithms is long and technical, which prohibited us from presenting

the ideas here. These algorithms are also not the most practical relative to

LinUCB (Chapter 19) or Thompson sampling (Chapter 36). Of course this does

not diminish the theoretical breakthrough. Phased elimination algorithms have

appeared in many places, but the most similar to the algorithm presented here

is the work on spectral bandits by Valko et al. [2014] (and we have also met

them briefly in earlier chapters on finite-armed bandits). None of the works just

mentioned used the Kiefer­Wolfowitz theorem. This idea is apparently new, but

it is based on the literature on adversarial linear bandits where John's ellipsoid

has been used to define exploration policies [Bubeck et al., 2012]. For more details

on adversarial linear bandits, read on to Part VI.

Ghosh et al. [2017] address misspecified (stochastic) linear bandits with a fixed

action set. In misspecified linear bandits, the reward is nearly a linear function of

the feature vectors associated with the actions. Ghosh et al. [2017] demonstrate

that in the favourable case when one can cheaply test linearity, an algorithm

that first runs a test bandit based on the

and then outcome

switches to either will achieve ( k

a 

linear d) n

bandit or regret up

a finite-armed to log factors.

We will return to misspecified linear bandits a few more times in the book.

22.3

Exercises
22.1 In this exercise, you will prove Theorem 22.1.

22.3 Exercises

274

(a) Use Theorem 21.1 to show that the length of the th phase is bounded by

T



2d 2

log

k ( + 1) 

+

d(d + 2

1)

.

(b) Let a  argmaxaA , a be the optimal arm and use Theorem 21.1 to show that

P (exists phase

such

that

a

/

A

)



 k

.

(c) For action a define a = min{ : 2 < a} to be the first phase where the suboptimality gap of arm a is smaller than 2 . Show that

P (a



A

a)



 k

.

(d) Show that with probability at least 1 -  the regret is bounded by

Rn  C

dn log

k log(n) 

,

where C > 0 is a universal constant. (e) Show that this implies Theorem 22.1 for the given choice of .

22.2 (Misspecified linear bandits) Assume the reward satisfies Xt = , At + t + f (At), where t is 1-subgaussian noise as usual and f : A  R is some function with f   , show that the expected regret of Algorithm 12
with the choice  = 1/n is
 Rn = O dn log(nk) + n d log(n) .

23 Stochastic Linear Bandits with Sparsity

In Chapter 19 we showed the linear variant of UCB has regret bounded by 
Rn = O(d n log(n)) ,
which for fixed finite action sets can be improved to
Rn = O( dn log(nk)) .
For moderately sized action sets, these approaches lead to a big improvement over what could be obtained by using the policies that do not make use of the linear structure.
The situation is still not perfect, though. In typical applications, the features are chosen by the user of the system, and one can easily imagine there are many candidate features and limited information about which will be most useful. This presents the user with a challenging trade-off. If they include many features, then d will be large, and the algorithm may be slow to learn. But if a useful feature is omitted, then the linear model will almost certainly be quite wrong. Ideally, one should be able to add features without suffering much additional regret if the added feature does not contribute in a significant way. This can be captured by the notion of sparsity, which is the central theme of this chapter.

23.1

Sparse Linear Stochastic Bandits

Like in the standard stochastic linear bandit setting, at the beginning of round t, the learner receives a decision set At  Rd. They then choose an action At  At and receive a reward

Xt = , At + t ,

(23.1)

where (t)t is zero-mean noise and   Rd is an unknown vector. The only
difference in the sparse setting is that the parameter vector  is assumed to have many zero entries. For   Rd let

d
 0 = I {i = 0} ,
i=1

which is sometimes called the zero-`norm' (quotations because it is not really a norm; see Exercise 23.1).

23.2 Elimination on the Hypercube

276

Assumption 23.1. The following hold:
(a) (Sparse parameter) There exist known constants m0 and m2 such that  0  m0 and  2  m2.
(b) (Bounded mean rewards) , a  1 for all a  At and all rounds t. (c) (Subgaussian noise) The noise is conditionally 1-subgaussian:
for all   R, E[exp(t) | Ft-1]  exp(2/2) a.s. ,
where Ft = (A1, X1, . . . , At, Xt, At+1).
Much ink has been spilled on what can be said about the speed of learning in linear models like (23.1) when (At)t are passively generated and the parameter vector is known to be sparse. Most results are phrased about recovering , but there also exist a few results that quantify the error when predicting Xt. The ideal outcome would be that the learning speed depends mostly on m0, with only a mild dependence on d. Almost all the results come under the assumption that the covariance matrix of the actions (At)t is well conditioned.
The condition number of a positive definite matrix A is the ratio of its largest and smallest eigenvalues. A matrix is well conditioned if it has a small condition number.
The details are a bit more complicated than just the conditioning, but the main point is that the usual assumptions imposed on the covariance matrix of the actions for passive learning are never satisfied when the actions are chosen by a good bandit policy. The reason is simple. Bandit algorithms want to choose the optimal action as often as possible, which means the covariance matrix will have an eigenvector that points (approximately) towards the optimal action with a large corresponding eigenvalue. We need some approach that does not rely on such strong assumptions.

23.2

Elimination on the Hypercube

As a warm-up, consider the case where the action set is the d-dimensional

hypercube: At = A = [-1, 1]d. To reduce clutter, we denote the true parameter

vector by  = . The hypercube is notable as an action set because it enjoys

perfect separability. For each dimension i  [d], the value of Ati  [-1, 1] can

be chosen independently of Atj for j = i. Because of this, the optimal action is a = sign(), where
 1 , if i > 0 ;

sign()i = sign(i) = 0-,1 ,

if i = 0 ; if i < 0 .

23.2 Elimination on the Hypercube

277

So learning the optimal action amounts to learning the sign of i for each

dimension. A disadvantage of this structure is that in the worst case the sign

of each i must be learned independently, which in Chapter 24 we show leads to a worst-case regret of Rn = (d n). On the positive side, the seperability

means that i can be estimated in each dimension independently while paying

absolutely no price for this experimentation when i = 0. It turns out that this allows us to design a policy for which Rn = O(  0 n), even without knowing

the value of  0.

Let Gt = (A1, X1, . . . , At, Xt) be the -algebra containing information up to
time t - 1 (this differs from Ft, which also includes information about the action chosen). Now suppose that (Ati)id=1 are chosen to be conditionally independent given Gt-1, and further assume for some specific i  [d] that Ati is sampled from a Rademacher distribution so that P (Ati = 1 | Gt-1) = P (Ati = -1 | Gt-1) = 1/2.

Then







d

E[AtiXt | Gt-1] = E Ati  Atj j + t Gt-1

j=1

= iE[At2i | Gt-1] + j E[Atj Ati | Gt-1] + E[Atit | Gt-1]
j=i

= i ,

where the first equality is the definition of Xt = , At +t, the second by linearity of expectation and the third by the conditional independence of (Ati)i and the fact that E[Ati | Gt-1] = 0 and E[A2ti | Gt-1] = 1. This looks quite promising, but we should also check the variance. Using our assumptions that (t) is conditionally 1-subgaussian and that , a  1 for all actions a, we have
V[AtiXt | Gt-1] = E[A2tiXt2 | Gt-1] - i2 = E[( , At + t)2 | Gt-1] - i2  2 . (23.2)

And now we have cause for celebration. The value of i can be estimated by choosing Ati to be a Rademacher random variable independent of the choices in other dimensions. All the policy does is treat all dimensions independently. For a particular dimension (say i), it explores by choosing Ati  {-1, 1} uniformly at random until its estimate is sufficiently accurate to commit to either Ati = 1 or Ati = -1 for all future rounds. How long this takes depends on |i|, but note that if |i| is small, then the price of exploring is also limited. The policy that results from this idea is called selective explore-then-commit (Algorithm 13, SETC).

Theorem 23.2. There exists a universal constants C, C > 0 such that the regret of SETC satisfies

Rn  3



1

+

C

i:i =0

log(n) |i|

and

Rn  3  1 + C  0 n log(n) .

By appealing to the central limit theorem and the variance calculation in

23.2 Elimination on the Hypercube

278

1: Input n and d

2: Set E1i = 1 and C1i = R for all i  [d]

3: for t = 1, . . . , n do

4: For each i  [d] sample Bti  Rademacher

5: Choose action:  Bti if 0  Cti

(i)

Ati = -1 1

if Cti  (0, ] if Cti  [-, 0) .

6: Play At and observe Xt 7: Construct empirical estimators:

t
(i) Ti(t) = Esi
s=1

^ti =

8: Construct confidence intervals:

t s=1

EsiAsi

Xs

Ti(t)

(i)

Wti = 2

1 Ti(t)

+

1 Ti(t)2

log n

2Ti(t) + 1

(i)

Ct+1,i = ^ti - Wti, ^ti + Wti

9: Update exploration parameters:

(i)

Et+1,i =

0 1

if 0 / Ct+1,i or Eti = 0 otherwise .

10: end for

Algorithm 13: Selective explore-then-commit.

Eq. (23.2), we should be hopeful that the confidence intervals used by the algorithm are sufficiently large to contain the true i with high probability, but this still needs to be proven.
Lemma 23.3. Define i = n  max{t : Eti = 1}, and let Fi = I {i / Ci+1,i} be the event that i is not in the confidence interval constructed at time i. Then P (Fi)  1/n.
The proof of Lemma 23.3 is left until after the proof of Theorem 23.2.
Proof of Theorem 23.2 Recalling the definition of the regret and using the fact that the optimal action is a = sign(), we have the following regret

23.2 Elimination on the Hypercube

279

decomposition:

n

d

n

Rn

=

max
aA

, a

-E

, At =

n|i| - E

Atii .

t=1

i=1

t=1

Rni

(23.3)

Clearly, if i = 0, then Rni = 0. And so it suffices to bound Rni for each i with |i| > 0. Suppose that |i| > 0 for some i and the failure event Fi given in Lemma 23.3 does not occur. Then i  Ci+1,t, and by the definition of the algorithm, Ati = sign(i) for all t  i. Therefore,

n

n

Rni = n|i| - E

Atii = E

|i| (1 - Ati sign(i))

t=1

t=1

 2n|i|P (Fi) + |i|E [I {Fic} i] .

(23.4)

Since i is the first round t when 0 / Ct+1,i it follows that if Fi does not occur, then i  Ci,i and 0  Ci,i. Thus the width of the confidence interval Ci,i must be at least |i|, and so

2Wi-1,i = 4

i

1 -

1

+

(i

1 -

1)2

 log n 2i - 1  |i| ,

which after rearranging shows for some universal constant C > 0 that

I

{Fic}

(i

-

1)



1

+

C

log(n) i2

.

Combining this result with Eq. (23.4) leads to

Rni



2n|i|P

(Fi)

+

|i|

+

C

log(n) |i|

.

Using Lemma 23.3 to bound P (Fi) and substituting into the decomposition Eq. (23.3) completes the proof of the first part. The second part is left as a treat
for you (Exercise 23.2).

Proof of Lemma 23.3 Let Sti = j=i Atjj and Zti = Atit +AtiSti. For t  i,

^ti

-

i

=

1 t

t

Zsi .

s=1

23.3 Online to Confidence Set Conversion

280

 The next step is to show that Zti is conditionally 2-subgaussian for t  i:

E [exp(Zti) | Gt-1] = E [E [exp(Zti) | Ft-1] | Gt-1]

= E [exp(AtiSti)E [exp(Atit) | Ft-1] | Gt-1]

 E exp(AtiSti) exp

2 2

Gt-1

= exp

2 2

E [E [exp(AtiSti) | Gt-1, Sti] | Gt-1]

 exp

2 2

E exp

2St2i 2

Gt-1

 exp(2) .

The first inequality used the fact that t is conditionally 1-subgaussian. The secondto-last inequality follows because Ati is conditionally Rademacher for t  i, which is 1-subgaussian by Hoeffding's lemma (5.11). The final inequality follows because Sti  At   1  1. The result follows by applying the concentration bound from Exercise 20.8.

23.3

Online to Confidence Set Conversion
A new plan is needed to relax the assumption that the action set is a hypercube. The idea is to modify the ellipsoidal confidence set used in Chapter 19 to have a smaller radius. We will see that modifying the algorithm in Chapter 19 to use the smaller confidence intervals improves the regret to Rn = O( dpn log(n)).
Without assumptions on the action set, one cannot hope to have a regret smaller than O( dn). To see this, recall that d-armed bandits can be represented as linear bandits with At = {e1, . . . , ed}. For these problems, Theorem 15.2 shows that for any policy there exists a d-armed bandit for which Rn = ( dn). Checking the proof reveals that when adapted to the linear setting the parameter vector is 2-sparse.

The construction that follows makes use of a kind of duality between online prediction and confidence sets. While we will only apply the idea to the sparse linear case, the approach is generic.
The prediction problem considered is online linear prediction under the squared loss. This is also known as online linear regression. The learner interacts with an environment in a sequential manner where in each round t  N+:
1 The environment chooses Xt  R and At  Rd in an arbitrary fashion. 2 The value of At is revealed to the learner (but not Xt).

23.3 Online to Confidence Set Conversion

281

3 The learner produces a real-valued prediction X^t  R in some way. 4 The environment reveals Xt to the learner and the loss is (Xt - X^t)2.

The regret of the learner relative to a linear predictor that uses the weights   Rd is

n

n

n() = (Xt - X^t)2 - (Xt - , At )2 .

t=1

t=1

(23.5)

We say that the learner enjoys a regret guarantee Bn relative to   Rd if for any strategy of the environment,

sup n()  Bn .


(23.6)

The online learning literature has a number of powerful techniques for this learning problem. Later we will give a specific result for the sparse case when  = {x : x 0  m0}, but first we show how to use such a learning algorithm to construct a confidence set. Take any learner for online linear regression, and assume the environment generates Xt in a stochastic manner like in linear bandits:

Xt = , At + t .

(23.7)

Combining Eqs. (23.5) to (23.7) with elementary algebra,

n

n

Qt = (X^t - , At )2 = n() + 2 t(X^t - , At )

t=1

t=1

n
 Bn + 2 t(X^t - , At ) ,

t=1

(23.8)

where the first equality serves as the definition of Qt. Let us now take stock for a moment. If we could somehow remove the dependence on the noise t in the righthand side, then we could define a confidence set consisting of all  that satisfy

the equation. Of course the noise has zero mean and is conditionally independent

of its multiplier, so the expectation of this term is zero. The fluctuations can be

controlled with high probability using a little concentration analysis. Let

t
Zt = s(X^s - , As ) .
s=1
Since X^t is chosen based on information available at the beginning of the round, X^t is Ft-1-measurable, and so

for all   R,

E[exp((Zt - Zt-1)) | Ft-1]  exp(2t2/2) ,

where t2 = (X^t - , At )2. The uniform self-normalised tail bound (Theorem 20.4) with  = 1 implies that,

P exists t  0 such that |Zt| 

(1 + Qt) log

1 + Qt 2

 .

23.3 Online to Confidence Set Conversion

282

Provided this low-probability event does not occur, then from Eq. (23.8) we have

Qt  Bt + 2

(1 + Qt) log

1 + Qt 2

.

(23.9)

While both sides depend on Qt, the left-hand side grows linearly, while the

right-hand side grows sublinearly in Qt. This means that the largest value of Qt

that satisfies the above inequality is finite. A tedious calculation then shows this

value must be less than



t() = 1 + 2Bt + 32 log

8 + 1 + Bt 

.

(23.10)

By piecing together the parts, we conclude that with probability at least 1 -  the following holds for all t:

t
Qt = (X^s - , As )2  t() .
s=1

We could define Ct+1 to be the set of all  such that the above holds with 

replaced by , but there is one additionally subtlety, which is that the resulting

confidence interval may be unbounded (think about the case that

t s=1

As

As

is

not invertible). In Chapter 19 we overcame this problem by regularising the least

squares estimator. Since we have assumed that  2  m2, the previous display

implies that

t



2 2

+

(X^s - , As )2  m22 + t() .

s=1

All together, we have the following theorem:

Theorem 23.4. Let   (0, 1) and assume that    and sup t()  Bt. If

t

Ct+1 =

  Rd :



2 2

+

(X^s - , As )2  m22 + t() ,

s=1

then P (exists t  N such that   Ct+1)   .

The confidence set in Theorem 23.4 is not in the most convenient form. By

defining Vt = I +

t s=1

AsAs

and St =

t s=1

As

X^s

and

^t

=

Vt-1St

and

performing an algebraic calculation that we leave to the reader (see Exercise 23.5),

one can see that

t

t



2 2

+

(X^s -

, As )2 =

 - ^t

2 Vt

+

(X^s -

^t, As )2 +

^t

2 2

.

(23.11)

s=1

s=1

Using this, the confidence set can be rewritten in the familiar form of an ellipsoid:

t

Ct+1 =

  Rd :

 - ^t

2 Vt

 m22 + t() -

^t

2 2

-

(X^s2 - ^t, As )2 .

s=1

23.4 Sparse Online Linear Prediction

283

1: Input Online linear predictor and regret bound Bt, confidence parameter   (0, 1)
2: for t = 1, . . . , n do 3: Receive action set At 4: Computer confidence set:

Ct =

  Rd :

t-1



2 2

+

(X^s - , As )2  m22 + t()

s=1

5: Calculate optimistic action

At

=

argmaxaAt

max
Ct

, a

6: Feed At to the online linear predictor and obtain prediction X^t 7: Play At and receive reward Xt 8: Feed Xt to online linear predictor as feedback 9: end for

Algorithm 14: Online linear predictor UCB (OLR-UCB).

It is not obvious that Ct+1 is not empty because the radius could be negative. Theorem 23.4 shows, however, that with high probability   Ct+1. At last we have established all the conditions required for Theorem 19.2, which implies the following theorem bounding the regret of Algorithm 14:

Theorem 23.5. With probability at least 1 -  the pseudo-regret of OLR-UCB satisfies

R^n 

8dn (m22 + n-1()) log

1

+

n d

.

23.4

Sparse Online Linear Prediction

Theorem 23.6. There exists a strategy  for the learner such that for any   Rd, the regret n() of  against any strategic environment such that maxt[n] At 2  L and maxt[n] |Xt|  X satisfies

n()  cX2  0

log(e + n1/2L) + Cn log

1+

1 0

+ (1 + X2)Cn ,

where c > 0 is some universal constant and Cn = 2 + log2 log(e + n1/2L).

Note that Cn = O(log log(n)), so by dropping the dependence on X and L, we have

sup

n() = O(m0 log(n)) .

:  0m0,  2L

As a final catch, the rewards (Xt) in sparse linear bandits with subgaussian noise

23.5 Notes

284

are not necessarily bounded. However, the subgaussian property implies that with probability 1 - , |t|  log(2/). By choosing  = 1/n2 and Assumption 23.1,
we have

P max |Xt|  1 + log 2n2
t[n]



1 n

.

Putting all the pieces together shows that the expected regret of OLR-UCB when using the predictor provided by Theorem 23.6 and when  0  m0 satisfies

Rn = O dnm0 log(n)2 .

23.5 Notes
1 The strategy achieving the bound in Theorem 23.6 is not computationally efficient. In fact we do not know of any polynomial time algorithm with logarithmic regret for this problem. The consequence is that Algorithm 14 does not yet have an efficient implementation.
2 While we focused on the sparse case, the results and techniques apply to other settings. For example, we can also get alternative confidence sets from results in online learning even for the standard non-sparse case. Or one may consider additional or different structural assumptions on .
3 When the online linear regression results are applied, it is important to use the tightest possible, data-dependent regret bounds Bn. In online learning most regret bounds start as tight, data-dependent bounds, which are then loosened to get further insight into the structure of problems. For our application, naturally one should use the tightest available regret bounds (or modify the existing proofs to get tighter data-dependent bounds). The gains from using data-dependent bounds can be significant.
4 The confidence set used by Algorithm 14 depends on the sparsity parameter m0, which must be known in advance. No algorithm can enjoy a regret of O(  0dn) for all  0 simultaneously (see Chapter 24).
5 The bound in Theorem 23.5 still depends on the ambient dimension. In general this is unavoidable, as we show in Theorem 24.3. For this reason it recently became popular to study the contextual setting with changing actions and make assumptions on the distribution of the contexts so that techniques from high-dimensional statistics can be brought to bear. These approaches are still in their infancy and deciding on the right assumptions is a challenge. The reader is referred to the recent papers by Kim and Paik [2019] and Bastani and Bayati [2020].

23.6 Bibliographical Remarks

285

23.6

Bibliographical Remarks

The selective explore-then-commit algorithm is due to the authors [Lattimore et al.,

2015]. The construction for the sparse case is from another paper co-authored

by one of the authors [Abbasi-Yadkori et al., 2012]. The online linear predictor

that competes with sparse parameter vectors and its analysis summarised in

Theorem 23.6 is due to Gerchinovitz [2013, theorem 10]. A recent paper by

Rakhlin and Sridharan [2017] also discusses the relationship between online

learning regret bounds and self-normalised tail bounds of the type given here.

Interestingly, what they show is that the relationship goes in both directions:

tail inequalities imply regret bounds, and regret bounds imply tail inequalities.

We are told by Francesco Orabona that confidence set constructions similar to

those in Section 23.3 have been used earlier in a series of papers by Claudio

Gentile and friends [Dekel et al., 2010, 2012, Crammer and Gentile, 2013, Gentile

and Orabona, 2012, 2014]. Carpentier and Munos [2012] consider a special case

where the action set is the unit sphere and the noise is vector valued so that the

reward is Xt = At,  + t . They prove bounds that essentially depend on the

sparsity of  and E[

t

2 2

].

Our

setting

is

recovered

by

choosing

t

to be a vector

of independent standard Gaussian random variables, but in this case the bounds

recovered by the proposed algorithm are suboptimal.

23.7

Exercises

23.1 (The zero-`norm') A norm on Rd is a function · : Rd  R such that

for all a  R and x, y  Rd, it holds that: (a) x = 0 if and only if x = 0 and

(b) ax = |a| x and (c) x + y  x + y and (d) x  0. Show that · 0

given by x 0 =

d i=1

I

{xi

=

0}

is

not

a

norm.

23.2 (Minimax bound for SETC) Prove the second part of Theorem 23.2.

23.3 (Anytime algorithm) Algorithm 13 is not anytime (it requires advance knowledge of the horizon). Design a modified version that does not require this knowledge and prove a comparable regret bound to what was given in Theorem 23.2.

Hint One way is to use the doubling trick, but a more careful approach will lead to a more practical algorithm.
23.4 Complete the calculation to derive Eq. (23.10) from Eq. (23.9).

23.5 Prove the equality in Eq. (23.11).

24 Minimax Lower Bounds for Stochastic Linear Bandits

Lower bounds for linear bandits turn out to be more nuanced than those for the classical finite-armed bandit. The difference is that for linear bandits the shape of the action set plays a role in the form of the regret, not just the distribution of the noise. This should not come as a big surprise because the stochastic finite-armed bandit problem can be modeled as a linear bandit with actions being the standard basis vectors, A = {e1, . . . , ek}. In this case the actions are orthogonal, which means that samples from one action do not give information about the rewards for other actions. Other action sets such as the unit ball (A = B2d = {x  Rd : x 2  1}) do not share this property. For example, if d = 2 and A = B2d and an algorithm chooses actions e1 = (1, 0) and e2 = (0, 1) many times, then it can deduce the reward it would obtain from choosing any other action.
All results of this chapter have a worst-case flavour showing what is (not) achievable in general, or under a sparsity constraint, or if the realisable assumption is not satisfied. The analysis uses the information-theoretic tools introduced in Part IV combined with careful choices of action sets. The hard part is guessing what is the worst case, which is followed by simply turning the crank on the usual machinery.
In all lower bounds, we use a simple model with Gaussian noise. For action At  A  Rd the reward is Xt = µ(At) + t where t  N (0, 1) is a sequence of independent standard Gaussian noise and µ : A  R is the mean reward. We will usually assume there exists a   Rd such that µ(a) = a,  . We write Pµ to indicate the measure on outcomes induced by the interaction of the fixed policy and the Gaussian bandit paramterised by µ. Because we are now proving lower bounds, it becomes necessary to be explicit about the dependence of the regret on A and µ or . The regret of a policy is:

n

Rn(A,

µ)

=

n

max
aA

µ(a)

-

Eµ

Xt ,

t=1

where the expectation is taken with respect to Pµ. Except in Section 24.4, we

assume the reward function is linear, which means there exists a   Rd such

that µ(a) = a,  . In these cases, we write Rn(A, ) and E and P. Recall the

notation used for finite-armed bandits by defining Tx(t) =

t s=1

I

{As

=

x}.

24.1 Hypercube

287

24.1

Hypercube

The first lower bound is for the hypercube action set and shows that the upper bounds in Chapter 19 cannot be improved in general.

Theorem 24.1. Let A = [-1, 1]d and  = {-n-1/2, n-1/2}d. Then, for any policy, there exists a vector    such that:

Rn(A, )



exp(-2) 8

 dn

.

Proof By the relative entropy identities in Exercise 15.8.(b) and Exercise 14.7, we have for ,    that

n

D(P, P ) = E

D(N ( At,  , 1), N ( At,  , 1))

t=1

=

1 2

n
E
t=1

At,  -  2 .

For i  [d] and   , define

(24.1)

n

pi = P

I {sign(Ati) = sign(i)}  n/2 .

t=1

Now let i  [d] and    be fixed, and let j = j for j = i and i = -i. Then, by the Bretagnolle­Huber inequality (Theorem 14.2) and Eq. (24.1),

pi

+ p

i



1 2

exp

-

1 2

n
E [
t=1

At, 

-

2]



1 2

exp

(-2)

.

(24.2)

Applying an `averaging hammer' over all   , which satisfies || = 2d, we get



1 ||

d
pi
i=1

=

1 ||

d
pi
i=1 



d 4

exp (-2)

.

This implies that there exists a    such that

d i=1

pi



d exp (-2) /4.

By

the definition of pi, the regret for this choice of  is at least

nd

Rn(A, ) = E

(sign(i) - Ati)i

t=1 i=1



1 n

d

E

n
I {sign(Ati) = sign(i)}

i=1

t=1



 n 2

d
P
i=1

n
I {sign(Ati) = sign(i)}  n/2
t=1

=

n 2

d i=1

pi



exp(-2) 8

 dn

,

24.2 Unit Ball

288

where the first line follows since the optimal action satisfies ai = sign(i) for i  [d], the first inequality follows from a simple case-based analysis showing that (sign(i) - Ati)i  |i|I {sign(Ati) = sign(i)}, the second inequality is Markov's inequality (see Lemma 5.1), and the last inequality follows from the choice of .
Except for logarithmic factors, this shows that the algorithm of Chapter 19 is near optimal for this action set. The same proof works when A = {-1, 1}d is restricted to the corners of the hypercube, which is a finite-armed linear bandit. In Chapter 22, we gave a policy with regret Rn = O( nd log(nk)), where k = |A|. There is no contradiction because the action set in the above proof has k = |A| = 2d elements.

24.2

Unit Ball

Lower-bounding the minimax regret when the action set is the unit ball presents an additional challenge relative to the hypercube. The product structure of the hypercube means that the actions of the learner in one dimension do not constraint their choices in other dimensions. For the unit ball, this is not true, and this complicates the analysis. Nevertheless, a small modification of the technique allows us to prove a similar bound.

Theorem 24.2. Assume d  2n and let A = {x  Rd : x 2  1}. Then

there exists a parameter vector   Rd with



2 2

=

d2/(48n)

such

that

Rn(A, )  d n/(16 3).

Proof

Let



=

1 43

d/n and   {±}d and for i  [d], define i = n  min{t :

t s=1

As2i



n/d}.

Then,

nd
Rn(A, ) = E
t=1 i=1

1 d

-

Ati

sign(i)





 2

d E

nd t=1 i=1

1 d

-

Ati

sign(i)

2



 d
2

d
E
i=1

i t=1

1 d

-

Ati

sign(i)

2

,

where the Ui(x) =

fit=irs1t(1in/eqdua-litAytiuxs)e2s

that At and let 

2 2



1.

Fix

i



[d].

For

x



{±1},

define

 {±}d be another parameter vector

such that j = j for j = i and i = -i. Assume without loss of generality that

i > 0. Let P and P be the laws of Ui(1) with respect to the bandit/learner

24.2 Unit Ball

289

interaction measure induced by  and  , respectively. Then,

E[Ui(1)]  E [Ui(1)] -

4n d

+

2

1 2

D(P,

P

)



E

[Ui(1)]

-

 2

4n d

+

2



E

[Ui(1)]

-

 2

4n d

+

2

 E [Ui(1)] - 4

3n d

n d

,

i

E

At2i

t=1

n d

+

1

(24.3) (24.4) (24.5)

where in the first inequality we used Pinsker's inequality (Eq. (14.12)), the result in Exercise 14.4, the bound

Ui(1) =

i



(1/ d - Ati)2  2

i

1 d

+

2

i

At2i



4n d

+

2,

t=1

t=1

t=1

and the assumption that d  2n. The inequality in Eq. (24.3) follows from the

chain rule for the relative entropy up to a stopping time (Exercise 15.7). Eq. (24.4)

is true by the definition of i and Eq. (24.5) by the assumption that d  2n.

Then,



E[Ui(1)] + E [Ui(-1)]  E [Ui(1) + Ui(-1)] - 4

3n d

n d

= 2E

i d

+

i

At2i

t=1



-4

3n d



n d



2n d

-

4

3n d

n d

=

n d

.

The proof is completed using the randomisation hammer:



Rn(A, )



 2

d

d

E [Ui (sign(i ))]

{±}d

i=1 {±}d



=

 2

d

d

E [Ui (sign(i ))]

i=1 -i{±}d-1 i{±}





 2

d

d

n d

=

2d-2nd .

i=1 -i{±}d-1





Hence there exists a   {±}d such that Rn(A, ) 

n 4

d

= d n . 16 3

The same proof works when A = {x  Rd : x 2 = 1} is the unit sphere. In fact, given a set X  Rd. A minimax lower bound that holds for A = co(X) continues to hold when A = X.

24.3 Sparse Parameter Vectors

290

24.3

Sparse Parameter Vectors
In Chapter 23 we gave an algorithm with Rn = O~(dpn) where p   0 is a known bound on the sparsity of the unknown parameter. Except for logarithmic terms this bound cannot be improved. An extreme case is when p = 1, which essentiallyreduces to the finite-armed bandit problem where the minimax regret has order dn (see Chapter 15). For this reason we cannot expect too much from sparsity and in particular the worst-case bound will depend polynomially on the ambient dimension d.
Constructing a lower bound for p > 1 is relatively straightforward. For simplicity we assume that d = pk for some integer k > 1. A sparse linear bandit can mimic the learner playing p finite-armed bandits simultaneously, each with k arms. Rather than observing the reward for each bandit, however, the learner only observes the sum of the rewards and the noise is added at the end. This is sometimes called the multi-task bandit problem.

Theorem 24.3. Assume pd  n and that d = pk for some integer k  2. Let

A = {ei  Rk : i  [k]}p  Rd. vector   Rd with  0 = p and

Then, for  

any policy there d/(pn) such that

exists Rn(A,

a )

par81ampedtenr.

Proof Let  > 0 and  = {ei : i  [k]}  Rk. Given   p  Rd and i  [p], let (i)  Rk be defined by k(i) = (i-1)p+k, which means that

 = [(1) , (2) , . . . , (p) ] .

Next define matrix V  Rp×d to be a block-diagonal matrix with 1 × k blocks, each containing the row vector (1, 2, . . . , k). For example, when p = 3, we have





V = 10

··· ···

k 0

0 1

··· ···

0 k

0 0

··· ···

00 .

0 ··· 0 0 ··· 0 1 ··· k

Let Bt = V At  [k]p represent the vector of `base' actions chosen by the learner in each of the p bandits in round t. The optimal action in the ith bandit is

bi () = argmaxb[k] b(i) .

The regret can be decomposed into the regrets in the p `base bandit' problems (a form of separability, again):

p

n

Rn() =  E

I {Bti = bi } .

i=1

t=1

Rni ()

24.4 Misspecified Models

291

For i  [p], we abbreviate (-i) = ((1), . . . , (i-1), (i+1), . . . , (p)). Then,

1 ||p

Rn()
p

=

1 ||p

p i=1

Rni()
p

=

p

1 ||p-1

1 ||

Rni()

i=1

(-i) p-1

(i) 



1 8

p i=1

1 ||p-1

 kn
(-i) p-1

=

1 8

 p kn

=

1 8

dpn .

(24.6)

Here, in the second equality, we use the convention that  denotes the vector obtained by `inserting' (i) into (-i) at the ith `block'. Other than this, the only tricky step is the inequality, which follows by choosing   k/n and repeating the argument outlined in Exercise 15.2. We leave it to the reader to check the details (Exercise 24.1).

24.4

Misspecified Models

An important generalisation of the linear model is the misspecified case, where
the mean rewards are not assumed to follow a linear model exactly. Suppose that A  Rd is a finite set with |A| = k and that Xt = t + µ(At), where µ : A  R is an unknown function. Let   Rd be the parameter vector for which supaA | , a - µ(a)| is as small as possible:

 = argminRd sup | , a - µ(a)| .
aA
Then let  = supaA | , a - µ(a)| be the maximum error. It would be very pleasant to have an algorithm such that

Rn(A,

µ)

=

n

max
aA

µ(a)

-

E

n

µ(At)

=

O~(min{dn

+

n,

 kn})

.

(24.7)

t=1

Unfortunately, it turns out that results of this kind are not achievable. To show this, we will prove a generic bound for the classical finite-armed bandit problem and afterwards show how this implies the impossibility of an adaptive bound like the above.

Theorem 24.4. Let A = [k], and for µ  [0, 1]k the reward is Xt = µAt + t and the regret is

n

Rn(µ)

=

n

max
iA

µi

-

Eµ

µAt .

t=1

24.4 Misspecified Models

292

Define ,   Rk by

 = µ  [0, 1]k : µi = 0 for i > 1

 = µ  [0, 1]k .

If V  R is such that 2(k - 1)  V  n(k - 1) exp(-2)/8 and supµ Rn(µ)  V , then

sup
µ 

Rn(µ

)



n(k - 1) 8V

exp(-2) .

Proof Recall that Ti(n) =

n t=1

I

{At

=

i}

is

the

number

of

times

arm

i

is

played after all n rounds. Let µ   be given by µ1 =  = (k - 1)/V  1/2. The

regret is then decomposed as:

k
Rn(µ) =  Eµ[Ti(n)]  V .
i=2

Rearranging shows that

k i=2

Eµ[Ti(n)]



V 

,

and

so

by

the

pigeonhole

principle

there exists an i > 1 such that

Eµ[Ti(n)]



(k

V - 1)

=

1 2

.

Then, define µ   by

  µj = 02

if j = 1 if j = i otherwise .

Next, by Theorem 14.2 and Lemma 15.1, for any event A, we have

Pµ(A) + Pµ

(Ac)



1 2

exp (D(Pµ, Pµ

))

=

1 2

exp

-22E[Ti(n)]



1 2

exp (-2)

.

By choosing A = {T1(n)  n/2} we have

Rn(µ)

+

Rn(µ

)



n 4

exp(-2)

=

n(k - 4V

1)

exp(-2) .

Therefore, by the assumption that Rn(µ)  V  n(k - 1) exp(-2)/8 we have

Rn(µ

)



n(k - 8V

1)

exp(-2) .

As promised, we now relate this to the misspecified linear bandits. Suppose that d = 1 (an absurd case) and that there are k arms A = {a1, a2, . . . , ak}  R1, where a1 = (1) and ai = (0) for i > 1. Clearly, if  > 0 and µ(ai) = ai,  , then the problem can be modelled as a finite-armed bandit with means µ    [0, 1]k.
In the general case, we just have a finite-armed bandit with µ   . If in the first case we have Rn(A, µ) = O( n), then the theorem shows for large enough n that
 sup Rn(A, µ) = (k n) .
µ

24.5 Notes

293

It follows that Eq. (24.7) is a pipe dream. To our knowledge, it is still an open question of what is possible on this front. We speculate that for k  d2, there is

a policy for which

Rn(A, ) = O~

min

 dn

+

 n d,

k d

 n

.

24.5

Notes

1 The worst-case bound demonstrates the near optimality of the OFUL algorithm

for a specific action set. It is an open question to characterise the optimal

regret for a wide range of action sets. We will return to these issues in the next

part of the book, where we discuss adversarial linear bandits.

2 We return to misspecified bandits in the notes and exercises of Chapter 29,

where algorithms from the adversarial linear bandit framework are applied to

tlahrigseptrhobatleRmnin=sOp~e(cdialnca+sesn. Ind)msahnoyualdppbleiccaotniosnids,ertehde

number of actions acceptable. There

is so exist

algorithms achieving this bound, which for large k is essentially not improvable

in the Foster

worst case [Lattimore and and Rakhlin [2020] shows

Stzheapteosvna´erci,a2n01a9chbi]e.vFeorRsnm=allO~k(,redckennt+wonrk kby).

24.6

Bibliographic Remarks
Worst-case lower bounds for stochastic bandits have appeared in a variety of places, all with roughly the same bound, but for different action sets. Our very simple proof for the hypercube is new, but takes inspiration from the paperby Shamir [2015]. Rusmevichientong and Tsitsiklis [2010] proved that Rn = (d n) when A is the unit sphere. Our proof for the unit ball strengthens their result marginally and is much simpler. As far as we know, the first lower bound of (d n) was given by Dani et al. [2008] for an action set equal to the product of two-dimensional disks. The results for the misspecified case are inspired by the work of one of the authors on the Pareto-regret frontier for bandits, which characterises what trade-offs are available when it is desirable to have a regret that is unusually small relative to some specific arms [Lattimore, 2015a].

24.7

Exercises
24.1 Complete the missing steps to prove the inequality in Eq. (24.6).

25 Asymptotic Lower Bounds for Stochastic Linear Bandits

The lower bounds in the previous chapter were derived by analysing the worst case for specific action sets and/or constraints on the unknown parameter. In this chapter, we focus on the asymptotics and aim to understand the influence of the action set on the regret. We start with a lower bound, and argue that the lower bound can be achieved. We finish by arguing that the optimistic algorithms (and Thompson sampling) will perform arbitrarily worse than what can be achieved by non-optimistic algorithms.

25.1

An Asymptotic Lower Bound for Fixed Action Sets

We assume that A  Rd is finite with |A| = k and that the reward is Xt = At,  + t, where   Rd and (t) t=1 is a sequence of independent standard Gaussian random variables. Of course the regret of a policy in this
setting is

n

Rn(A, ) = E

At ,

t=1

a

=

max
a A

a

- a, 

,

where the dependence on the policy is omitted for readability and E[·] is the expectation with respect to the measure on outcomes induced by the interaction of the policy and the linear bandit determined by . Like the asymptotic lower bounds in the classical finite-armed case (Chapter 16), the results of this chapter are proven only for consistent policies. Recall that a policy is consistent in some class of bandits E if the regret is sub-polynomial for any bandit in that class. Here this means that

Rn(A, ) = o(np) for all p > 0 and   Rd .

(25.1)

The main objective of the chapter is to prove the following theorem on the behaviour of any consistent policy and discuss the implications.

Theorem 25.1. Assume that A  Rd is finite and spans Rd, and suppose a

policy is consistent (satisfies Eq. 25.1). Let   Rd be any parameter such

that there is a unique optimal action, and let G¯n = E

n t=1

At

At

. Then

25.1 An Asymptotic Lower Bound for Fixed Action Sets

295

lim infn min(G¯n)/ log(n) > 0. Furthermore, for any a  A, it holds that

lim sup log(n)
n

a

2 G¯- n 1



2a 2

.

The reader should recognise

a

2 G¯- n 1

as

the

key

term

in

the

width

of

the

confidence interval for the least squares estimator (Chapter 20). This is quite

intuitive. The theorem is saying that any consistent algorithm must prove

statistically that all suboptimal arms are indeed suboptimal by making the

size of the confidence interval smaller than the suboptimality gap. Before the

proof of this result, we give a corollary that characterises the asymptotic regret

that must be endured by any consistent policy.

Corollary 25.2. Let A  Rd be a finite set that spans Rd and   Rd be such that there is a unique optimal action. Then, for any consistent policy,

lim inf
n

Rn(A, ) log(n)



c(A, ) ,

where c(A, ) is defined as

c(A, ) = inf

(a)a

[0,)A aA

subject to

a

2 H-1



a2 2

for all

a  A with a > 0 ,

with H = aA (a)aa .

The lower bound is complemented by a matching upper bound that we will not prove.

Theorem 25.3. Let A  Rd be a finite set that spans Rd. Then there exists a policy such that

lim sup
n

Rn(A, ) log(n)



c(A, ) ,

where c(A, ) is defined as in Corollary 25.2.

Proof of Theorem 25.1 The proof of the first part is simply omitted (see the
reference below for details). It follows along similar lines to what follows, essentially
that if Gn is not sufficiently large in every direction, then some alternative parameter is not sufficiently identifiable. Let a = argmaxaA a,  be the optimal action, which we assumed to be unique. Let   Rd be an alternative parameter to be chosen subsequently, and let P and P be the measures on the sequence of outcomes A1, X1, . . . , An, Xn induced by the interaction between the policy and the bandit determined by  and  respectively. Let E[·] and E [·] be the expectation operators of P and P , respectively. By Theorem 14.2 and Lemma 15.1,

25.1 An Asymptotic Lower Bound for Fixed Action Sets

296

for any event E,

P (E) + P

(Ec)



1 2

exp (- D(P, P

))

=

1 2

exp

-

1 2

E

n
At,  -  2
t=1

=

1 2

exp

-

1 2

-

2 G¯ n

.

(25.2)

A simple re-arrangement shows that

1 2

-

2 G¯ n



log

1 2P (E) + 2P (Ec)

.

Now we follow the usual plan of choosing  to be close to , but so that the

optimal action in the bandit determined by  is not a. Let min = min{a :

a  A, a > 0} and   (0, min) and H be a positive definite matrix to be

chosen later such that

a - a

2 H

> 0. Then define

 =+

a a-

+ a


2 H

H

(a

-

a

)

,

which is chosen so that

a - a,  = a - a,  + a +  =  .
This means that a is -suboptimal for bandit  . We abbreviate Rn = Rn(A, ) and Rn = Rn(A,  ). Then

Rn = E

Ta(n)a
aA



nmin 2

P

(Ta

(n)

<

n/2)



n 2

P

(Ta

(n)

<

n/2)

,

where Ta(n) =

n t=1

I {At

=

a}.

Similarly,

a

is

-suboptimal

in

bandit



so that

Rn



n 2

P

(Ta (n)



n/2)

.

Therefore,

P (Ta (n)

<

n/2) + P

(Ta (n)



n/2)



2 n

(Rn

+ Rn)

.

(25.3)

Note that this holds for any choice of H with a - a H > 0. The logical next step is to select H (which determines  ) to make (25.2) as large as possible. The

main difficulty is that this depends on n, so instead we aim to choose an H so

the quantity is large enough infinitely often. We start by just re-arranging things:

1 2

-

2 G¯ n

=

(a + )2 2

·

a - a

2 H G¯ n H

a - a

4 H

=

2

(a a-

+ )2 a 2
G¯ n-1

n (H )

,

where we introduced

n(H) =

a - a

2 G¯ n-1

a - a

a - a

4 H

2
HG¯nH .

25.1 An Asymptotic Lower Bound for Fixed Action Sets

297

Therefore, by choosing E to be the event that Ta (n) < n/2 and using (25.3) and (25.2), we have

2

(a a-

+ )2 a 2
G¯ n-1

n (H )



log

n 4Rn + 4Rn

,

which after re-arrangement leads to

(a + )2 2 log(n) a - a

2 G¯ n-1

n (H )



1

-

log((4Rn + 4Rn)/) log(n)

.

The definition of consistency means that Rn and Rn are both sub-polynomial, which implies that the second term in the previous expression tends to zero for

large n and so by sending  to zero,

lim inf
n

n (H ) log(n) a - a

2 G¯ n-1



2 2a

.

We complete the result using proof by contradiction. Suppose that

(25.4)

lim sup log(n)
n

a - a

> 2
G¯ n-1

a2 2

.

Then there exists an  > 0 and infinite set S  N such that

(25.5)

log(n)

a - a

 2
G¯- n 1

(a + )2 2

for all n  S .

Hence, by (25.4), lim infnS n(H) > 1. We now choose H to be a cluster point of the sequence (G¯-n 1/ G¯-n 1 )nS where G¯-n 1 is the spectral norm of the matrix G¯n-1. Such a point must exist, since matrices in this sequence have unit spectral
norm by definition and the set of such matrices is compact. We let S  S be a subset so that G¯-n 1/ G¯-n 1 converges to H on n  S . We now check that a - a H > 0:

a - a

2 H

=

lim
nS

a - a

2 G¯ n-1

G¯ n-1

> 0,

where the last inequality follows from the assumption in (25.5) and the first part of the theorem. Therefore,

1

<

lim inf
nS

n (H )



lim inf
nS

a - a

2 G¯ n-1

a - a

a - a

4 H

2 H G¯ n H

= 1,

which is a contradiction, and hence (25.5) does not hold. Thus,

lim sup log(n)
n

a - a

 2
G¯ n-1

2a 2

.

We leave the proof of the corollary as an exercise for the reader. Essentially, though, any consistent algorithm must choose its actions so that in expectation

a - a

2 G¯- n 1



(1

+

o(1))

2

2a log(n)

.

25.2 Clouds Looming for Optimism

298

Now, since a will be chosen linearly, often it is easily shown for suboptimal a that limn a - a / G¯n-1 a G¯n-1  1. This leads to the required constraint on the actions of the algorithm, and the optimisation problem in the corollary is
derived by minimising the regret subject to this constraint.

25.2

Clouds Looming for Optimism

The theorem and its corollary have disturbing implications for policies based on the principle of optimism in the face of uncertainty, which is that they can never be asymptotically optimal. The reason is that these policies do not choose actions for which they have collected enough statistics to prove they are suboptimal, but in the linear setting it can be worth playing these actions when they are very informative about other actions for which the statistics are not yet so clear. As we shall see, a problematic example appears in the simplest case where there is information sharing between the arms. Namely, when the dimension is d = 2, and there are k = 3 arms.
Let A = {a1, a2, a3}, where a1 = e1 and a2 = e2 and a3 = (1 - , ) with   1 and  > 0 is small. Let  = (1, 0) so that the optimal action is a = a1 and a2 = 1 and a3 = . If  is very small, then a1 and a3 point in nearly the same direction, and so choosing only these arms does not provide sufficient information to quickly learn which of a1 or a3 is optimal. On the other hand, a2 and a1 - a3 point in very different directions, which means that choosing a2 allows a learning agent to quickly identify that a1 is in fact optimal. We now show how the theorem and corollary demonstrate this. First we calculate the optimal solution to the optimisation problem in Corollary 25.2. Recall we are trying to minimise

(a)a
aA

subject to

a

2 H ()-1



2a 2

for

all

aA

with

a

> 0,

where H() = aA (a)aa . Clearly we should choose (a1) arbitrarily large, then a computation shows that





lim H()-1 =  0

(a1 )

0

0

 .

1

(a3 )2  2 +(a2 )

25.2 Clouds Looming for Optimism

299

The constraints mean that

1 (a3)22

+ (a2)

=

lim
(a1 )

a2

2 H ()-1



1 2

22 (a3)22 + (a2)

=

lim
(a1 )

a3

2 H ()-1



2 2

.

Provided that   1, this reduces to the constraint that

(a3)2 + (a2)  22 .

Since we are minimising (a2) + (a3) we can easily see that (a2) = 22 and (a3) = 0 provided that 22  2/. Therefore, if  is chosen sufficiently small relative to , then the optimal rate of the regret is c(A, ) = 22, and so by
Theorem 25.3 there exists a policy such that

lim sup
n

Rn(A, ) log(n)

=

22 .

Now we argue that for  sufficiently large and  arbitrarily small that the regret for any consistent optimistic algorithm is at least

lim sup
n

Rn(A, ) log(n)

=

(1/) ,

which can be arbitrarily worse than the optimal rate! So why is this so? Recall that optimistic algorithms choose

At

=

argmaxaA

max
~Ct

a, ~

,

where Ct  Rd is a confidence set that we assume contains the true  with high probability. So far this does not greatly restrict the class of algorithms that we might call optimistic. We now assume that there exists a constant c > 0 such that

Ct  ~ : ^t - ~ Vt  c log(n) ,

where Vt =

t s=1

AsAs

.

So

now

we

ask

how

often

we

can

expect

the

optimistic

algorithm to choose action a2 = e2 in the example described above. Since we

have assumed   Ct with high probability, we have that

max
~Ct

a1, ~

 1.

On the other hand, if Ta2 (t - 1) > 4c2 log(n), then

max
~Ct

a2, ~

=

max
~Ct

a2, ~ - 

 2c

a2 Vt-1 log(n)  2c

log(n) Ta2 (t - 1)

<

1,

which means that a2 will not be chosen more than 1 + 4c2 log(n) times. So if  = (c2), then the optimistic algorithm will not choose a2 sufficiently often and a simple computation shows it must choose a3 at least (log(n)/2) times

25.3 Notes

300

and suffers regret of (log(n)/). The key take away from this is that optimistic algorithms do not choose actions that are statistically suboptimal, but for linear bandits it can be optimal to choose these actions more often to gain information about other actions.
This conclusion generalises to structured bandit problems where choosing one action allows you to gain information about the rewards of other actions. In such models the optimism principle often provides basic guarantees, but may fail to optimally exploit the structure of the problem.

25.3

Notes
1 All algorithms known to match the lower bound in Theorem 25.3 are based on (or inspired by) solving the optimisation problem that defines c(A, ) with estimated value . Unfortunately, these algorithms are not especially practical in finite time. As far as we know, none are simultaneously near-optimal in a minimax sense. Constructing a practical asymptotically optimal algorithm for linear bandits is a fascinating open problem.
2 In Chapter 36 we will introduce the randomised Bayesian algorithm called Thompson sampling algorithm for finite-armed and linear bandits. While Thompson sampling is often empirically superior to UCB, it does not overcome the issues described here.

25.4

Bibliographic Remarks
The theorems of this chapter are by the authors: Lattimore and Szepesva´ri [2017]. The example in Section 25.2 first appeared in a paper by Soare et al. [2014], which deals with the problem of best-arm identification for linear bandits (for an introduction to best-arm identification, see Chapter 33). The optimisation-based algorithms that match the lower bound are by Lattimore and Szepesva´ri [2017], Ok et al. [2018], Combes et al. [2017] and Hao et al. [2020], with the latter handling also the contextual case with finitely many contexts.

25.5

Exercises
25.1 Prove Corollary 25.2. 25.2 Prove the first part of Theorem 25.1.

25.5 Exercises

301

25.3 Give examples of action sets A, parameter vectors   Rd and vectors a  Rd such that:
(a) c(A  {a}, ) > c(A, ); and (b) c(A  {a}, ) < c(A, ).

Part VI
Adversarial Linear Bandits

303
The adversarial linear bandit is superficially a generalisation of the stochastic linear bandit where the unknown parameter vector is chosen by an adversary. There are many similarities between the two topics. Indeed, the techniques in this part combine the ideas of optimal design presented in Chapter 22 with the exponential weighting algorithm of Chapter 11. The intuitions gained by studying stochastic bandits should not be taken too seriously, however. There are subtle differences between the model of adversarial bandits introduced here and the stochastic linear bandits examined in previous chapters. These differences will be discussed at length in Chapter 29. The adversarial version of the linear bandits turns out to be remarkably rich, both because of the complex information structure and because of the challenging computational issues.
The part is split into four chapters, the first of which is an introduction to the necessary tools from convex analysis and optimisation. In the first chapter on bandits, we show how to combine the core ideas of the Exp3 policy of Chapter 11 with the optimal experimental design for least-squares estimators in Chapter 21. When the number of actions is large (or infinite), the approach based on Exp3 is hard to make efficient. These shortcomings are addressed in the next chapter, where we introduce the mirror descent and follow-the-regularised leader algorithms for bandits and show how they can be used to design efficient algorithms. We conclude the part with a discussion on the relationship between adversarial and stochastic linear bandits, which is more subtle than the situation with finite-armed bandits.

26 Foundations of Convex Analysis ( )

Our coverage of convex analysis is necessarily extremely brief. We introduce only what is necessary and refer the reader to standard texts for the proofs.

26.1

Convex Sets and Functions
A set A  Rd is convex if for any x, y  A it holds that x + (1 - )y  A for all   (0, 1). The convex hull of a collection of points x1, x2, . . . , xn  Rd is the smallest convex set containing the points, which also happens to satisfy
n
co(x1, x2, . . . , xn) = x  Rd : x = pixi for some p  Pn-1 .
i=1
The convex hull co(A) is also defined for an arbitrary set A  Rd and is still the smallest convex set that contains A (see (c) in Figure 26.1). For the rest of the section, we let A  Rd be convex. Let R¯ = R  {-, } be the extended real number system and define operations involving infinities in the natural way (see notes).
Definition 26.1. An extended real-valued function f : Rd  R¯ is convex if its epigraph Ef = {(x, y)  Rd × R : y  f (x)}  Rd+1 is a convex set.
The term `epi' originates in greek and it means upon or over: The epigraph of a function is the set of points that sit on the top of the function's graph.
The domain of an extended real-valued function on Rd is dom(f ) = {x  Rd : f (x) < }. For S  Rd, a function f : S  R¯ is identified with the function f¯ : Rd  R¯ , which coincides with f on S and is defined to take the value  outside of S. It follows that if f : S  R, then dom(f ) = S. A convex function is proper if its range does not include - and its domain is nonempty.
For the rest of the chapter, we will write `let f be a convex' to mean that f : Rd  R¯ is a proper convex function.

26.1 Convex Sets and Functions

305

(a)

(b)

(c)

(d)

(e)

(f)

Figure 26.1 (a) is a convex set. (b) is a non-convex set. (c) is the convex hull of a non-convex set. (d) is a convex function. (e) is non-convex, but all local minimums are global. (f) is not convex.

Permitting convex functions to take values of - is a convenient standard because certain operations on proper convex functions result in improper ones (infimal convolution, for example). These technicalities will never bother us in this book, however.

A consequence of the definition is that for convex f , we have f (x + (1 - )y)  f (x) + (1 - )f (y) for all   (0, 1) and x, y  dom(f ) .
In fact, the inequality holds for all x, y  Rd.

(26.1)

Some authors use Eq. (26.1) as the definition of a convex function along with a specification that the domain is convex: If A  Rd is convex, then f : A  R is convex if it satisfies Eq. (26.1), with f (x) =  assumed for x / A.

The reader is invited to prove that all convex functions are continuous on the
interior of their domain (Exercise 26.1).
A function is strictly convex if the inequality in Eq. (26.1) is always strict. The Fenchel dual of a function f is f (u) = supx x, u - f (x), which is convex because the maximum of convex functions is convex. The Fenchel dual has many nice properties. Most important for us is that for sufficiently nice functions, f 
is the inverse of f (Theorem 26.6). Another useful property is that when f is a proper convex function and its epigraph is closed, then f = f , where f  denotes the bidual of f : f  = (f ). The Fenchel dual is also called the convex

26.2 Jensen's Inequality

306

conjugate. If f : Rd  R¯ is twice differentiable on the interior of its domain, then convexity of f is equivalent to its Hessian having non-negative eigenvalues for
all x  int(dom(f )). The field of optimisation is obsessed with convex functions
because all local minimums are global (see Fig. 26.1). This means that minimising
a convex function is usually possible (efficiently) using some variation of gradient descent. A function f : Rd  R¯ is concave if -f is convex.

26.2

Jensen's Inequality

One of the most important results for convex functions is Jensen's inequality: Theorem 26.2 (Jensen's inequality). Let f : Rd  R¯ be a measurable convex function and X be an Rd-valued random element on some probability space such that E[X] exists and X  dom(f ) holds almost surely. Then E[f (X)]  f (E[X]).

If we allowed Lebesgue integrals to take on the value of , the condition that

X is almost surely an element of the domain of f could be removed and the

result would still be true. Indeed, in this case we would immediately conclude

that E[f (X)] =  and Jensen's inequality would trivially hold.

The basic inequality of (26.1) is trivially

a special case of Jensen's inequality. Jensen's

f (x)

inequality is so central to convexity that it

can actually be used as the definition (a function is convex if and only if it satisfies

(x¯,

n k=1

pk f

(xk ))

Jensen's inequality). The proof of Jensen's using

Definition 26.1 in full generality is left to the

reader (Exercise 26.2). However, we cannot resist

(x¯, f (x¯))

to include here a simple `graphical proof' that works in the simple case when X is supported

x1 x2 x3 x4 x5

on x1, . . . , xn and P(X = xk) = pk. Then, letting x¯ =

n k=1

pk xk ,

one

can

notice

that the point (x¯, k pkxk) lies in the convex hull of {(xk, f (xk))k}, which is a

convex subset of the epigraph Ef  Rd+1. The result follows because (x¯, f (x¯)) is

on the boundary of Ef as shown in the figure. The direction of Jensen's inequality

is reversed if `convex' is replaced by `concave'.

26.3

Bregman Divergence
Let f : Rd  R be convex and x, y  Rd with y  dom(f ). The Bregman divergence at y induced by f is defined by
Df (x, y) = f (x) - f (y) - x-yf (y) , where vf (y) = limh0+ (f (y + hv) - f (y))/h  R  {-, } is the directional derivative of f at y in direction v. The directional derivative is always well defined

26.3 Bregman Divergence

307

f (x) f (y) + x - y, f (y)
Df (x, y)

y

x

Figure 26.2 The Bregman divergence Df (x, y) is the difference between f (x) and the Taylor series approximation of f at y. When f is convex the, linear approximation is a lower bound on the function and the Bregman divergence is positive.

for convex functions, but can be positive/negative infinity. When f is differentiable at y, then vf (y) = v, f (y) and thus Df (x, y) = f (x) - f (y) - x - y, f (y) , which is the more usual definition. For the geometric intuition see Fig. 26.2. Let dom(f ) denote the set of points in the domain of f where f is differentiable.

Theorem 26.3. The following hold:

(a) Df (x, y)  0 for all y  dom(f ). (b) Df (x, x) = 0 for all x  dom(f ). (c) Df (x, y) is convex as a function of x for any y  dom(f ).

Part (c) does not hold in general when f is not differentiable at y, as you will show in Exercise 26.14. The square root of the Bregman divergence shares many properties with a metric, and for some choices of f , it actually is a metric. In general, however, it is not symmetric and does not satisfy the triangle inequality.

Example 26.4.

Let

f (x)

=

1 2

x

22. Then f (x) = x and

Df (x, y)

=

1 2

x

2 2

-

1 2

y

2 2

-

x - y, y

=

1 2

x-y

2 2

.

Example 26.5. Let A = [0, )d, dom(f ) = A and for x  A, f (x) = di=1(xi log(xi) - xi), where 0 log(0) = 0. Then, for y  (0, )d, f (y) = log(y)
and

d

d

d

Df (x, y) = (xi log(xi) - xi) - (yi log yi - yi) - log(yi)(xi - yi)

i=1

i=1

i=1

d
= xi log
i=1

xi yi

d
+ (yi - xi) .
i=1

Notice that if x, y  Pd-1 are in the unit simplex, then Df (x, y) is the relative entropy between probability vectors x and y. The function f is called the unnormalised negentropy, which will feature heavily in many of the chapters

26.4 Legendre Functions

308

that follow. When y > 0, the Bregman divergence is infinite if there exists an

i such that yi = 0 and xi > 0. Otherwise, Df (x, y) = id=1(yi - xi).

i:xi>0 xi log(xi/yi) +

26.4

Legendre Functions

In this section we use various topological

notions such as the interior, closed set and 0

-x

boundary. The definitions of these terms are

given in the notes. Let f be a convex function

and A = dom(f ) and C = int(A). Then f is -1

Legendre if

(a) C is non-empty;
(b) f is differentiable and strictly convex on C; and
(c) limn f (xn) 2 =  for any sequence (xn)n with xn  C for all n and limn xn = x and some x  C.

-2

0

1

2

3

4

Figure 26.3 f (x) = -x: the archetypical Legendre function

The intuition is that the set {(x, f (x)) : x  dom(A)} is a `dish' with eversteepening edges towards the boundary of the domain. Legendre functions have some very convenient properties:

Theorem 26.6. Let f : Rd  R¯ be a Legendre function. Then,

(a) f is a bijection between int(dom(f )) and int(dom(f )) with the inverse (f )-1 = f ;
(b) Df (x, y) = Df (f (y), f (x)) for all x, y  int(dom(f )); and (c) the Fenchel conjugate f  is Legendre.

The next result formalises the `dish' intuition by showing the directional derivative along any straight path from a point in the interior to the boundary blows up. You should supply the proof of the following results in Exercise 26.6.

Proposition 26.7. Let f be Legendre and x  int(dom(f )) and y   int(dom(f )), then lim1 y - x, f ((1 - )x + y) = .

Corollary 26.8. If f is Legendre and x  argminxdom(f) f (x), then x  int(dom(f )).

Example 26.9.

Let f

be

the

Legendre

function

given

by

f (x)

=

1 2

x

2 2

,

which

has domain dom(f ) = Rd. Then, f (x) = f (x) and f and f  are the identity

functions.

26.4 Legendre Functions

309

Example 26.10. Let f (x) = -2

d i=1

xi

when

xi



0

for

all

i

and



otherwise, whichhas dom(f ) = [0, )d and int(dom(f )) = (0, )d. The gradient

is f (x) = -1/ x, which blows up thientv(edcotmor(f())x=i)i{. xInw[h0,at f)odllo:wxsi

(in norm) on any sequence (xn) approaching = 0 for some i  [d]}. Here, x stands for we will often use the underlying convention

of extending univariate functions to vector by applying them componentwise.

Note that f (x)  0 as x  : `' is not part of the boundary of dom(f ).

Strict convexity is also obvious so f is Legendre. In Exercise 26.8, we ask you

to calculate the Bregman divergences with respect to f and f  and verify the

results of Theorem 26.6.

Example 26.11. Let f (x) = i xi log(xi) - xi be the unnormalised negentropy, which we met in Example 26.5. Similarly to the previous example, dom(f ) = [0, )d, int(dom(f )) = (0, )d and  int(dom(f )) = {x  [0, )d : xi = 0 for some i  [d]}. The gradient is f (x) = log(x), and thus f (x)   as
x   int(dom(f )). Strict convexity also holds, hence f is Legendre. You already
met the Bregman divergence Df (x, y), which turned out to be the relative entropy when x, y belong to the simplex. Exercise 26.9 asks you to calculate the dual of f
(can you guess what this function will be?) and the Bregman divergence induced by f  and to verify Theorem 26.6.

The Taylor series of the Bregman divergence is often a useful approximation. Let g(y) = Df (x, y), which for y = x has g(y) = 0 and 2g(y) = 2f (x). A
second-order Taylor expansion suggests that

Df (x, y) = g(y)  g(x) +

y - x, g(x)

+

1 2

y-x

2 2f (x)

=

1 2

y-x

2 2f (x)

.

This approximation can be very poor if x and y are far apart. Even when x and y are close, the lower-order terms are occasionally problematic, but nevertheless the approximation can guide intuition. The next theorem, which is based on Taylor's theorem and measurable selections, gives an exact result (Exercise 26.15).

Theorem 26.12. If f is convex and twice differentiable in A = int(dom(f )) and x, y  A, then there exists an   [0, 1] and z = x + (1 - )y such that

Df (x, y)

=

1 2

x-y

2 2f (z)

.

Suppose furthermore that 2f is continuous on int(dom(f )); then there exists a measurable function g : int(dom(f )) × int(dom(f ))  int(dom(f )) such that for all x, y  int(dom(f )),

Df (x, y)

=

1 2

x-y

2 2f (g(x,y))

.

The next result will be useful.

Theorem 26.13. Let  > 0 and f be Legendre and twice differentiable in

26.5 Optimisation

310

A = int(dom(f )), x, y  A, and let z  [x, y] be the point such that Df (x, y) =

1 2

x-y

2 2

f

(z)

.

Then,

for

al l

u



Rd,

x - y, u

- Df (x, y)  



2

u

2 (2f (z))-1

.

Although the Bregman divergence is not symmetric, the right-hand side does not depend on the order of x and y in the Bregman divergence except that z  [x, y] may be different.

Proof Strict convexity of f ensures that H = 2f (z) is invertible. Applying Cauchy­Schwarz,

x - y, u  x - y H u H-1 = u H-1 2Df (x, y) .

Therefore,

x - y, u

- Df (x, y)  

u H-1

2Df (x, y) -

Df (x, y) 



 2

u

2 H -1

,

where the last step follows from the ever useful maxxR ax - bx2 = a2/(4b) which holds for any b > 0 and a  R.

26.5

Optimisation

The first-order optimality condition states that if x  Rd is the minimiser of a differentiable function f : Rd  R, then f (x) = 0. One of the things we like about convex functions is that when f is convex, the first-order optimality
condition is both necessary and sufficient. In particular, if f (x) = 0 for some x  Rd then x is a minimiser of f . The first-order optimality condition can also be generalised to constrained minima: if f : Rd  R is convex and differentiable and A  Rd is a non-empty convex set, then

x  argminxA f (x)  x  A : x - x, f (x)  0 .

(26.2)

The necessity of the condition on the right-hand side is easy to understand by a geometric reasoning. If f (x) = 0, then the said condition trivially holds. If f (x) = 0, the hyperplane Hx whose normal is f (x) and goes through x must be a supporting hyperplane of A at x, with -f (x) being the outer normal of A at x otherwise x could be moved by a small amount while staying
inside A and improving the value of f . Since A is convex, it thus lies entirely on the side of Hx that f (x) points into. This is clearly equivalent to (26.2).
The sufficiency of the condition also follows from this geometric viewpoint as the
reader may verify from the figure.
The above statement continues to hold with a small modification even when f

-f (x) better point

26.6 Projections

311

-f (x)

Figure 26.4 Illustration of first-order optimality conditions. The point at the top is not a minimiser because the hyperplane with normal as gradient does not support the convex set. The point at the right is a minimiser.

is not differentiable everywhere. In particular, in this case the equivalence (26.2) holds for any x  dom(f ) with the modification that on the right side of the
equivalence, A should be replaced by A  dom(f ):

Proposition 26.14. Let f : Rd  R¯ be a convex function and A  Rd a non-empty convex set. Then, for any x  dom(f ), it holds that

x  argminxA f (x)  x  A  dom(f ) : x - x, f (x)  0 .

(26.3)

Further, if f is Legendre, then x  argminxA f (x) implies x  dom(f ) and hence also (26.3).

The part that concerns the Legendre objective f follows by noting that by Corollary 26.8, x  int(dom(f )) combined with that by Theorem 26.6(a),
int(dom(f )) = dom(f ).

26.6

Projections

If A  Rd and x  Rd, then the Euclidean projection of x on A is A(x) =

argminyA

x-y

2 2

.

One

can

also

project

with

respect

to

a

Bregman

divergence

induced by convex function f . Let A,f be defined by

A,f (x) = argminyA Df (y, x) .

An important property of the projection is that minimising a Legendre function f on a convex set A is (usually) equivalent to finding the unconstrained minimum on the domain of f and then projecting that point on to A.

Theorem 26.15. Let f : Rd  R¯ be Legendre, A  Rd a non-empty, closed convex set with A  dom(f ) non-empty and assume that y~ = argminzRd f (z) exists. Then the following hold:

26.7 Notes

312

(a) y = argminzA f (z) exists and is unique; (b) y = argminzA Df (z, y~).
The assumption that y~ exists is necessary. For example f (x) = -x for x  0
and f (x) =  for x < 0 is Legendre with domain dom(f ) = [0, ), but f does
not have a minimum on its domain.

26.7

Notes

1 The `infinity arithmetic' on the extended real line is as follows:

 +  =  for   (-, ]  -  = - for   [-, )  ·  =  and  · (-) = -  ·  = - and  · (-) = 
0 ·  = 0 · (-) = 0 .

for  > 0 for  < 0

Like /0, the value of  -  is not defined. We also have    for all 
and   - for all .
2 There are many ways to define the topological notions used in this chapter.
The most elegant is also the most abstract, but there is no space for that here. Instead we give the classical definitions that are specific to Rd and subsets. Let A be a subset of Rd. A point x  A is an interior point if there exists an  > 0 such that B(x) = {y : x - y 2  }  A. The interior of A is int(A) = {x  A : x is an interior point}. The set A is open if int(A) = A and closed if its complement Ac = Rd \ A is open. The boundary of A is denoted by A and is the set of points in x  Rd such that for all  > 0 the set B(x) contains points from A and Ac. Note that points in the boundary need not be in A. Some examples: [0, ) = {0} = (0, ) and Rn = .

26.8

Bibliographic Remarks
The main source for these notes is the excellent book by Rockafellar [2015]. The basic definitions are in part I. The Fenchel dual is analysed in part III while Legendre functions are found in part V. Convex optimisation is a huge topic. The standard text is by Boyd and Vandenberghe [2004].

26.9

Exercises
26.1 Let f : Rd  R be convex. Prove that f is continuous on int(dom(f )). 26.2 Prove Jensen's inequality (Theorem 26.2). Precisely, let X  Rd be a random

26.9 Exercises

313

variable for which E[X] exists and f : Rd  R¯ a measurable convex function. Prove that E[f (x)]  f (E[X]).
Hint Let x0 = E[X]  Rd and define a linear function g : Rd  R such that g(x0) = f (x0) and g(x)  f (x) for all x  Rd. To guarantee the existence of g, you may use the supporting hyperplane theorem, which states that if S  Rm is a convex set and s  S, then there exists a supporting hyperplane containing s.
26.3 Let f : Rd  R  {-, }.
(a) Prove that f (x)  f (x). (b) Assume that f is convex and differentiable on int(dom(f )). Show that
f (x) = f (x) for x  int(dom(f )).
As mentioned in the text, the assumption that f is differentiable can be relaxed to an assumption that the epigraph of f is closed, in which case the result holds over the whole domain. The proof is not hard, but you will need to use the sub-differential rather than the gradient, and the boundary must be treated with care.

26.4 For each of the real-valued functions below, decide whether or not it is Legendre on the given domain:

(a) (b)

f f

(x) (x)

= =

x-2oxn

[-1, 1]. on [0, ).

(c) f (x) = log(1/x) on [0, ) with f (0) = .

(d) f (x) = x log(x) on [0, ) with f (0) = 0.

(e) f (x) = |x| on R.

(f) f (x) = max{|x|, x2} on R.

26.5 Prove Theorem 26.3.

26.6 Prove Proposition 26.7 and Corollary 26.8.

26.7 Prove Proposition 26.14.

26.8 Let f be the convex function given in Example 26.10.

(a) For x, y  dom(f ), find Df (x, y). (b) Compute f (u) and f (u). (c) Find dom(f ). (d) Show that for u, v  (-, 0]d,

Df (u, v)

=

-

d i=1

(ui - vi)2 uivi2

.

26.9 Exercises

314

(e) Verify the claims in Theorem 26.6.
26.9 Let f : Rd  R¯ be the unnormalised negentropy function from Example 26.11. We have seen in Example 26.5 that Df (x, y) = i(xi log(xi/yi) + yi - xi).
(a) Compute f (u) and f (u). (b) Find dom(f ). (c) Show that for u, v  Rd,
d
Df (u, v) = exp(vi)(vi - ui) + exp(ui) - exp(vi) .
i=1
(d) Verify the claims in Theorem 26.6.
26.10 Let f be Legendre. Show that f~ given by f~(x) = f (x) + x, u is also Legendre for any u  Rd.

26.11 Let f be the unnormalised negentropy function from Example 26.5.

(a) Prove that f is Legendre. (b) Given y  [0, )d, prove that argminxPd-1 Df (x, y) = y/ y 1.
26.12 Let   [0, 1/d] and A = Pd-1  [, 1]d and f be the unnormalised negentropy function. Let y  [0, )d and x = argminxA Df (x, y) and assume that y1  y2  · · ·  yd. Let m be the smallest value such that
d
ym(1 - (m - 1))   yj .
j=m
Show that



if i < m

xi =

(1 - (m - 1))yi/

d j=m

yj

otherwise .

26.13 (Generalised Pythagorean identity) Let A  Rd be convex and closed and f : Rd  R¯ be a convex function with A  dom(f ) non-empty.
(a) Suppose that x  A and y  Rd and z = A,f (y) and f is differentiable at y. Prove that

Df (x, y)  Df (x, z) + Df (z, y) .

(b) Prove that the condition that f be differentiable at y cannot be relaxed.

26.14 Prove Theorem 26.3 and show that Part (c) does not hold in general when f is not differentiable at y.

26.15 Prove Theorem 26.12

Hint For the first part, simply apply Taylor's theorem. For the second part,

26.9 Exercises

315

you will probably need to use a measurable selection theorem. For example, the theorem by Kuratowski and Ryll-Nardzewski, which appears as theorem 6.9.4 in the second volume of the book by Bogachev [2007].

27 Exp3 for Adversarial Linear Bandits

The model for adversarial linear bandits is as follows. The learner is given an action set A  Rd and the number of rounds n. As usual in the adversarial setting, it is convenient to switch to losses. An instance of the adversarial problem is a sequence of loss vectors y1, . . . , yn taking values in Rd. In each round t  [n], the learner selects a possibly random action At  A and observes a loss Yt = At, yt .
The learner does not observe the loss vector yt. The regret of the learner after n
rounds is

n

n

Rn = E

Yt

- min
aA

a, yt .

t=1

t=1

Clearly, the finite-armed adversarial bandits discussed in Chapter 11 is a special case of adversarial linear bandits corresponding to the choice A = {e1, . . . , ed}, where e1, . . . , ed are the unit vectors of the d-dimensional standard Euclidean basis.

For this chapter, we assume that
(a) for all t  [n] the loss satisfies yt  L = x  Rd : supaA | a, x |  1 ; and
(b) the action set A spans Rd.
The latter assumption is for convenience only and may be relaxed with a little care (Exercise 27.7).

27.1

Exponential Weights for Linear Bandits
We adapt the exponential-weighting algorithm of Chapter 11. Like in that setting, we need a way to estimate the individual losses for each action, but now we make use of the linear structure to share information between the arms and decrease the variance of our estimators. For now we assume that A is finite, which we relax in Section 27.3. Let t  [n] be the index of the current round. Assuming the loss estimate for action a  A in round s  [n] is Y^s(a), then the probability distribution proposed by exponential weights is given by the probability mass

27.1 Exponential Weights for Linear Bandits

317

function P~t : A  [0, 1] given by
t-1
P~t(a)  exp - Y^s(a) ,
s=1
where  > 0 is the learning rate. To control the variance of the loss estimates, it will be useful to mix this distribution with an exploration distribution  ( : A  [0, 1] and aA (a) = 1). The mixture distribution is
Pt(a) = (1 - )P~t(a) + (a) ,

where  is a constant mixing factor to be chosen later. The algorithm then simply samples its action At from Pt:

At  Pt .

Recall way to

ethstaimt Yatte=yt(Aa)t,=y. t

is the observed loss after taking action At. We need a a, yt . The idea is to use least squares to estimate yt with

Y^t = RtAtYt, where Rt  Rd×d is selected so that Y^t is an unbiased estimate of yt

given the history. Then the loss for a given action is estimated by Y^t(a) = a, Y^t .

To find the choice of Rt that makes Y^t unbiased, let Et[·] = E [·|Pt] and calculate

Et[Y^t] = RtEt[AtAt ]yt = Rt

Pt(a)aa yt .

aA

Qt

Using Rt = Qt-1 leads to Et[Y^t] = yt as desired. Of course Qt should be nonsingular, which will follow by choosing  so that

Q() = (a)aa
aA
is non-singular. The complete algorithm is summarised in Algorithm 15.

1: Input Finite action set A  Rd, learning rate , exploration distribution , exploration parameter 
2: for t = 1, 2, . . . , n do 3: Compute sampling distribution:

Pt(a) = (a) + (1 - )

exp -

t-1 s=1

Y^s(a)

.

a A exp -

t-1 s=1

Y^s(a

)

4: Sample action At  Pt 5: Observe loss Yt = At, yt and compute loss estimates:

Y^t = Q-t 1AtYt

and

Y^t(a) = a, Y^t .

6: end for

Algorithm 15: Exp3 for linear bandits.

27.2 Regret Analysis

318

27.2

Regret Analysis

Theorem 27.1. Assume that A is non-empty and let k = |A|. For any exploration distribution , for some parameters  and , for all (yt)t with yt  L, the regret of Algorithm 15 satisfies

Rn  2 (2g() + d)n log(k) ,

(27.1)

where

g()

=

maxaA

a

2 Q-1

()

.

Furthermore,

there

exists

an

exploration

distribution  and parameters  and  such that g()  d, and hence Rn 

2 3dn log(k).

The utility of (27.1) is that at times, calculating the distribution that minimises g() or sampling from it may be difficult, in which case, one may employ a distribution that trades off computation with the regret.

Proof Assume that the learning rate  is chosen so that for each round t the loss estimates satisfy

Y^t(a)  -1, a  A .

(27.2)

Then, by adopting the proof of Theorem 11.1 (see Exercise 27.1), the regret is bounded by

Rn



log k 

+

2n

+



n t=1

E

Pt(a)Y^t2(a)
aA

.

(27.3)

Note that we cannot use the proof that leads to the tighter constant ( getting replaced by /2 in the second term above) because we would loose too much in other parts of the proof by guaranteeing that the loss estimates are bounded by one (see below). To get a regret bound, it remains to set  and  so that (27.2) is satisfied and to bound E a Pt(a)Y^t2(a) . We start with the latter. Let Mt = a Pt(a)Y^t2(a). By the definition of the loss estimate,
Y^t2(a) = (a Qt-1AtYt)2 = Yt2At Q-t 1aa Qt-1At ,

which means that Mt = a Pt(a)Y^t2(a) = Yt2At Qt-1At  At Q-t 1At = trace(AtAt Qt-1), and by the linearity of trace,

E[Mt | Pt]  trace

Pt(a)aa Q-t 1 = d .

aA

It remains to choose  and . Strengthen (27.2) to |Y^t(a)|  1 and note that since |Yt|  1,

|Y^t(a)| = |a Qt-1AtYt|  |a Q-t 1At| .

Recall that Q() = aA (a)aa . Clearly Qt Q(), and hence Q-t 1

27.3 Continuous Exponential Weights

319

Q()-1/ by Exercise 27.4. Using this and the Cauchy­Schwarz inequality shows that

|a

Qt-1At| 

a

Q- t 1

At

Qt-1



max 
A

Qt-1



1 

max 
A

Q-1()

=

g() 

,

which implies that

|Y^t(a)|



 

g()

.

(27.4)

Choosing  = g() guarantees |Y^t(a)|  1. Plugging this choice into (27.3), we get

Rn



log k 

+

n(2g()

+

d)

=

2

(2g() + d)n log(k) ,

where the last equality is derived by choosing  =

log(k) (2g()+d)n

finishing

the

proof

of (27.1).

For the second half, recall that by the Kiefer­Wolfowitz theorem (Theorem 21.1

and Exercise 21.6), there exists a sampling distribution  such that g()  d.

Plugging this value into (27.1), finishes the proof.

27.3

Continuous Exponential Weights
The dependence on log(k) in the regret guarantee provided by Theorem 27.1 is objectionable when the number of arms is extremely large or infinite. One approach is to find a finite subset C  A for which
sup min sup | a - b, y |  1/n .
aA bC yL
A standard calculation shows (Exercise 27.6) shows that C can always be chosen so that log |C|  d log(6dn). Then it is easy to check that Exp3 on C suffers regret relative to the best action in A of at most Rn = O(d n log(nd)). The problem with this approach is that C is exponentially large in d, which makes this algorithm intractable in most situations. When A is convex, a more computationally tractable approach is to use the continuous exponential weights algorithm.
For this section, we assume that A is convex and has positive Lebesgue measure. The latter condition can be relaxed with some care (Exercise 27.10).

Let  be a probability measure supported on A. The continuous exponential weights policy samples At from Pt = (1 - )P~t + , where P~t is a measure

27.3 Continuous Exponential Weights

320

supported on A defined by

P~t(B) = B exp - A exp -

t-1 s=1

Y^s

(a)

da .

t-1 s=1

Y^s

(a)

da

(27.5)

We will shortly see that the analysis in the previous section can be copied almost verbatim to prove a regret bound for this strategy. But what has been bought here? Rather than sampling from a discrete distribution on a large number of arms, we now have to sample from a probability measure on a convex set. Sampling from arbitrary probability measures is itself a challenging problem, but under certain conditions there are polynomial time algorithms for this problem. The factors that play the biggest role in the feasibility of sampling from a measure are (a) the form of the measure or its density and (b) how the convex set is represented. As it happens, the measure defined in the last display is log-concave, which means that the logarithm of the density, with respect to the Lebesgue measure on A, is a concave function.

Theorem 27.2. Let p(a)  IA(a) exp(-f (a)) be a density with respect to the Lebesgue measure on A such that f : A  R is a convex function. Then there exists a polynomial-time algorithm for sampling from p, provided one can compute
the following efficiently:

1 (First-order information): f (a) where a  A. 2 (Euclidean projections): argminxA x - y 2 where y  Rd.
The probability distribution defined by Eq. (27.5) satisfies the first condition. Efficiently computing a projection on to a convex set is a more delicate issue. A general criterion that makes this efficient is access to a separation oracle, which is a computational procedure  that accepts a point x  Rd as input and responds (x) = true if x  A and otherwise (x) = u, where y, u > x, u for all y  A (see Fig. 27.1).

A

x

Figure 27.1 Separation oracle returns the normal of a hyperplane that separates x from A whenever x / A. When x  A, the separation oracle returns true.
Define log+(x) = max(0, log(x)). Theorem 27.3. Assume that A is compact, convex and has volume vol(A) =
A da > 0. Then an appropriately tuned instantiation of the continuous

27.4 Notes

321

exponential weights algorithm with Kiefer­Wolfowitz exploration has regret bounded by

Rn  2d 3n(1 + log+(2n/d)) .

The proof of Theorem 27.3 relies on the following proposition, which we leave as an exercise (Exercise 27.11).

Proposition 27.4. Let K  Rd be a compact convex set with vol(K) > 0, u  Rd and let x = argminxK x, u . Then,

log

vol(K) K exp (- x - x, u ) dx

 d 1 + log+

supx,yK x - y, u d

.

The left-hand side in the above display is the logarithmic Laplace transform of the uniform measure on K - {x} evaluated at u.

Proof of Theorem 27.3 As before, choosing  = d ensures that | a, Y^t |  1 for all a  A (see the proof of Theorem 27.1). The standard argument (Exercise 27.9)

shows that





Rn



1 

E

log



A exp

-

vol(A)

 + 3dn .

tn=1(Y^t(a) - Y^t(a)) da

(27.6)

Using again that | a, Y^t |  1 and Proposition 27.4 with u = 

n t=1

Y^t

shows

that

Rn



d(1 +

log+(n/d)) 

+

3dn



2d

3n(1 + log+(2n/d)) .

27.4

Notes
1 A naive implementation of Algorithm 15 has computation complexity O(kd+d3) per round. There is also the one-off cost of computing the exploration distribution, the complexity of which was discussed in Chapter 21. The real problem is that k can be extremely large. This is especially true when the action set is combinatorial. For example, when A = {a  Rd : ai = ±1} is the corners of the hypercube |A| = 2d, which is much too large unless the dimension is small. Such problems call for a different approach that we present in the next chapter and in Chapter 30.
2 It is not important to find exactly the optimal exploration distribution. All that is needed is a bound on Eq. (27.4), which for the exploration distribution based on the Kiefer­Wolfowitz theorem is just d. However, unlike in the finite case, exploration is crucial and cannot be removed (Exercise 27.8).

27.5 Bibliographic Remarks

322

3 The O(n) dependence of the regret on the horizon is not improvable, but the linear dependence on the dimension is suboptimal for certain action sets and optimal for others. An example where improvement is possible occurs when A is the unit ball, which is analysed in the next chapter.
4 A slight modification of the set-up allows the action set to change in each round, but where actions have identities. Suppose that k  {1, 2, . . .} and At = {a1(t), . . . , ak(t)} and the adversary chooses losses so that maxaAt | a, yt |  1 for all t. Then a straightforward adaptation of Algorithm 15 and Theorem 27.1 leads to an algorithm for which

n

Rn = max E

At - ai(t), yt

i[k]

t=1

 2 3dn log(k) .

The definition of the regret still compares the learner to the best single action in hindsight, which makes it less meaningful than the definition of the regret in Chapter 19 for stochastic linear bandits with changing action sets. These differences are discussed in more detail in Chapter 29. See also Exercise 27.5.

27.5

Bibliographic Remarks
The results in Sections 27.1 and 27.2 follow the article by Bubeck et al. [2012], with minor modifications to make the argument more pedagogical. The main difference is that they used John's ellipsoid over the action set for exploration, which is only the right thing when John's ellipsoid is also a central ellipsoid. Here we use Kiefer­Wolfowitz, which is equivalent to finding the minimum volume central ellipsoid containing the action set. Theorem 27.2, which guarantees the existence of a polynomial time sampling algorithm for convex sets with gradient information and projections is by Bubeck et al. [2015b]. We warn the reader that these algorithms are not very practical, especially if theoretically justified parameters are used. The study of sampling from convex bodies is quite fascinating. There is an overview by Lov´asz and Vempala [2007], though it is a little old. The continuous exponential weights algorithm is perhaps attributable to Cover [1991] in the special setting of online learning called universal portfolio optimisation. The first application to linear bandits is by Hazan et al. [2016]. Their algorithm and analysis are more complicated because they seek to improve the computation properties by replacing the exploration distribution based on Kiefer­Wolfowitz with an adaptive randomised exploration basis that can be computed in polynomial time under weaker assumptions. Continuous exponential weights for linear bandits using the core set of John's ellipsoid for exploration (rather than Kiefer­Wolfowitz) was recently analysed by van der Hoeven et al. [2018]. Another path towards an efficient O(d n log(·)) policy for convex action sets is to use the tools from online optimisation. We explain some of these ideas in more detail in the next chapter, but the reader is referred to the paper by Bubeck and Eldan [2015].

27.6 Exercises

323

27.6

Exercises
27.1 (`Mixed' Exp3 analysis) Prove Eq. (27.3).
27.2 (Dependence on the range of losses) Suppose that instead of assuming yt  L, we assume that yt  {y  Rd : supaA | a, y |  b} for some known b > 0. Modify the algorithm to accommodate this change, and explain how the regret guarantee changes.
27.3 (Dependence on the range of losses (ii)) Now suppose that a < b are known and yt  {y  Rd : a, y  [a, b] for all a  A}. How can you adapt the algorithm now, and what is its regret?
27.4 (Inversion reverses Loewner orders) Let A, B  Rd×d and suppose that A B and B is invertible. Show that A-1 B-1.
27.5 (Changing action sets) Provide the necessary corrections to Algorithm 15 and its analysis to prove the result claimed in Note 4.
Hint You will need to choose a new exploration distribution in every round. Otherwise everything is more or less the same.
27.6 (Covering numbers for convex sets) For K  Rd let x K = supyK | x, y |. Let A  Rd and L = {y : y A  1}. Let N (A, ) be the size of the smallest subset C  A such that minx C x - x L   for all x  A. Show the following:
(a) When A = x  Rd : x V -1  1 , we have N (A, )  (3/)d. (b) When A is convex, bounded and span(A) = Rd we have N (A, )  (3d/)d. (c) For any bounded A  Rd we have N (A, )  (6d/)d.
Hint For the first part, find a linear map from A to the Euclidean ball and use the fact that the Euclidean ball can be covered with a set of size (3/)d. For the second part use the fact that for any symmetric, convex and compact set K there exists an ellipsoid E = {x : x V  1} such that E  K  dE.
27.7 (Low rank action sets (i)) In the definition of the algorithm and the proof of Theorem 27.1, we assumed that A spans Rd and that it has positive Lebesgue measure. Show that this assumption may be relaxed by carefully adapting the algorithm and analysis.
27.8 (Necessity of exploration) We saw in Chapter 11 that the exponential weights algorithm achieved near-optimal regret without mixing additional exploration. Show that exploration is crucial here. More precisely, construct a finite action set A and reward sequence yt  L such that the regret of Algorithm 15 with  = 0 becomes very poor (even with  optimally tuned) relative to the optimal choice.

27.6 Exercises

324

27.9 (Continuous exponential weights) Complete the missing steps in the proof of Theorem 27.3.
27.10 (Low rank action sets (ii)) In the definition of the algorithm and the proof of Theorem 27.3, we assumed that A spans Rd and that it has positive Lebesgue measure. Show that this assumption may be relaxed by carefully adapting the algorithm and analysis.
27.11 (Volume bounds) Prove Proposition 27.4.

28 Follow-the-Regularised-Leader and Mirror Descent

In the last chapter, we showed that if A  Rd has k elements, then the regret of Exp3 with a careful exploration distribution has regret
Rn = O( dn log(k)) .
We also showed the continuous version of this algorithm has regret at most
Rn = O(d n log(n)) .
Although this algorithm can often be made to run in polynomial time, the degree tends to be high and the implementation complicated, making the algorithm impractical. In many cases this can be improved, both in terms of the regret and computation. In this chapter we demonstrate this in the case when A is the unit ball by showing that for this case there is an efficient, low-complexity algorithm for which the regret is Rn = O( dn log(n)). More importantly, however, we introduce a pair of related algorithms called follow-the-regularised-leader and mirror descent, which are powerful tools for the design and analysis of bandit algorithms. In fact, the exponential weights algorithm turns out to be a special case.

28.1

Online Linear Optimisation
Mirror descent originated in the convex optimisation literature. The idea has since been adapted to online learning and specifically to online linear optimisation. Online linear optimisation is the full information version of the adversarial linear bandit, where at the end of each round the learner observes the full vector yt. Let A  Rd Figure 28.1 Mirror descent is a be a convex set and L  Rd be an arbitrary set modern art, as well as science called the loss space. Let y1, . . . , yn be a sequence of loss vectors with yt  L for t  [n]. In each round the learner chooses at  A and subsequently observes the vector yt. The regret relative to a fixed comparator a  A is
n
Rn(a) = at - a, yt ,
t=1

28.1 Online Linear Optimisation

326

and the regret is Rn = maxaA Rn(a). We emphasise that the only difference relative to the adversarial linear bandit is that now yt is observed rather than at, yt . Actions are not capitalised in this section because the algorithms presented here do not randomise.

Mirror descent
The basic version of mirror descent has two extra parameters beyond n and A. A learning rate  > 0 and a convex function F : Rd  R¯ with domain D = dom(F ). Usually F will be Legendre. The function F is called a potential function or
regulariser. In the first round, mirror descent predicts

Subsequently it predicts

a1 = argminaA F (a) .

(28.1)

at+1 = argminaA ( a, yt + DF (a, at)) ,

(28.2)

where DF (a, at) is the F -induced Bregman divergence between a and at. Implicit in the definition is that a1, a2, . . . are well-defined. The reader is invited to construct examples when this is not the case (Exercise 28.2). A simple case when (at)tn=1 are well-defined is when A is compact and F is Legendre.

Fol low-the-Regularised-Leader
Like mirror descent, follow-the-regularised-leader depends on a convex potential F with domain D = dom(F ) and predicts a1 = argminaA F (a). In subsequent rounds t  [n], the predictions are

t
at+1 = argminaA  a, ys + F (a) .
s=1

(28.3)

The intuition is that the algorithm chooses at+1 to be the action that performed best in hindsight with respect to the regularised loss. Again, the definition of follow-the-regularised-leader implicitly assumes that (at)nt=1 are well-defined. As for mirror descent, the regularisation serves to stabilise the algorithm, which
turns out to be a key property of good algorithms for online linear prediction.

Follow-the-leader chooses the action that appears best in hindsight,

at+1 = argminaA

t s=1

a, ys

.

In

general

this

algorithm

is

not

well

suited

for online linear optimisation because the absence of regularisation makes it

unstable (Exercise 28.4).

Equivalence of Mirror Descent and Follow-the-Regularised-Leader At first sight these algorithms do not look that similar. To clarify matters, let us suppose that F is Legendre with domain D  A. In this setting, mirror descent

28.1 Online Linear Optimisation

327

and follow-the-regularised-leader are identical. To see this, let

t(a) =  a, yt + DF (a, at) =  a, yt + F (a) - F (at) - a - at, F (at) .

Now mirror descent chooses at+1 to minimise t. The reader should check that the assumption that F is Legendre on domain D  A implies that the minimiser occurs in the interior of D  A and that t(at+1) = 0 (see Exercise 28.1). This means that yt = F (at) - F (at+1), and so

t

t

F (at+1) = -yt + F (at) = F (a1) -  ys = - ys ,

s=1

s=1

where the last equality is true because a1 is chosen as the minimiser of F in A  D = D, and again the fact that F is Legendre ensures this minimum occurs

at an interior point where the gradient vanishes. Follow the regularised leader

chooses at+1 to minimise t(a) = 

t s=1

a, ys

+ F (a). The same argument

shows that t(at+1) = 0, which means that

t
F (at+1) = - ys .
s=1

The last two displays and the fact that the gradient for Legendre functions is invertible shows that mirror descent and follow-the-regularised-leader are the same in this setting.

The equivalence between these algorithms is far from universal. First of

all, it does not generally hold when F is not Legendre or its domain

is larger than A. Second, in many applications of these algorithms, the

learning rate or potential change with time, and in either case the

algorithms will typically produce different action sequences. For example, if

a learning rate t is used rather than  in the definition of t, then mirror

descent chooses F (at+1) = - leader chooses F (at+1) = -t

stst==11yss.ysW, ewrheitleurfnoltloowt-htihse-irsesuguelainristehde-

notes and exercises.

Example

28.1.

Let A

=

Rd

and

F (a)

=

1 2

a

2 2

.

Then

F (a)

=

a

and

D(a, at)

=

1 2

a - at

2 2

.

Clearly

F

is Legendre and D = A, so mirror descent and

follow-the-regularised-leader are the same. By simple calculus we see that

at+1 = argminaRd  a, yt

+

1 2

a - at

2 2

=

at

-

yt

,

which may be familiar as online gradient descent with linear losses. For the extension to nonlinear convex loss functions, see Note 12.

Example 28.2.

Let A be a compact convex subset of Rd and F (a) =

1 2

a

22.

28.1 Online Linear Optimisation

328

Then mirror descent chooses

at+1 = argminaA  a, yt

+

1 2

a - at

2 2

=

(at

-

yt)

,

(28.4)

where (a) is the Euclidean projection of a on to A. This algorithm is usually called online projected gradient descent. On the other hand, for follow-theregularised-leader we have

t
at+1 = argminaA  a, ys
s=1

+

1 2

a - at

2 2

=



t
- ys
s=1

,

which may be a different choice than that of mirror descent.

Example 28.3. The exponential weights algorithm that appeared in various
forms on numerous occasions in earlier chapters is a special case of mirror descent corresponding to choosing the constraint set A as the simplex in Rd and choosing F to be the unnormalised negentropy function of Example 26.5. In this case
follow-the-regularised-leader chooses

t

d

at+1 = argminaA  a, ys + ai log(ai) - ai .

s=1

i=1

You will show in Exercise 28.8 that

at+1,i =

exp -

t s=1

ysi

.

d j=1

exp

-

t s=1

ysj

(28.5)

28.1.1

A Two-Step Process for Implementation

Solving the optimisation problem in Eq. (28.2) is often made easier by using Theorem 26.15 from Chapter 26. Assume F is Legendre and A is compact and non-empty, and suppose that

F (a) - y  int(dom(F )) for all a  A  D and y  L .

(28.6)

Then the solution to Eq. (28.2) can be found using the following two-step procedure:

a~t+1 = argminaD  a, yt + DF (a, at)

and

at+1 = argminaA DF (a, a~t+1) .

(28.7) (28.8)

Eq. (28.6) means the first optimisation problem can be evaluated explicitly as the solution to

yt + F (a~t+1) - F (at) = 0 .

(28.9)

Since F is Legendre, Theorem 26.6 shows that F is a bijection between int(dom(F )) and int(dom(F )), which means that a~t+1 = (F )-1(F (at) - yt).

28.2 Regret Analysis

329

The optimisation problem in Eq. (28.8) is usually harder to calculate analytically, but there are important exceptions, as we shall see.
All potentials and losses that appear in positive results in this book guarantee that mirror descent (and also follow-the-regularised-leader) are well defined, and that condition in Eq. (28.6) holds.

The two-step implementation of mirror descent also explains its name. The
update in round t can be seen as transforming the action at  A into the `mirror' (dual) space using F , where it is combined with the most recent (scaled) loss yt. Then F -1 is used to transform the updated vector back to the original (primal) space. The function F is called the mirror map.

The same idea works for follow-the-regularised-leader. Assuming F is

Legendre, A is compact and nonempty and -

t s=1

ys



int(dom(F )),

then for follow-the-regularised-leader

t

at+1 = A,F F -1 - ys

,

s=1

where A,F is the projection on to A with respect to DF as described in Section 26.6.

Some of the differences between follow-the-regularised-leader and mirror descent are illustrated in Fig. 28.2, which shows how the algorithms differ once projections start to occur.

28.2

Regret Analysis

Although mirror descent and follow-the-regularised-leader are not the same, the bounds presented here are identical. The theorem for mirror descent has two parts, the first of which is a little stronger than the second. To minimise clutter, we abbreviate DF by D.

Theorem 28.4 (Mirror descent regret bound). Let  > 0 and F be Legendre with domain D and A  Rd be a non-empty convex set with int(dom(F ))  A = . Let a1, . . . , an+1 be the actions chosen by mirror descent, which are assumed to be
well-defined. Then, for any a  A, the regret of mirror descent is bounded by

Rn(a)



F (a) - F (a1) 

+

n t=1

at - at+1, yt

-

1 

n t=1

D(at+1, at) .

Furthermore, suppose that Eq. (28.6) holds and a~2, a~3, . . . , a~n+1 are given by

28.2 Regret Analysis

330

Constraint set a1

Primal F

a2

F -1

F

afollow-the-regularised-leader 4 a4MD

a3 A,F

F -1 F

F -1 F -1 F

-y3

Dual -y1
-y2 -y3

Figure 28.2 Illustration of follow-the-regularised-leader and mirror descent. The constraint set is A, and the function A,F is the projection on to A with respect to the Bregman divergence induced by Legendre function F . Follow-the-regularisedleader accumulates the scaled losses in the dual space, mapping back to the primal using the inverse map F -1. Mirror descent computes the next iterate by at+1 = A,F (F -1(F (at) - yt). The algorithms generally behave differently in the presence of projections. In the figure, the algorithms behave the same until the fourth iterate, after which the projection that appeared in the computation of the third iterate breaks the equivalence.

Eq. (28.7). Then,

Rn(a)



1 

n
F (a) - F (a1) + D(at, a~t+1)
t=1

.

Proof Fix a  A. The result trivially holds when a  D. Hence, we assume that a  D. For the first part of the claim, we split the inner product:

at - a, yt = at - at+1, yt + at+1 - a, yt .

In Exercise 28.1, you will show that at  int(dom(F )), and hence the Bregman divergence D(b, at) = F (b) - F (at) - b - at, F (at) for any b  dom(F ). By definition, at+1 = argminbA  b, yt + D(b, at). Hence, the first-order optimality conditions for at+1 (Proposition 26.14) show that

a - at+1, yt + F (at+1) - F (at)  0 .

28.2 Regret Analysis

331

Reordering and using the definition of the Bregman divergence,

at+1 - a, yt



1 

a - at+1, F (at+1) - F (at)

=

1 

(D(a, at)

-

D(a, at+1)

-

D(at+1, at))

.

Using this, along with the definition of the regret,

n

Rn = at - a, yt

t=1



n

at - at+1, yt

+

1 

n
(D(a, at) - D(a, at+1) - D(at+1, at))

t=1

t=1

n

=

at - at+1, yt

t=1

+

1 

n
D(a, a1) - D(a, an+1) - D(at+1, at)
t=1



n

at - at+1, yt

+

F (a)

- F (a1) 

-

1 

n
D(at+1, at) ,

t=1

t=1

(28.10)

where the final inequality follows from the fact that D(a, an+1)  0 and D(a, a1)  F (a) - F (a1), the latter of which is true by the first-order optimality conditions for a1 = argminbA F (b). To see the second part, note that

at - at+1, yt

=

1 

at - at+1, F (at) - F (a~t+1)

=

1 

(D(at+1, at) +

D(at, a~t+1)

- D(at+1, a~t+1))



1 

(D(at+1, at) +

D(at, a~t+1))

.

The result follows by substituting this into Eq. (28.10).

The assumption that a1 minimises the potential was only used to bound D(a, a1)  F (a) - F (a1). For a different initialisation, the following bound still holds:

Rn(a)



1 

n
D(a, a1) + D(at, a~t+1)

.

t=1

(28.11)

As we shall see in Chapter 31, this is useful when using mirror descent to analyse non-stationary bandits.

The first part of Theorem 28.4 also holds for follow-the-regularised-leader as stated in the next result, the proof of which is left for Exercise 28.5.
Theorem 28.5 (Follow-the-regularised-leader regret bound). Let  > 0, F be convex with domain D, A  Rd be a non-empty convex set. Assume that

28.2 Regret Analysis

332

a1, . . . , an+1 chosen by follow-the-regularised-leader are well defined. Then, for any a  A, the regret of follow-the-regularised-leader is bounded by

Rn(a)



F (a)

- F (a1) 

+

n

at - at+1, yt

-

1 

n
D(at+1, at) .

t=1

t=1

We now give two applications of the regret bound of Theorem 28.4 for mirror descent. The same results would hold for the same problems for FTRL just in this case we would need to use Theorem 28.5. Let diamF (A) = maxa,bA F (a) - F (b) be the diameter of A with respect to F .

Proposition 28.6 (Regret on the unit-ball). Let A = B2d = {a  Rd : a 2  1}

be the standard unit ball and assume yt  B2d for all t. Then mirror descent with

potential F (a) =

1 2

a

2 2

and  =

1/n is well defined and its regret satisfies

Rn  n.

Proof That mirror descent is well defined follows by a direct calculation (cf. Example 28.1). By Eq. (28.9), we have a~t+1 = at - yt so

D(at, a~t+1)

=

1 2

a~t+1 - at

2 2

=

2 2

yt

2 2

.

Therefore, since diamF (A) = 1/2 and yt 2  1 for all t,

Rn



diamF (A) 

+

 2

n t=1

yt

2 2



1 2

+

n 2

 = n.

Proposition 28.7 (Regret on the simplex). Let A = Pd-1 be the probability simplex and yt  L = [0, 1]d for all t. Then mirror descent with the unnormalised
negentropy potential and  = 2 log(d)/n is well defined and its regret satisfies
Rn  2n log(d).

Proof That mirror descent is well-defined follows because the simplex is compact.

The Bregman divergence with respect to the unnormalised negentropy potential

for a, b  A is D(a, b) =

d i=1

ai

log(ai/bi).

Therefore,

Rn(a)



F (a) - F (a1) 

+

n t=1

at

- at+1, yt

-

1 

n t=1

D(at+1, at)



log(d) 

+

n t=1

at - at+1

1

yt



-

1 

n t=1

1 2

at - at+1

2 1



log(d) 

+

 2

n t=1

yt

2 



log(d) 

+

n 2

=

2n log(d) ,

where the first inequality follows from Theorem 28.4, the second from Pinsker's
inequality and the facts that diamF (A) = log(d). In the third inequality, we used `optimise to bound'. In particular, we used that for any a  R and b > 0, maxxR ax - bx2/2 = a2/(2b). The last inequality follows from the assumption that yt   1.

28.3 Application to Linear Bandits

333

The last few steps in the above proof are so routine that we summarise their use in a corollary, the proof of which we leave to the reader (Exercise 28.6).

Corollary 28.8. Let F be a Legendre potential and · t be a norm on Rd for

each

t



[n]

such

that

DF (at+1, at)



1 2

at+1 - at

2 t

.

Then

the

regret

of

mirror

descent or follow-the-regularised-leader satisfies

Rn



diamF (A) 

+

 2

n t=1

yt

2 t

,

where y t = maxx: x t1 x, y is the dual norm of · t.

It often happens that the easiest way to bound the regret of mirror descent is to find a norm that satisfies the conditions of Corollary 28.8. Often, Theorem 26.13 provides a good approach.

Example 28.9. To illustrate a suboptimal application of mirror descent,

suppose

we

had

chosen

F (a)

=

1 2

a

2 2

in

the

setting

of

Proposition

28.7.

Then

DF (at+1, at)

=

1 2

at+1 -at

2 2

suggests

choosing

· t to be the standard Euclidean

norm. Since diamF (A) = 1/2 and · 2 = · 2, applying Corollary 28.8 shows

that

Rn



1 2

+

 2

n t=1

yt

2 2

.

But now we see that

yt

2 2

can be as large as d, and tuning 

would lead to a

rate of O( nd) rather than O( n log(d)).

Both Theorems 28.4 and 28.5 were presented for the oblivious case where (yt)tn=1 are chosen in advance. This assumption was not used, however, and in fact the bounds continue to hold when yt is chosen strategically as a function of a1, y1, . . . , yt-1, at. This is analogous to how the basic regret bound for exponential weights continues to hold in the face of strategic losses. But
be cautioned, this result does not carry immediately to the application of
mirror descent to bandits, as discussed at the end in Note 9.

28.3

Application to Linear Bandits
We now show how mirror descent and follow-the-regularised-leader can be used to construct algorithms for adversarial linear bandit problems. Like in the previous chapter, the adversary chooses a sequence of vectors y1, . . . , yn with yt  L  Rd. In each round the learner chooses At  A  Rd and observes At, yt . The regret

28.3 Application to Linear Bandits

334

relative to action a  A is

n

Rn(a) = E

At - a, yt .

t=1

The regret is Rn = maxaA Rn(a). The application of mirror descent and followthe-regularised-leader to linear bandits is straightforward. The only difficulty is that the learner does not observe yt but instead At, yt . The solution is to replace yt with an estimator, which is typically some kind of importance-weighted estimator as in the previous chapter. Because estimation of yt is only possible using randomisation, the algorithm cannot play the suggested action of mirror descent, but instead plays a distribution over actions with the same mean as the proposed action. This is often necessary anyway, when A is not convex. Since the losses are linear, the expected additional regret by playing according to the distribution vanishes. The algorithm is summarised in Algorithm 16. We have switched to capital letters because the actions are now randomised.

Theorem 28.10 (Regret of Mirror-Descent and FTRL with bandit feedback).
Suppose that Algorithm 16 is run with Legendre potential F , convex action set A  Rd and learning rate  > 0 such that the loss estimators are unbiased: E[Y^t | A¯t] = yt for all t  [n]. Then the regret for either variant of Algorithm 16, provided that they are well defined, is bounded by

Rn(a)  E

F (a)

- F (A¯1) 

+

n

A¯t - A¯t+1, Y^t

-

1 

n
D(A¯t+1, A¯t)

.

t=1

t=1

Furthermore, letting

A~t+1 = argminadom(F )  a, Y^t + DF (a, A¯t)

and assuming that -Y^t + F (a)  F (dom(F )) for all a  A almost surely, the regret of the mirror descent variation satisfies

Rn



diamF (A) 

+

1 

n t=1

E

D(A¯t, A~t+1)

.

Proof Using the definition of the algorithm and the assumption that Y^t is unbiased given A¯t and that Pt has mean A¯t leads to

E [ At, yt ] = E A¯t, yt = E E A¯t, yt | A¯t = E E A¯t, Y^t A¯t ,

where the last equality used the linearity of expectations. Hence,

n

n

Rn(a) = E

At, yt - a, yt = E

A¯t - a, Y^t ,

t=1

t=1

which is the expected random regret of mirror descent or follow-the-regularisedleader on the recursively constructed sequence Y^t. The result follows from
Theorem 28.4 or Theorem 28.5 and the note at the end of the last section

28.4 Linear Bandits on the Unit Ball

335

that says these theorems continue to hold even for recursively constructed loss sequences.

1: Input Legendre potential F , action set A and learning rate  > 0 2: Choose A¯1 = argminaAdom(F ) F (a) 3: for t = 1, . . . , n do 4: Choose measure Pt on A with mean A¯t
5: Sample action At from Pt and observe At, yt 6: Compute estimate Y^t of the loss vector yt
7: Update:

A¯t+1 = argminaAdom(F )  a, Y^t + DF (a, A¯t)

(Mirror descent)

t

A¯t+1 = argminaAdom(F ) 

a, Y^s + F (a)

s=1
(follow-the-regularised-leader)

8: end for
Algorithm 16: Online stochastic mirror descent/follow-the-regularised-leader.

28.4

Linear Bandits on the Unit Ball

To illustrate the power of these methods, we return to adversarial linear bandits and the special case where the action set is the unit ball. In the previous chapter, we showed that continuous exponential weights on the unit ball with KieferWolfowitz exploration has a regret of

Rn = O(d n log(n)) .

Surprisingly, follow-the-regularised-leader with a carefully chosen potential improves on this bound by a factor of d.
For the remainder of this section, let · = · 2 be the standard Euclidean norm and A = B2d be the standard unit ball. In order to instantiate follow-theregularised-leader we need a potential, a sampling rule, an unbiased estimator and
a learning rate. Note that the only source of randomness is the randomisation in the algorithm. Hence, let Et[·] = E[· | A1, . . . , At-1]. We start with the sampling rule and estimator. Recall that in round t we need to choose a distribution on A with mean A¯t and sufficient variability that the variance of the estimator is
not too large. Given the past, let Et and Ut be independent, where Et  {0, 1} is such that Et[Et] = 1 - A¯t and Ut is uniformly distributed on {±e1, . . . , ±ed}. The algorithm chooses

At

=

EtUt

+

(1

- Et)A¯t A¯t

.

28.4 Linear Bandits on the Unit Ball

336

In other words, Et = 1 indicates that the algorithm explores, which happens with probability 1 - A¯t . Clearly, Et[At] = A¯t. (The sampling distribution Pt is just the law of At given the past, which remains implicit.) For the estimator we use a
variant of the importance-weighted estimator from the last chapter:

Y^t

=

d Et At 1-

At, yt A¯t

.

(28.12)

The reader can check for themself that this estimator is unbiased. Next, we inspect the contents of our magician's hat and select the potential

F (a) = - log (1 - a ) - a .

There is one more modification. Rather than instantiating follow-the-regularisedleader with action set A, we use A~ = {x  Rd : x 2  r}, where r < 1 is a
radius to be tuned subsequently. The reason for this modification is to control the variance of the estimator in Eq. (28.12), which blows up as A¯t gets close to
the boundary. You will show in Exercise 28.7 that

A¯t = 

- L^ t-1 1 +  L^t-1

with

t-1
L^t-1 = Y^s ,
s=1

where (x) is the projection operator on to A~ with respect to · 2.

(28.13)

1: Input Learning rate  > 0 2: for t = 1, . . . , n do 3: Compute

A¯t = 

- L^ t-1 1 +  L^t-1

with

t-1
L^t-1 = Y^s
s=1

4: Sample Et  {0, 1} from Binomial with bias 1 - A¯t and Ut uniformly

on {e1, . . . , ed}

5:

Play

action

At

=

EtUt

+

(1-Et )A¯t A¯t

6:

Observe

At, yt

and

estimate

loss

vector

Y^t

=

d Et At 1-

At, yt A¯t

7: end for

Algorithm 17: Follow-the-regularised-leader for linear bandits on the unit ball

Theorem 28.11. Assume that (yt)nt=1 are a sequence of losses such that yt 2  1 for all t. Suppose that Algorithm 16 is run using the sampling rule, estimator and potential as described above, shrunken action set A~ with r = 1 - 2d where
the learning rate is  = log(n)/(3dn). Then, the algorithm is well defined and
its regret satisfies Rn  2 3nd log(n).

28.4 Linear Bandits on the Unit Ball

337

You might notice that in some regimes this is smaller than the lower bound for stochastic linear bandits (Theorem 24.2). There is no contradiction because the adversarial and stochastic linear bandit models are actually quite different. More details are in Chapter 29.

Proof That the algorithm is well defined follows because A~ is compact. Let

a = argminaA

n t=1

a, yt

be the optimal action. Then

n

Rn = E

At - ra, yt

t=1

n
+ ra - a, yt  Rn(ra) + (1 - r)n ,
t=1

where the inequality follows from the definition of A and Cauchy­Schwarz. By Theorems 26.13 and 28.10,

Rn(ra)



diamF (A~) 

+

 2

E

n t=1

Y^t

2 (2F (Zt))-1

,

where Zt  [A¯t, A¯t+1] lies on the chord connecting A¯t and A¯t+1. The algorithm is stable in the sense that no matter how the losses are chosen, A¯t+1 cannot be too far from A¯t. This also means that Zt is close to A¯t. By definition,  Y^t  d/(1 - r) = 1/2. Combining this with Eq. (28.13) shows that

1 - Zt 1 - A¯t

 sup 1 -
[0,1]

A¯t + (1 - )A¯t+1 1 - A¯t

= max

1,

1 - A¯t+1 1 - A¯t

 max

1,

1 +  L^t-1 1 +  L^t

 max

1,

1 +  L^t-1 1/2 +  L^t-1

 2.

Here, the second inequality is proved by noting that if the maximum is not one, A¯t+1 < A¯t . The next step is to find the Hessian of F , which is

2F (a)

=

I 1-

a

+

aa a (1 -

a )2

I 1- a

.

Therefore, (2F (a))-1  (1 - a )I, and so

E

Y^t

2 (2F (Zt))-1

 E (1 -

Zt ) Y^t 2

= d2E

(1 - Zt )Et Ut, yt 2 (1 - A¯t )2

The diameter satisfies diamF (A~)  log(1/(1 - r)), and hence

 2d .

Rn



(1

-

r)n

+

1 

log

1 1-r

=

1 

log

1 2d

+ 3nd

+ nd

 2 3nd log(n) ,

where the last two relations follow from the choices of r and , respectively.

28.5 Notes

338

We could have used mirror descent rather than follow-the-regularisedleader with a slightly more complicated proof and the same bound except for constants. Using continuous exponential weights and the analysis in Section 27.3 would yield a bound that is a factor of d worse than the above, and we believe that this cannot be improved.

28.5

Notes
1 Our assumptions on the potential and action set in the analysis of mirror descent (Theorem 28.4) can be relaxed significantly. What is important is that F is convex and the directional derivative v  vF (x) is linear for all values for which it exists. Our assumptions are chosen to ensure that at  int(dom(F )), which for Legendre F means that F (at) exists, and hence vF (at) = v, F (at) is linear. A comprehensive examination of various generalisations is given by Joulani et al. [2017]. For follow-the-regularisedleader, convexity of F suffices, as you will show using directional derivatives in Exercise 28.5.
2 Finding at+1 for both mirror descent and follow-the-regularised-leader requires solving a convex optimisation problem. Provided the dimension is not too large and the action set and potential are reasonably nice, there exist practical approximation algorithms for this problem. The two-step process described in Eqs. (28.7) and (28.8) is sometimes an easier way to go. Usually (28.7) can be solved analytically, while (28.8) can be quite expensive. In some important special cases, however, the projection step can be written in closed form or efficiently approximated.
3 We saw that follow-the-regularised-leader with a carefully chosen potential function achieves O( dn log(n)) regret on the 2-ball. On the  ball (hypercube), the optimal regret is O(d n). Interestingly, as n tends to infinity the optimal dependence on the dimension for A = Bpd = {x  Rd : x p  1} with p  1 is either d or d with a complete classification given by Bubeck et al. [2018].
4 Adversarial linear bandits with A = Pk-1 are essentially equivalent to k-armed adversarial bandits. There exists a potential such that the resulting algorithm satisfies Rn = O( kn), which matches the lower bound up to constant factors and shaves a factor of log k from the upper bounds presented in Chapters 11 and 12. For more details, see Exercise 28.15.
5 Most of the bounds proven for adversarial bandits have a worst-case flavour. The tools in this chapter can often be applied to prove adaptive bounds. In Exercise 28.14, you will analyse a simple algorithm for k-armed adversarial

28.5 Notes

339

bandits for which





Rn = O 

k

n
1 + min yta
a[k] t=1

log

n k

.

Bounds of this kind are called first-order bounds [Allenberg et al., 2006,

Abernethy et al., 2012, Neu, 2015b, Wei and Luo, 2018]. The log(n/k) term

can be improved to log(k) using a more sophisticated algorithm/analysis.

6 Both mirror descent and follow-the-regularised-leader depend on the potential

function. Currently there is no characterisation of exactly what this potential

should be or how to find it. At least in the full information setting, there are

quite general universality results showing that if a certain regret is achievable

by some algorithm, then that same regret is nearly achievable by mirror descent

with some potential [Srebro et al., 2011]. In practice this result is not useful for

constructing new potential functions, however. There have been some attempts

to develop `universal' potential functions that exhibit nice behaviour for any

action sets [Bubeck et al., 2015b, and others]. These can be useful, but as yet

we do not know precisely what properties are crucial, especially in the bandit

case.

7 When the horizon is unknown, the learning rate cannot be tuned ahead of time.

One option is to apply the doubling trick. A more elegant solution is to use a

decreasing schedule of learning rates. This requires an adaptation of the proofs

of Theorems 28.4 and 28.5, which we outline in Exercises 28.11 and 28.12. This

is one situation where mirror descent and follow-the-regularised-leader are not

the same and where the latter algorithm is usually to be preferred.

8 In much of the literature the potential is chosen in such a way that mirror descent

and follow-the-regularised-leader are the same algorithm. For historical reasons,

the name mirror descent is more commonly used in the bandit community.

Unfortunately `mirror descent' is often used, sometimes with qualifiers, when

the algorithm being analysed is actually follow-the-regularised-leader. This is

confusing and makes it hard to identify for which algorithm the results actually

hold. Naming aside, we encourage the reader to keep both algorithms in mind,

since the analysis of one or the other can sometimes be slightly easier.

9 Mirror descent and follow-the-regularised-leader are used as modules for

converting loss sequences to distributions. Since these losses depend on past

actions, it is crucial that both algorithm are well-behaved in the full-information

setting when the losses are chosen non-obliviously. This does not translate to

the bandit setting for a subtle reason. Let R^n(a) =

n t=1

At

- a, yt

be the

random regret so that

n

n

Rn = E

max
aA

R^n

(a)

=E

At, yt

- min
aA

a, yt .

t=1

t=1

The second sum is constant when the losses are oblivious, which means the maximum can be brought outside the expectation, which is not true if the loss

28.5 Notes

340

vectors are non-oblivious. It is still possible to bound the expected loss relative to a fixed comparator a so that

n

Rn(a) = E

At - a, yt

t=1

B,

where B is whatever bound obtained from the analysis presented above. Using maxa R^n(a)  maxa R^n(a) - Rn(a) + maxa Rn(a) shows that

Rn = E

max
aA

R^n

(a)

B+E

max
aA

R^n

(a)

-

Rn(a)

.

The second term on the right-hand side empirical process theory, but the resulting

bcoaunndbeisbOou(ndne)donulsyinigf

tools from V[R^n(a)] =

O(n). In general, however, the variance can be much larger (for an example, see

Exercise 11.6). We emphasise again that the non-oblivious regret is a strange

measure because it does not capture the reactive nature of the environment.

The details of the application of empirical process theory is beyond the scope

of this book. For an introduction to that topic, we recommend the books by

van der Vaart and Wellner [1996], van de Geer [2000], Boucheron et al. [2013]

and Dudley [2014].

10 The price of bandit information on the unit ball is an extra d log(n) (compare

Proposition 28.6 and Theorem 28.11). Except for log factors, this is also true for

the simplex (Proposition 28.7 and Note 4). One might wonder if the difference is always about d, but this is not true. The price of bandit information can

be as high as (d). Overall the dimension dependence in the regret in terms of

the action set is still not well understood except for special cases.

11 The poor behaviour of follow-the-leader in the full information setting depends

on (a) the environment being adversarial rather than stochastic and (b) the

action set having sharp corners. When either of these factors is missing, follow-

the-leader is a reasonable choice [Huang et al., 2017b]. Note that with bandit

feedback, the failure is primarily due to a lack of exploration (Exercises 4.11

and 4.12).

12 A generalisation of online linear optimisation is online convex optimisation,

where the adversary secretly chooses a sequence of convex functions f1, . . . , fn. In each round the learner chooses at  A and observes the entire function ft. As usual, the regret is relative to a  A is

n
Rn(a) = ft(at) - ft(a) .
t=1
One way to tackle this problem is to linearise the loss functions. Let yt = ft(at). Then, by convexity of the loss functions,
n
Rn(a)  at - a, yt ,
t=1
which shows that an algorithm for online linear optimisation can be used to

28.6 Bibliographic Remarks

341

analyse the more general case. Now look again at Example 28.1 and notice that online mirror descent with a quadratic potential and linearised losses is really the same gradient descent we know and love. Online convex optimisation is a rich topic by itself. We refer the interested reader to the books by ShalevShwartz [2012] and Hazan [2016].
13 There is a nice application of online linear optimisation to minimax theorems. Let X and Y be arbitrary sets. For any function f : X × Y  R,

inf sup f (x, y)  sup inf f (x, y) .

xX yY

yY xX

Under certain conditions, the inequality becomes an equality. Theorems guaranteeing this are called minimax theorems. The following result by Sion [1958] is one of the more generic variants. The statement uses notions of quasi-convexity and semi-continuity, which are defined in the next note.

Theorem 28.12 (Sion's minimax theorem). Suppose that X and Y are convex
subsets of linear topological spaces with at least one of X or Y compact. Let f : X × Y  R be a function such that f (·, y) is lower semi-continuous and quasi-convex for all y  Y and f (x, ·) is upper semi-continuous and quasi-
concave for all x  X. Then

inf sup f (x, y) = sup inf f (x, y) .

xX yY

yY xX

There is a short topological proof of this theorem [Komiya, 1988]. You will use the tools of online linear optimisation to analyse two special cases in Exercise 28.16. When X and Y are probability simplexes and f is linear, the resulting theorem is von Neumann's minimax theorem [von Neumann, 1928]. The minimax theorems form a bridge between minimax adversarial regret and Bayesian regret, which we discuss in Chapters 34 and 36. 14 Let X be a subset of a linear topological space and f : X  R. The function f is quasi-convex if f -1((-, a)) is convex for all a  R and quasi-concave if -f is quasi-convex. f is upper semi-continuous if for all x  X and  > 0 there exists a neighborhood U of x such that f (y)  f (x) +  for all y  U . It is lower semi-continuous if for all x  X and  > 0 there exists a neighborhood U of x such that f (y)  f (x) -  for all y  U .

28.6

Bibliographic Remarks
The results in this chapter come from a wide variety of sources. The online convex optimisation framework was popularised by Zinkevich [2003]. The framework has been briefly considered by Warmuth and Jagota [1997], then reintroduced by Gordon [1999] (without noticing the earlier work of Warmuth and Jagota). While the framework was introduced relatively recently, the core ideas have been worked out earlier in the special case of linear prediction with nonlinear

28.7 Exercises

342

losses (the book of Cesa-Bianchi and Lugosi [2006] can be used as a reference to this literature). Mirror descent was first developed by Nemirovsky [1979] and Nemirovsky and Yudin [1983] for classical optimisation. In statistical learning, follow-the-regularised-leader is known as regularised risk minimisation and has a long history. In the context of online learning, Gordon [1999] considered follow-the-regularised-leader and called it `generalised gradient descent'. The name seems to originate from the work of Shalev-Shwartz [2007] and Shalev-Shwartz and Singer [2007]. An implicit form of regularisation is to add a perturbation of the losses, leading to the `follow-the-perturbed-leader' algorithm [Hannan, 1957, Kalai and Vempala, 2002], which is further explored in the context of combinatorial bandit problems in Chapter 30 (and see also Exercise 11.7). Readers interested in an overview of online learning will like the short books by Shalev-Shwartz [2012] and Hazan [2016], while the book by Cesa-Bianchi and Lugosi [2006] has a little more depth (but is also older). As far as we know, the first explicit application of mirror descent to bandits was by Abernethy et al. [2008]. Since then the idea has been used extensively, with some examples by Audibert et al. [2013], Abernethy et al. [2015], Bubeck et al. [2018] and Wei and Luo [2018]. Mirror descent has been adapted in a generic way to prove high-probability bounds by Abernethy and Rakhlin [2009]. The reader can find (slightly) different proofs of some mirror descent results in the book by Bubeck and Cesa-Bianchi [2012]. The results for the unit ball are from a paper by Bubeck et al. [2012], but we have reworked the proof to be more in line with the rest of the book. Mirror descent can be generalised to Banach spaces. For details, see the article by Sridharan and Tewari [2010].

28.7

Exercises
28.1 Let F : Rd  R  {} be Legendre with domain D  Rd and A  Rd be convex, and for b  int(D) and y  Rd let (a) = a, y + DF (a, b). Suppose that c  argminaA (a) exists and A  int(D) = . Show that c  int(D)
28.2 (Ill-defined actions) Given an example of a non-empty bounded convex action set A, convex potential F and sequences of losses (yt)nt=1 where the choices of mirror descent and/or follow-the-regularised-leader either:
(a) exist but are not unique; (b) do not exist at all.
Prove that if F is Legendre and A is non-empty and compact, then (at)nt=1 exist and are unique for both mirror descent and follow-the-regularised-leader.
28.3 Prove the correctness of the two-step procedure described in Section 28.1.1.
28.4 (Linear regret for follow-the-leader) Let A = [-1, 1], and let y1 = 1/2 and ys = 1 for odd s > 1 and ys = -1 for even s > 1.

28.7 Exercises

343

(a) Recall that follow-the-leader (without regularisation) chooses at =

argmina

t-1 s=1

a, ys

.

Show

that

this

algorithm

suffers

linear

regret

on

the

above sequence.

(b) Implement follow-the-regularised-leader or mirror descent on this problem

with quadratic potential F (a) = a2 and plot at as a function of time.

28.5 (Regret for follow-the-regularised-leader) Prove Theorem 28.5.

28.6 (Regret in terms of local dual norms) Prove Corollary 28.8.

28.7 (Follow-the-regularised-leader for the unit ball) Prove the equality in Eq. (28.13).

28.8 (Exponential weights as mirror descent) Prove the equality in Eq. (28.5).

28.9 (Exp3 as mirror descent) Let A = Pk-1 be the simplex, F the unnormalised negentropy potential and  > 0. Let P1 = argminpA F (p), and for t > 1,
Pt+1 = argminpA  p, Y^t + DF (p, Pt) ,
where Y^ti = I {At = i} yti/Pti and At is sampled from Pt.

(a) Show that the resulting algorithm is exactly Exp3 from Chapter 11. (b) What happens if you replace mirror descent by follow-the-regularised-leader,

t

Pt+1 = argminpA

p, Y^s + F (p)

?

s=1

28.10 (Exp3 as mirror descent (ii)) Here you will show that the tools in this chapter not only lead to the same algorithm, but also the same bounds.
(a) Let P~t+1 = argminp[0,)k  p, Y^t + DF (p, Pt). Show both relations in the following display:

DF (Pt, P~t+1) =

k
Pti

exp(-Y^ti) - 1 + Y^ti



2 2

k
PtiY^t2i .

i=1

i=1

(b)

Show

that

1 

E

n
DF (Pt, P~t+1)
t=1



nk 2

.

(c) Show that diamF (Pk-1) = log(k).

(d) Conclude that for appropriately tuned  > 0, the regret of Exp3 satisfies,

Rn  2nk log(k) .

Hint Use Theorem 26.6(b).
28.11 (Mirror descent and changing learning rates) Let A be a convex set and y1, . . . , yn  L  Rd. Let F be Legendre with domain D with

28.7 Exercises

344

A  int(D) non-empty and assume that Eq. (28.6) holds. Let 0, 1, . . . , n > 0, a1, a2, . . . , an+1  A and a~2, . . . , a~n+1 be sequences so that 0 = , a1 = argminaA F (a) and

a~t+1 = argminaD t a, yt + DF (a, at) , at+1 = argminaAD DF (a, a~t+1) .

Show that for all a  A,

n
(a) Rn(a) = at - a, yt
t=1



n t=1

DF (at, a~t+1) t

+

n t=1

DF

(a,

at)

- DF t

(a,

a~t+1)

;

and

(b)

Rn(a) 

n t=1

DF (at, a~t+1) t

n
+ DF (a, at)
t=1

1- 1 t t-1

.

The statement allows the time-varying learning rate sequence (t)t to be constructed in any way. This flexibility can be useful when designing adaptive algorithms. A sequence of learning rates (t)t is said to be non-anticipating if for each t, t depends on data available at the end of round t.

28.12 (follow-the-regularised-leader and changing potentials) Like

in the previous exercise, let A be non-empty and convex and y1, . . . , yn  L  Rd.

Let F1, . . . , Fn, Fn+1 be a sequence of convex functions and t(a) = Ft(a) +

t-1 s=1

a, ys

and at = argminaA t(a), which you may assume are well defined.

(a) Show that
n
Rn(a)  ( at - at+1, yt - DFt (at+1, at))
t=1 n
+ Fn+1(a) - F1(a1) + (Ft(at+1) - Ft+1(at+1)) .
t=1

(b) Show that if Ft = F/t and (t)tn=+11 is decreasing with n = n+1, then

Rn(a)



F (a)

- minbA F (b) n

+

n t=1

at - at+1, yt

-

DF (at+1, at) t

.

Again, the statement applies to any sequence of Legendre functions, including those that are constructed based on the past.

28.13 (Anytime version of Exp3) Consider the k-armed adversarial bandit problem described in Chapter 11, where the adversary chooses (yt)nt=1 with

28.7 Exercises

345

yt  [0, 1]k. Let Pt  Pk-1 be defined by

Pti =

exp -t

t-1 s=1

Y^si

,

k j=1

exp

-t

t-1 s=1

Y^sj

where (t) t=1 is an infinite sequence of learning rates and Y^ti = I {At = i} yti/Pti and At is sampled from Pt.

(a) Let A = Pk-1 be the simplex, F be the unnormalised negentropy potential,

Ft(p) = F (p)/t and t(p) = F (p)/t +

t-1 s=1

p, Y^s

.

Show

that

Pt

is

the

choice of follow-the-regularised-leader with potentials (Ft)tn=1 and losses

(Y^t)nt=1.

(b) Assume that (t)nt=1 are decreasing and then use Exercise 28.12 to show that

Rn



log(k) n

+

E

n
Pt - Pt+1, Y^t
t=1

-

DF (Pt+1, Pt) t

.

(c) Use Theorem 26.13 in combination with the facts that Y^ti  0 for all i and Y^ti = 0 unless At = i to show that

Pt - Pt+1, Y^t

-

DF (Pt+1, Pt) t



t 2PtAt

.

(d)

Prove

that

Rn



log(k) n

+

k 2

n
t.
t=1

(e) Choose (t)t=1 so that Rn  2 nk log(k) for all n  1.

28.14 (The log barrier and first-order bounds) Your mission in this

exercise is to prove first-order bounds for finite-armed bandits as studied in

Chapter 11. The notation is the same as the previous exercise. Let (yt)nt=1 be

a sequence of loss vectors with yt  [0, 1]k for all t and F (a) = -

k i=1

log(ai

).

Consider the instance of follow-the-regularised-leader for bandits that samples

At from Pt defined by

t-1

Pt = argminpPk-1 t

p, Y^s + F (p) .

s=1

(a) Show a particular, non-anticipating choice of the learning rates (t)nt=1 so that

n-1

Rn  k + 2 k 1 + E

yt2At

t=1

log

nk k

.

(28.14)

(b) Prove that any algorithm satisfying Eq. (28.14) also satisfies

Rn  k + k log

nk k

+C

k

n
1 + min yta
a[k] t=1

log

nk k

,

28.7 Exercises

346

where C is a suitably large universal constant.
Hint For choosing the learning rate, you might take inspiration from Theorem 18.3.
The algorithm in this exercise is a simplified variant of the algorithm analysed by Wei and Luo [2018].

28.15 (Minimax regret for finite-armed adversarial bandits) Let

(-yt2)nt=1ik=b1 eaai.seCqounesnidceer

of loss vectors the instance of

with yt  [0, 1]k for all t and follow-the-regularised-leader for

F (a) = k-armed

adversarial bandits that samples At  [k] from Pt defined by

t-1

Pt = argminpPk-1 

p, Y^s + F (p) ,

s=1

where Y^si = I {As = i} ysi/Psi is the importance-weighted estimator of ysi and  > 0 is the learning rate.

(a) Show that

Pti =

t-1
 + Y^si
s=1

-2
,

where   R is the largest value such that Pti  Pk-1.

(b) Show that Pt+1,At  PtAt for all t  [n - 1].

(c)

Show

that

2F (x) =

1 2

diag(x-3/2).

(d) Show that diamF (A)  2 k.



(e) Prove that the regret of this algorithm is bounded by Rn  8kn.

(f) What happens if you use mirror descent instead of follow-the-regularised-

leader. Are the resulting algorithms the same? And if not, what can you

prove for mirror descent?

(g) Explain how you would implement this algorithm.

(h) Prove that if the learning rate is chosen in a time-dependent way to be t = 1/ t, then the resulting instantiation of follow-the-regularised-leader satisfies Rn = O( nk) for adversarial bandits and Rn = O( i:i>0 log(n)/i) for stochastic bandits with losses in [0, 1].

The algorithm in the above exercise is called the implicitly normalised forecaster (INF) and was introduced by Audibert and Bubeck [2009]. The last part of the exercise is very difficult. For `hints', see the articles by Zimmert and Seldin [2019] and Zimmert et al. [2019].

28.7 Exercises

347

28.16 (Minimax theorem) In this exercise you will prove simplified versions of Sion's minimax theorem.
(a) Use the tools from online linear optimisation to prove Sion's minimax theorem when X = Pk-1 and Y = Pj-1 and f (x, y) = x Gy for some G  Rk×j.
(b) Generalise your result to the case when X and Y are non-empty, convex, compact subsets of Rd and f : X × Y  R is convex/concave and has bounded gradients.

Hint Consider a repeated simultaneous game where the first player chooses

(xt)t=1 and the second player chooses (yt)t=1. The loss in round t to the first

player is f (xt, yt), and the loss to the second player is -f (xt, yt). See what

happens

to

the

average

iterates

x¯n

=

1 n

n t=1

xt

and

y¯n

=

1 n

n t=1

yt

when

(xt)

and (yt) are chosen by (appropriate) regret-minimising algorithms. For the second

part, see Note 12. Also observe that there is nothing fundamental about X and

Y both having dimension d.

28.17 (Counterexample to Sion without compactness) Find examples of X, Y and f that satisfy the conditions of Sion's theorem except that neither X nor Y are compact and where the statement does not hold. Can you choose f to be bounded?

29 The Relation between Adversarial and Stochastic Linear Bandits

The purpose of this chapter is to highlight some of the differences and connections between adversarial and stochastic linear bandits. As it turns out, the connection between these are not as straightforward as for finite-armed bandits. We focus on three topics:
(a) For fixed action sets, there is a reduction from stochastic linear bandits to adversarial linear bandits. This does not come entirely for free. The action set needs to be augmented for things to work (Section 29.2).
(b) The adversarial and stochastic settings make different assumptions about the variability of the losses/rewards. This will explain the apparently contradictory result that the upper bound for adversarial bandits on the unit ball is O( dn log(n)) (Theorem 28.11), while the lower bound for stochastic bandits also for the unit ball is (d n) (Theorem 24.2).
(c) When the action set is changing, the notion of regret in the adversarial setting must be carefully chosen, and for the `right' choice, we do not yet have effective algorithms (Section 29.4).
We start with a unified view of the two settings.

29.1

Unified View

To make the notation consistent, we present the stochastic
and adversarial linear bandit frameworks again using losses for both. Let A  Rd be the action set. In each round, the learner chooses At  A and receives the loss Yt, where

Yt = At,  + t ,

(Stochastic setting) (29.1)

Yt = At, t ,

(Adversarial setting) (29.2) Figure 29.1 A tricky

and (t)nt=1 is a sequence of independent and identically relationship distributed 1-subgaussian random variables and (t)nt=1 is a sequence of loss vectors chosen by the adversary. As noted earlier, the assumptions on the noise

can be relaxed significantly. For example, if Ft = (A1, Y1, . . . , At, Yt, At+1), then the results of the previous chapters hold as soon as t is 1-subgaussian conditioned

29.2 Reducing Stochastic Linear Bandits to Adversarial Linear Bandits

349

on Ft-1. The expected regret for the two cases are defined as follows:

n

Rn =

E[

At, 

] - n inf
aA

a, 

,

t=1

n

Rn =

E [ At, t

]

-

n inf
aA

a, ¯n

.

t=1

(Stochastic setting) (Adversarial setting)

In

the

last

display,

¯n

=

1 n

n t=1

t

is

the

average

of

the

loss

vectors

chosen

by

the adversary.

29.2

Reducing Stochastic Linear Bandits to Adversarial Linear Bandits
To formalise the intuition that adversarial environments are harder than stochastic environments, one may try to find a reduction where learning in the stochastic setting is reduced to learning in the adversarial setting. Here, reducing problem E (`easy') to problem H (`hard') just means that we can use algorithms designed for problem H to solve instances of problem E. In order to do this, we need to transform instances of problem E into instances of problem H and translate back the actions of algorithms designed for H to actions for problem E. To get a regret bound for problem E from a regret bound for problem H, one needs to ensure that the losses translate properly between the problem classes.
Of course, based on our previous discussion, we know that if there is a reduction from stochastic linear bandits to adversarial linear bandits, then somehow the adversarial problem must change so that no contradiction is created in the curious case of the unit ball. To be able to use an adversarial algorithm in the stochastic environment, we need to specify a sequence (t)t so that the adversarial feedback matches the stochastic one. Comparing Eq. (29.1) and Eq. (29.2), we can see that the crux of the problem is incorporating the noise t into t while satisfying the other requirements. One simple way of doing this is by introducing an extra dimension for the adversarial problem.
In particular, suppose that the stochastic problem is d-dimensional so that A  Rd. For the sake of simplicity, assume furthermore that the noise and parameter vector satisfy | a,  + t|  1 almost surely for all a  A and that a = argminaA a,  exists. Then define Aaug = {(a, 1) : a  A}  Rd+1 and let the adversary choose t = (, t)  Rd+1. Here, we slightly abuse notation: for x  Rd and y  R, we use (x, y) to denote the d + 1 dimensional vector whose first d components are those of x and whose last component is y. The reduction is now straightforward: for t = 1, 2, . . . , do the following:
1 Initialise adversarial bandit policy with action set Aaug. 2 Collect action At = (At, 1) from the policy. 3 Play At and observe loss Yt.

29.3 Stochastic Linear Bandits with Parameter Noise

350

4 Feed Yt to the adversarial bandit policy, increment t and repeat from step 2.

Suppose the adversarial policy guarantees a bound Bn on the expected regret:

n

n

Rn = E

At, t
t=1

- inf
a Aaug

t=1

a

, t

 Bn .

Let a = (a, 1). Note that for any a = (a, 1)  Aaug, At,  - a,  = At, t - a , t and thus adversarial regret, and eventually Bn, will upper bound the stochastic regret:

n

E

At,  - n a, 

t=1

n

=E

At, t - n a, ¯n

t=1

 Rn  Bn .

Therefore, the expected regret in the stochastic bandit is also at most Bn. We
have to emphasise that this reduction changes the geometry of the decision sets for both the learner and the adversary. For example, if A = B2d is the unit ball, then neither Aaug nor

y  Rd : sup | a, y |  1
aAaug

are unit balls. It does least in the case of the

not seem like ball, from our

th(ids shno)ullodwmerabkoeumnducohn

difference, the regret

but at for the

stochastic case, we see that the changed geometry must make the adversary more

powerful. This reinforces the importance of the geometry of the action set, which

we have already seen in the previous chapter.

While the reduction shows one way to use adversarial algorithms in stochastic

environments, the story seems to be unfinished. When facing a linear bandit

problem with some action set A, the user is forced to decide whether or not

the environment is stochastic. Strangely enough, for stochastic environments the

recommendation is to run your favorite adversarial linear bandit algorithm on the

augmented action set. What if the environment may or may not be stochastic?

One can still run the adversarial linear bandit algorithm on the original action

set. This usually works, but the algorithm may need to be tuned differently

(Exercises 29.2 and 29.3).

29.3

Stochastic Linear Bandits with Parameter Noise
The real reason for all these discrepancies is that the adversarial linear bandit model is better viewed as relaxation of another class of stochastic linear bandits. Rather than assuming the noise is added after taking an inner product, assume that (t)nt=1 is a sequence of vectors sampled independently from a fixed distribution  on Rd. The resulting model is called a stochastic linear bandit with parameter noise. This new problem can be trivially reduced to adversarial

29.3 Stochastic Linear Bandits with Parameter Noise

351

bandits when Supp() is bounded (Exercise 29.1). In particular, there is no need to change the action set.
Combining the stochastic linear bandits with parameter noise model with the techniques in Chapter 24 is the standard method for proving lower bounds for adversarial linear bandits.

Parameter noise environments form a subset of all possible stochastic environments. To see this, let  = x(dx) be the mean parameter vector under . Then the loss in round t is

At, t = At,  + At, t -  .

Let Et[·] = E[· | Ft-1]. By our assumption that  has mean , the second term vanishes in expectation, Et[ At, t -  ] = 0. This implies that we can make a connection to the `vanilla' stochastic setting by letting ~t = At, t -  . Now
consider the conditional variance of ~t:

Vt[~t] = Et[ At, t -  2] = At Et[(t - )(t - ) ]At = At At , (29.3)

where  is the covariance matrix of multivariate distribution . Eq. (29.3) implies

that the variance of the noise ~t now depends on the choice of action and in

particular the noise variance scales with the length of At. This can make parameter

noise problems easier. For example, if  is a Gaussian with identity covariance,

then Vt[~t] =

At

2 2

so

that

long

actions

have

more

noise

than

short

actions.

By contrast, in the usual stochastic linear bandit, the variance of the noise is

unrelated to the length of the action. In particular, even the noise accompanying

short actions can be large. This makes quite a bit of difference in cases when

the action set has both short and long actions. In the standard stochastic model,

shorter actions have the disadvantage of having a worse signal-to-noise ratio,

which an adversary can exploit.

This calculation also provides the reason for the different guarantees for the

Out~hn(eidtrebngar)le,l.twFihsoiOrl~e(sitnodctnhh)ae.sltTaicshtilsicnhdeaiaspcrtreebrpaawnndeciysthsioswweiextdhplta1hi-nastuedbfogbrayuasdtshvieearnvsaanrrioiaainsl ecleinthoefaertrhbeegarnnedotiitsises,.

Suppose that  is supported on the unit sphere. Then the eigenvalues of its

covariance matrix sum to one and if the learner chooses At from the uniform

probability measure µ on the sphere, then

E[Vt[~t]] = a a dµ(a) = 1/d .

By contrast, in the standard stochastic model with 1-subgaussian noise, the predictable variation of the noise is just 1. If the adversary were allowed to choose its loss vectors from the sphere of radius d, then the expected predictable variation would be 1, matching the standard stochastic case, and the regret would scale linearly in d, which also matches the vanilla stochastic case. This example

29.4 Contextual Linear Bandits

352

further emphasises the importance of the assumptions that restrict the choices of the adversary.
The best way to think about the standard adversarial linear model is that it generalises the stochastic linear bandit with parameter noise. Linear bandits with parameter noise are sometimes easier than the standard model because parameter noise limits the adversary's control of the signal-to-noise ratio experienced by the learner.

29.4

Contextual Linear Bandits

In practical applications the action set is usually changing from round to round.
Although it is possible to prove bounds for adversarial linear bandits with changing
action sets, the notion of regret makes the results less meaningful than what one obtains in the stochastic setting. Suppose that (At)tn=1 are a sequence of action sets. In the stochastic setting, the actions (At)t selected by the LinUCB algorithm satisfy

n

E

At - at, 

t=1

= O~(dn) ,

where at = argmaxaAt a,  is the optimal action in round t. This definition of the regret measures the right thing: the action at really is the optimal action in round t. The analogous result for adversarial bandits would be a bound on

n

Rn()

=

max


E

At - at(), yt
t=1

,

(29.4)

where  is a subset of Rd and at() = argmaxaAt a,  . Unfortunately, however, we do not currently know how to design algorithms for which this regret is small. For finite , the techniques of Chapter 27 are easily adapted to prove a bound of O( dn log ||), but this algorithm is (a) not computationally efficient for large ||, and (b) choosing  as an -covering of a continuous set does not guarantee a bound against the larger set. Providing a meaningful bound on Eq. (29.4) when  is a continuous set like { :  2  1} is a fascinating challenge. The reader may recall that the result in Exercise 27.5 provides a bound for adversarial linear bandits with changing action sets. However, in this problem the actions have `identities', and the regret is measured with respect to the best action in hindsight, which is a markedly different objective than the one in Eq. (29.4).

29.5 Notes

353

29.5

Notes

1 For the reduction in Section 29.2, we assumed that |Yt|  1 almost surely. This is not true for many classical noise models like the Gaussian. One way to overcome this annoyance is to apply the adversarial analysis on the event that |Yt|  C for some constant C > 0 that is sufficiently large that the probability that this event occurs is high. For example, if t is a standard Gaussian and supaA | a,  |  1, then C may be chosen to be 1 + 4 log(n), and the failure event that there exists a t such that | At,  + t|  C has probability at most 1/n by Theorem 5.3 and a union bound.
2 The mirror descent analysis of adversarial linear bandits also works for stochastic bandits. Recall that mirror descent samples At from a distribution with a conditional mean of A¯t, and suppose that ^t is a conditionally unbiased estimator of . Then the regret for a stochastic linear bandit with optimal action a can be rewritten as

n

n

n

Rn = E

At - a,  = E

A¯t - a,  = E

A¯t - a, ^t ,

t=1

t=1

t=1

which is in the standard format necessary for the analysis of mirror descent/follow-the-regularised-leader. In the stochastic setting, the covariance of the least squares estimator ^t will not be the same as in the adversarial setting, however, which leads to different results. When ^t is biased, the bias term can be incorporated into the above formula and then bounded separately. 3 Consider a stochastic bandit with A = B2d the unit ball and Yt = At,  + t where |Yt|  1 almost surely and  2  1. Adapting the analysis of the algorithm in Section 28.4 leads to a bound of Rn = O(d n log(n)). Essentially the only change is the variance calculation, which increases by roughly a factor of d. The details of this calculation are left to you in Exercise 29.2. When A is finite, the analysis of Exp3 with Kiefer­Wolfowitz exploration (Theorem 27.1) leads to an algorithm for which Rn = O( dn log(k)). For convex A, you can use continuous exponential weights (Section 27.3).
4 You might wonder whether or not an adversarial bandit algorithm is well behaved for stochastic bandits where the model is almost linear (the misspecified linear bandit). Suppose the loss is nearly linear in the sense that

Yt = (At) + t ,
where (At) = At,  + (At) and  : A  R is some function with small supremum norm. Because (At) depends on the chosen action, it is not possible to write Yt = At, t for t independent of At. When A = B2d is the unit ball, you will show in Exercise 29.4 that an appropriately tuned instantiation of follow-the-regularised-leader satisfies Rn = O(d n log(n) + n d), where  = supaA (a). This improves by logarithmic factors on the more generic algorithm in Chapter 22.

29.6 Bibliographic Remarks

354

29.6

Bibliographic Remarks

Linear bandits on the sphere with parameter noise have been studied by Carpentier

and Munos [2012]. However they consider the case where the action set is the

sphere and the components of the noise are independent so that the reward is

Xt = At,  + t where the coordinates of t  Rd are independent with unit

variance. In this case, the predictable variation is V[Xt | At] =

d i=1

A2ti

=

1

for

all actions At and the parameter noise is equivalent to the standard model. We

are not aware of any systematic studies of parameter noise in the stochastic

setting. With only a few exceptions, the impact on the regret of the action set

and adversary's choices is not well understood beyond the case where A is an

p-ball, which has been mentioned in the previous section. A variety of lower

bounds illustrating the complications are given by Shamir [2015]. Perhaps the most informative is the observation that obtaining O( dn) regret is not possible

when A = {a + x : x 2  1} is a shifted unit ball with a = (2, 0, . . . , 0), which

also follows from our reduction in Section 29.2.

29.7

Exercises
29.1 (Reductions) Let A  Rd be an action set and L = {y  Rd : supaA | a, y |  1}. Take an adversarial linear bandit algorithm that enjoys a worst-case guarantee Bn on its n-round expected regret Rn when the adversary is restricted to playing t  L. Show that if this algorithm is used in a stochastic linear bandit problem with parameter noise where t   and Supp()  L, then the expected regret Rn is still bounded by Bn.
29.2 (Follow-the-regularised-leader for stochastic bandits (i)) Consider a stochastic linear bandit with A = B2d and loss Yt = At,  + t where (t)tn=1 are independent with zero mean and Yt  [-1, 1] almost surely. Adapt the proof of Theorem 28.11 to show that with appropriate tuning the algorithm in Section 28.4 satisfies Rn  Cd n log(n) for universal constant C > 0.
Hint Repeat the analysis in the proof of Theorem 28.11, update the learning rate and check the bounds on the norm of the estimators.
29.3 (Follow-the-regularised-leader for stochastic bandits (ii)) Repeat the previous exercise using exponential weights or continuous exponential weights with Kiefer­Wolfowitz exploration where
(a) A is finite; and (b) A is convex.
29.4 (Misspecified linear bandits) Let A  Rd and (t)tn=1 be a sequence

29.7 Exercises

355

of independent zero-mean random variables and assume the loss is
Yt = (At) + t ,
where (At) = At,  + (At) and  = supaA (a) and |Yt|  1 almost surely. (a) Suppose that A = B2d. Show that the expected regret of an appropriately
tuned version of the algorithm in Section 28.4 satisfies 
Rn  C(d n log(n) + n d) ,
where C > 0 is a universal constant. (b) Do you think the result from Part (a) can be improved? (c) Suppose that A is finite. What goes wrong in the analysis of exponential
weights with Kiefer­Wolfowitz exploration (Algorithm 15)?

Part VII
Other Topics

357

In the penultimate part, we collect a few topics to which we could not dedicate a whole part. When deciding what to include, we balanced our subjective views on what is important, pedagogical and sufficiently well understood for a book. Of course we have played favourites with our choices and hope the reader can forgive us for the omissions. We spend the rest of this intro outlining some of the omitted topics.

Continuous-Armed Bandits
There is a small literature on bandits where the number of actions is infinitely large. We covered the linear case in earlier chapters, but the linear assumption can be relaxed significantly. Let A be an arbitrary set and F a set of functions from A  R. The learner is given access to the action set A and function class F. In each round, the learner chooses an action At  A and receives reward Xt = f (At) + t, where t is noise and f  F is fixed, but unknown. Of course this set-up is general enough to model all of the stochastic bandits so far, but is perhaps too general to say much. One interesting relaxation is the case where A is a metric space and F is the set of Lipschitz functions. We refer the reader to papers by Kleinberg [2005], Auer et al. [2007], Kleinberg et al. [2008], Bubeck et al. [2011], Slivkins [2014], Magureanu et al. [2014] and Combes et al. [2017], as well as the book of Slivkins [2019].

Infinite-Armed Bandits Consider a bandit problem where in each round the learner can choose to play an arm from an existing pool of Bernoulli arms or to add another Bernoulli arm to the pool with mean sampled from a uniform distribution. The regret in this setting is defined as

n

Rn = n - E

Xt .

t=1

This problem is studied by Berry et al. [1997], who show that Rn = (n1/2) is the optimal regret. There are now a number of strengthening and generalisations of this work [Wang et al., 2009, Bonald and Proutiere, 2013, Carpentier and Valko, 2015, for example], which sadly must be omitted from this book. The notable difficulty is generalising the algorithms and analysis to the case where reservoir distribution from which the new arms are sampled is unknown and/or does not exhibit a nice structure.

Duelling Bandits
In the duelling bandit problem, the learner chooses two arms in each round At1, At2. Rather than observing a reward for each arm, the learner observes the winner of a `duel' between the two arms. Let k be the number of arms and P  [0, 1]k×k be a matrix where Pij is the probability that arm i beats arm j in a duel. It is natural to assume that Pij = 1 - Pji. A common, but slightly less justifiable, assumption is the existence of a total ordering on the arms such that

358

if i j, then Pij > 1/2. There are at least two notions of regret. Let i be the optimal arm so that i j for all j = i. Then the strong and weak regret are
defined by

n

Strong regret = E

(Pi,At1 + Pi,At2 - 1) ,

t=1

n

Weak regret = E

min {Pi,At1 - 1/2, Pi,At2 - 1/2} .

t=1

Both definitions measure the number of times arms with low probability of winning a duel against the optimal arm is played. The former definition only vanishes when At1 = At2 = i, while the latter is zero as soon as i  {At1, At2}. The duelling bandit problem was introduced by Yue et al. [2009] and has seen quite a lot of interest since then [Yue and Joachims, 2009, 2011, Ailon et al., 2014, Zoghi et al., 2014, Dud´ik et al., 2015, Jamieson et al., 2015, Komiyama et al., 2015a, Zoghi et al., 2015, Wu and Liu, 2016, Zimmert and Seldin, 2019].

Convex Bandits Let A  Rd be a convex set. The convex bandit problem comes in both stochastic and adversarial varieties. In both cases, the learner chooses At from A. In the stochastic case, the learner receives a reward Xt = f (At) + t where f is an unknown convex function and t is noise. In the adversarial setting, the adversary chooses a sequence of convex functions f1, . . . , fn and the learner receives reward Xt = ft(At). This turned out to be a major challenge over the last decade with most approaches leading to suboptimal regret in terms of the horizon. The best bounds in the stochastic case are by Agarwal et al. [2011], while in the adversarial case there has been a lot of recent progress [Bubeck et al., 2015a, Bubeck and Eldan, 2016, Bubeck et al., 2017]. In both cases the dependence of the regret on the horizon is O( n), which is optimal in the worst case. Many open question remain, such as the optimal dependence on the dimension, or the related problem of designing practical low-regret algorithms. The interested reader may consult Shamir [2013] and Hu et al. [2016] for some of the open problems.

Budgeted Bandits

In many problems, choosing an action costs some resources. In the bandits-with-

knapsacks problem, the learner starts with a fixed budget B  [0, )d over

d resource types. Like in the standard K-armed stochastic bandit, the learner

chooses At  [K] and receives a reward Xt sampled from a distribution depending

on At. The twist is that the game does not end after a fixed number of rounds.

Instead, in each round, the environment samples a cost vector Ct  [0, 1]d from a

distribution that depends on At. The game ends in the first round  for which

there exists an i  [d] such that

 t=1

Cti

>

Bi.

This

line

of

work

was

started

by

Badanidiyuru et al. [2013] and has been extended in many directions by Agrawal

and Devanur [2014], Tran-Thanh et al. [2012], Ashwinkumar et al. [2014], Xia

359
et al. [2015], Agrawal and Devanur [2016], Tran-Thanh et al. [2010] and Hanawal et al. [2015]. A somewhat related idea is the conservative bandit problem where the goal is to minimise regret subject to the constraint that the learner must not be much worse than some known baseline. The constraint limits the amount of exploration and makes the regret guarantees slightly worse [Sui et al., 2015, Wu et al., 2016, Kazerouni et al., 2017].
Learning with Delays In many practical applications, the feedback to the learner is not immediate. The time between clicking on a link and buying a product could be minutes, days, weeks or longer. Similarly, the response to a drug does not come immediately. In most cases, the learner does not have the choice to wait before making the next decision. Buyers and patients just keep coming. Perhaps the first paper for online learning with delays is by Weinberger and Ordentlich [2002], who consider the full information setting. Recently this has become a hot topic, and there has been a lot of follow-up work extending the results in various directions [Joulani et al., 2013, Desautels et al., 2014, Cesa-Bianchi et al., 2016, Vernade et al., 2017, 2018, Pike-Burke et al., 2018, and others]. Learning with delays is an interesting example where the adversarial and stochastic models lead to quite different outcomes. In general the increase in regret due to rewards being delayed by at most  rounds is a multiplicative  factor for adversarial models and an additive term only for stochastic models.
Graph Feedback There is growing interest in feedback models that lie between the full information and bandit settings. One way to do this is to let G be a directed graph with K vertices. The adversary chooses a sequence of loss vectors in [0, 1]K as usual. In each round, the learner chooses a vertex and observes the loss corresponding to that vertex and its neighbours. The full information and bandit settings are recovered by choosing the graph to be fully connected or have no edges respectively, but of course there are many interesting regimes in between. There are many variants on this basic problem. For example, G might change in each round or be undirected. Or perhaps the graph is changing, and the learner only observes it after choosing an action. The reader can explore this topic by reading the articles by Mannor and Shamir [2011], Alon et al. [2013], Koca´k et al. [2014] and Alon et al. [2015] or the short book by Valko [2016].

30 Combinatorial Bandits

A combinatorial bandit is a linear bandit with an action set that is a subset of the d-dimensional binary hypercube: A  {0, 1}d. Elements of A are thus d-dimensional, binary-valued vectors. Each component may be on or off, but some combinations are not allowed ­ hence the combinatorial structure. Combinatorial bandit problems arise in many applications, some of which are detailed shortly.
The setting is studied in both the adversarial and stochastic models. We focus on the former in this chapter and discuss the latter in the notes. In the adversarial setting, as usual, the environment chooses a sequence of loss vectors y1, . . . , yn with yt  Rd, and the regret of the learner is

n

Rn

=

max
aA

E

At - a, yt ,

t=1

where as usual At is the action chosen by the learner in round t.
Unsurprisingly, the algorithms and analysis from Chapters 27 and 28 are applicable in this setting. The main challenge is controlling the computation complexity of the resulting algorithms. As we will soon argue, except in special cases, it is natural to be hopeful when there exists an optimisation oracle that computes the map y  argminaA a, y is efficient. The most important result of this chapter gives a strategy based on follow-the-perturbed-leader that makes a single call to such an optimisation oracle in every round for a suitable chosen vector L~t  Rd (a perturbed estimate of the cumulative loss vector). This is done in the semi-bandit setting, an in-between setting where the learner receives semi-bandit feedback, which is the vector (At1yt1, . . . , Atdytd). Since Ati  {0, 1}, this is equivalent to observing yti for all i for which Ati = 1.
The rest of this chapter is organised as follows: the next section describes some additional useful notation. There follows a section that describes selected applications. In Section 30.3 we describe an application of Exp3 to the case when the learner receives only bandit feedback and explain the computational challenges that arise due to the combinatorial nature of the problem. Section 30.4 explains how online stochastic mirror descent can be applied to the semi-bandit setting, which still fails to give an efficient algorithm. Finally, the follow-theperturbed-leader algorithm is introduced and analysed in Section 30.5.

30.1 Notation and Assumptions

361

30.1

Notation and Assumptions
In the applications, a key quantity associated with combinatorial action sets is the largest number of elements m that can be simultaneously `on' in any given action:
A  a  {0, 1}d : a 1  m .
In Chapters 27 and 28, we assumed that yt  {y : supaA | a, y |  1}. This restriction is not consistent with the applications we have in mind, so instead we assume that yt  [0, 1]d, which by the definition of A ensures that | At, yt |  m for all t. In the standard bandit model, the learner observes At, yt in each round.

30.2

Applications
Shortest-Path Problems Let G = (V, E) be a fixed graph with a finite set of vertices V and edges E  V × V , with |E| = d. The online shortest-path problem is a game over n rounds between an adversary and a learner. Given fixed vertices u, v  V , the learner's objective in each round is to find the shortest path between u and v. At the beginning of the game, the adversary chooses a sequence of vectors y1, . . . , yn, with yt  [0, 1]d and yti representing the length of the ith edge in E in round t. In each round, the learner chooses a path between u and v. The regret of the learner is the difference between the distance they travelled and the distance of the optimal path in hindsight. A path is represented by a vector a  {0, 1}d where ai = 1 if the ith edge is part of the path. Let A be the set of paths connecting vertices u and v, then the length of path a in round t is a, yt . In this problem, m is the length of the longest path. Fig. 30.1 illustrates a typical example.

Ranking
Suppose a company has d ads and m locations in which to display them. In each round t, the learner should choose the m ads to display, which is represented by a vector At  {0, 1}d with At 1 = m. As before, the adversary chooses yt  [0, 1]d that measures the quality of each placement and the learner suffers loss At, yt . This problem could also be called `selection' because the order of the items play no role. Problems where the order plays a direct role are analysed in Chapter 32.

Multitask Bandits Consider playing m multi-armed bandits simultaneously, each with k arms. If the losses for each bandit problem are observed, then it is easy to apply Exp3 or Exp3-IX to each bandit independently. But now suppose the learner only observes the sum of the losses. This problem is represented as a combinatorial bandit by

30.3 Bandit Feedback

362

Beijing

12

13

7

Budapest 10

13

1 11 Abu Dhabi

Frankfurt 10
12 Singapore

8

Sydney

Figure 30.1 Shortest-path problem between Budapest and Sydney. The learner chooses the path Budapest­Frankfurt­Singapore­Sydney. In the bandit setting, they observe total travel time (21 hours), while in the semi-bandit they observe the length of each flight on the route they took (1 hour, 12 hours, 8 hours).

letting d = mk and
k
A = a  {0, 1}d : ai+kj = 1 for all 0  j < m .
i=1
In words, the d coordinates are partitioned into m parts and the learner needs to select exactly one coordinate ("primitive action") from each part. The resulting problem is called the multi-task bandit problem: This problem is like making m independent choices in parallel in m bandit problems blindly and then receiving an aggregated feedback for all the m choices made. This scenario can arise in practice when a company is making multiple independent interventions, but the quality of the interventions are only observed via a single change in revenue.

30.3

Bandit Feedback

The easiest approach is to apply the version of Exp3 for linear bandits described in Chapter 27. The only difference is that now | At, yt | can be as large as m, which increases the regret by a factor of m. We leave the proof of the following theorem to the reader (Exercise 30.1).
Theorem 30.1. Consider the setting of Section 30.1. If Algorithm 15 is run on action set A with appropriately chosen learning rate, then

Rn  2m

3dn log |A|  m3/2

12dn log

ed m

.

There are two issues with this approach, both computational. First, the action

30.4 Semi-bandit Feedback and Mirror Descent

363

set is typically so large that finding the core set of the central minimum volume enclosing ellipsoid that determines the Kiefer­Wolfowitz exploration distribution of Algorithm 15 is hopeless. Second, efficiently sampling from the resulting exponential weights distribution may not be possible. There is no silver bullet for these issues. The combinatorial bandit can model a repeated version of the travelling salesman problem, which is hard even to approximate. Since an online learning algorithm with O(np) regret with p < 1 can be used to approximate the optimal solution, it follows that no such algorithm can be computationally efficient. There are, however, special cases where efficient algorithms exist, and we give some pointers to the relevant literature on this at the end of the chapter. One modification that greatly eases computation is to replace the optimal Kiefer­ Wolfowitz exploration distribution with a distribution that can be computed and sampled from in an efficient manner, as noted after Theorem 27.1.

30.4

Semi-bandit Feedback and Mirror Descent

In the semi-bandit setting, the learner observes the loss associated with all nonzero coordinates of the chosen action. The additional information is exploited by noting that yt can now be estimated in each coordinate. Let

Y^ti

=

Atiyti A¯ti

,

(30.1)

where A¯ti = E[Ati | Ft-1] with Ft = (A1, . . . , At). An easy calculation shows that E[Y^t | Ft-1] = yt, so this estimate is still unbiased. Unsurprisingly we will again use online stochastic mirror descent, which is summarised for this setting
in Algorithm 18.

1: Input A, , F 2: A¯1 = argminaco(A) F (a) 3: for t = 1, . . . , n do 4: Choose distribution Pt on A such that aA Pt(a)a = A¯t 5: Sample At  Pt and observe At1yt1, . . . , Atdytd 6: Compute Y^ti = Atiyti/A¯ti for all i  [d] 7: Update A¯t+1 = argminaco(A)  a, Y^t + DF (a, A¯t) 8: end for
Algorithm 18: Online stochastic mirror descent for semi-bandits.

Theorem 30.2. Consider the setting of Section 30.1. Let F : Rd  R be the unnormalised negentropy potential:
d
F (a) = (ai log(ai) - ai)
i=1

30.4 Semi-bandit Feedback and Mirror Descent

364

for a  [0, )d and F (a) =  otherwise. Then, Algorithm 18 is well defined and, provided  = 2m(1 + log(d/m))/(nd), its regret Rn satisfies

Rn  2nmd(1 + log(d/m)) .
Proof Since A is a finite set, the algorithm is well defined. In particular, A¯t > 0 exists and is unique for all t  [n]. By Theorem 28.10,

Rn



diamF (co(A)) 

+

E

n
A¯t - A¯t+1, Y^t
t=1

-

1 

DF

(A¯t+1,

A¯t)

.

(30.2)

The diameter is easily bounded by noting that F is negative in co(A) and using Jensen's inequality:

d
diamF (co(A))  sup
aco(A) i=1

ai + ai log

1 ai

 m(1 + log(d/m)) .

For the second term in Eq. (30.2), let Y^ti = Y^tiI A¯t+1,i  A¯ti . Since Y^t is positive,

A¯t - A¯t+1, Y^t

-

1 

DF

(A¯t+1,

A¯t)



A¯t - A¯t+1, Y^t

-

1 

DF

(A¯t+1,

A¯t)



 2

Y^t

2 2F (Zt)-1



 2

d i=1

Ati A¯ti

,

where Zt is provided by Theorem 26.12 and lies on the chord [A¯t, A¯t+1]. The final inequality follows because 2F (z) = diag(1/z) and using the definition of Y^t , which ensures that the worst case occurs when Zt = A¯t. Summing and taking
the expectation:

E

n

A¯t - A¯t+1, Y^t

-

1 

DF

(A¯t+1

,

A¯t)

t=1

Putting together the pieces shows that



 2

E

n d Ati t=1 i=1 A¯ti

=

nd 2

.

Rn



m(1 + log(d/m)) 

+

nd 2

=

2nmd(1 + log (d/m)) .

Algorithm 18 plays mirror descent on the convex hull of the actions, which has dimension d - 1. In principle it would be possible to do the same thing on the set of distributions over actions, which has dimension |A| - 1. Repeating the analysis leads to a suboptimal regret of O(m dn log(d/m)). We encourage the reader to go through this calculation to see where things go wrong.

Like in Section 30.3, the main problem is computation. In each round the algorithm needs to find a distribution Pt over A such that aA Pt(a) = A¯t. Feasibility
follows from the definition of co(A), while Carath´eodory's theorem proves the

30.5 Follow-the-Perturbed-Leader

365

support of Pt never needs to be larger than d+1. Since A is finite, we can write the
problem of finding Pt in terms of linear constraints, but naively the computation complexity is polynomial in k = |A|, which is exponential in m. The algorithm also needs to compute A¯t+1 from A¯t and Y^t. This is a convex optimisation problem, but the computation complexity depends on the representation of A and may be
intractable. See Note 6 for a few more details on this.

30.5

Follow-the-Perturbed-Leader

In this section, we help ourselves to find a computationally efficient algorithm by adding the assumption that for all y  [0, )d, the optimisation problem of
finding

a = argminaA a, y

(30.3)

admits a computationally efficient algorithm. This assumption feels close to the

minimum one could get away with in the sense that if the offline problem in

Eq. (30.3) is hard to approximate, then any algorithm with low regret must also

be inefficient. A marginally more reasonable assumption is that Eq. (30.3) can be

approximated efficiently. For simplicity we assume exact solutions, however.

If the algorithm observed the losses in every round, adding a random vector to

the sum of previous losses and then finding the action that minimises the total

randomly perturbed loss leads to what is known as the follow-the-perturbed-

leader (FTPL) algorithm. As discussed before, the random perturbation is

necessary to achieve sublinear regret. In semi-bandit setting which is considered

here, the full loss vector is unobserved and hence needs to be estimated. Letting

L^t-1 =

t-1 s=1

Y^s

be

the

cumulative

loss

estimates

before

round

t,

FTPL

chooses

At = argminaA a, L^t-1 - Zt ,

(30.4)

where  > 0 is the learning rate and Zt  Rd is sampled from a carefully chosen distribution Q. The random perturbations is chosen to both guard against worstcase, and to induce necessary exploration. Notice that if  is small, then the effect of Zt is larger and the algorithm can be expected to explore more, which is consistent with the learning rate used in mirror descent or exponential weighting studied in previous chapters.
Before defining the loss estimations and perturbation distribution, we make a connection between FTPL and mirror descent. Given Legendre potential F with dom(F ) = int(co(A)), online stochastic mirror descent chooses A¯t so that
A¯t = argminaco(A) a, Y^t-1 + DF (a, A¯t-1) .

Taking derivatives and using the fact that dom(F ) = int(co(A)), we have

F (A¯t) = F (A¯t-1) - Y^t-1 = -L^t-1 .

30.5 Follow-the-Perturbed-Leader

366

By duality (Theorem 26.6), this implies that A¯t = F (-L^t-1). On the other hand, examining Eq. (30.4), we see that for FTPL,
A¯t = E[At | Ft-1] = E argminaA a, L^t-1 - Zt Ft-1 ,
where Ft = (Z1, . . . , Zt). Thus, in order to view FTPL as an instance of mirror descent, it suffices to find a Legendre potential F with dom(F ) = int(co(A)) and
F (-L^t-1) = E argminaA a, L^t-1 - Zt Ft-1
= E argmaxaA a, Zt - L^t-1 Ft-1 .
Since L^t-1 is more or less uncontrolled, the latter condition is most easily satisfied by requiring that for any x  Rd, F (x) = Rd argmaxaco(A) a, x + z dQ(z). To remove clutter in the notation, define

a(x) = argmaxaA a, x ,
where a(x) is chosen to be an arbitrary maximiser if multiple maximisers exist. Readers with some familiarity with convex analysis will remember that if a convex set A has a smooth boundary, then the support function of A,

(x) = max a, x ,
aA
satisfies (x) = a(x). For combinatorial bandits, A is not smooth, but if Q is absolutely continuous with respect to the Lebesgue measure, then you will show in Exercise 30.5 that

 (x + z) dQ(z) = a(x + z) dQ(z) for all x  Rd .

Rd

Rd

The key to this argument is that the derivative of  exists almost everywhere

and is equal to a(x). All this shows is that FTPL can be interpreted as mirror

descent with potential F defined in terms of its Fenchel dual,

F (x) = (x + z)dQ(z) .
Rd

(30.5)

Of course we have not shown that F is Legendre or that int(dom(F )) = int(co(A)), both of which you will do in Exercise 30.6 under appropriate conditions on Q.
There are more reasons for making this connection than mere curiosity. The classical analysis of FTPL involves at least one `leap of faith' in the analysis. In contrast, the analysis via the mirror descent interpretation is more mechanical. Recall that mirror descent depends on choosing a potential, an exploration distribution and an estimator. We now make the choice of these explicit. The exploration distribution is a distribution Pt on A such that

A¯t = Pt(a)a ,
aA

30.5 Follow-the-Perturbed-Leader

367

which in our case is implicitly defined by the distribution of Zt:
Pt(a) = P(a(Zt - L^t-1) = a | Ft-1) .
It remains to choose the loss estimator. A natural choice would be the same as Eq. (30.1), which is Y^ti = Atiyti/Pti with Pti = P (Ati = 1 | Ft-1) = A¯ti. The problem is that Pti does not generally have a closed-form solution. And while Pti can be estimated by sampling, the number of samples required for sufficient accuracy can be quite large. The next idea is to replace 1/Pti in the importanceweighted estimator with a random variable with conditional expectation equal to 1/Pti. This is based on the following well-known result:
Lemma 30.3. Let U  {1, 2, . . .} be geometrically distributed with parameter   [0, 1] so that P (U = j) = (1 - )j-1. Then E[U ] = 1/.
You can sample from a geometric distribution with parameter  by counting the number of flips of a biased coin with bias  until the first head. That is, if (Xt) t=1 is an independent sequence of Bernoulli random variables with bias , then U = min{t  1 : Xt = 1} is geometrically distributed with parameter .

Define a sequence of d-dimensional random vectors K1, . . . , Kn, where (Kti)di=1 is a sequence of geometric random variables that are conditionally independent given Ft so that the conditional law of Kti given Ft is Geometric(Pti) and where we now redefine Ft = (Z1, K1, . . . , Zt-1, Kt-1, Zt). The estimator of yti can now be defined by
Y^ti = min(, Kti)Atiyti ,
where  is a positive integer to be chosen subsequently. Note that
E [KtiAtiyti | Ft-1] = yti .
The truncation parameter  is needed to ensure that Y^ti is never too large. We have now provided all the pieces to define a version of FTPL that is a special case of mirror descent. The algorithm is summarised in Algorithm 19.

Theorem 30.4. Consider the setting of Section 30.1. Let Q have density with respect to the Lebesgue measure of q(z) = 2-d exp(- z 1), and choose the
parameters ,  as follows:

=

2(1 + log(d)) (1 + e2)dnm

,

=

1 m

.

Then the algorithm Algorithm 19 is well defined and provided that m  1 its regret is bounded by Rn  m 2(1 + e2)nd(1 + log(d)).

30.5 Follow-the-Perturbed-Leader

368

1: Input A, n, , , Q 2: L^0 = 0  Rd

3: for t = 1, . . . , n do

4: Sample Zt  Q 5: Compute At = argmaxaA a, Zt - L^t-1 6: Observe At1yt1, . . . , Atdytd

7: For each i  [d] sample Kti  Geometric(Pti)

8: For each i  [d] compute Y^ti = min(, Kti)Atiyti

9:

L^t = L^t-1 + Y^t

10: end for

Algorithm 19: Follow-the-perturbed-leader for semi-bandits.

Proof First, note that At is almost surely uniquely defined and so is A¯t = E [At | Ft-1]. Therefore, by isolating the bias in the loss estimators, and thanks
to Exercise 30.6, we can apply Theorem 28.4 to get that

n

n

Rn(a) = E

At - a, yt = E

A¯t - a, yt

t=1

t=1

n

n

=E

A¯t - a, Y^t + E

A¯t - a, yt - Y^t

t=1

t=1



diamF (A) 

+

E

1 

n t=1

DF (A¯t, A¯t+1)

+E

n
A¯t - a, yt - Y^t
t=1

.

(30.6)

Of the three terms, the diameter is most easily bounded. For Z  Q,

F (a) = sup ( a, x - F (x)) = sup ( a, x - E[max b, x + Z ])

xRd

xRd

bA

(30.7)

 -E[max
bA

b, Z

]  -mE[

Z

] = -m

d

1 d



-m(1

+

log(d)) ,

i=1

where the first inequality follows by choosing x = 0 and the second follows from H¨older's inequality and that a 1  m for any a  A. The last equality is non-trivial and is explained in Exercise 30.4. By the convexity of the maximum function and the fact that Z is centered, we also have from Eq. (30.7) that F (a)  0, which means that

diamF

(A)

=

max
a,bA

F

(a)

-

F

(b)



m(1

+

log(d))

.

(30.8)

The next step is to bound the Bregman divergence induced by F . We will shortly show that the Hessian 2F (x) of F  exists, so by Part (b) of Theorem 26.6

30.5 Follow-the-Perturbed-Leader

369

and Taylor's theorem, there exists an   [0, 1] and  = -L^t-1 - Y^t such that

DF (A¯t, A¯t+1) = DF  (F (A¯t+1), F (A¯t))

=

DF  (-L^t-1

-

Y^t, -L^t-1)

=

2 2

Y^t

2 2 F

 ()

,

(30.9)

where the last equality follows from Taylor's theorem (see Theorem 26.12). To calculate the Hessian, we use a change of variable to avoid applying the gradient to the non-differentiable argmax:

2F (x) = (F (x)) = E [a(x + Z)] =  a(x + z)q(z)dz
Rd

=  a(u)q(u - x)du = a(u)(q(u - x)) du

Rd

Rd

= a(u) sign(u - x) q(u - x)du = a(x + z) sign(z) q(z)dz .

Rd

Rd

Using the definition of  and the fact that a(x) is non-negative,

2F ()ij = a( + z)i sign(z)jq(z)dz
Rd

 a( + z)iq(z)dz
Rd

= a(z - L^t-1 - Y^t)iq(z)dz
Rd

= a(u - L^t-1)iq(u + Y^t)du
Rd

 exp Y^t 1  e2Pti ,

a(u - L^t-1)iq(u)du
Rd

(30.10) (30.11)

where the last inequality follows since   [0, 1] and Y^ti   = 1/(m) , m  1 and Y^t has at most m non-zero entries. Continuing on from Eq. (30.9), we have

2 2

Y^t

2 2F ()



e22 2

d

d

PtiY^ti Y^tj

i=1

j=1



e22 2

dd
PtiKtiAtiKtj Atj .
i=1 j=1

Chaining together the parts and taking the expectation shows that





E[DF (A¯t, A¯t+1)] 

e2 2

E



d

d
PtiKtiAtiKtj Atj 

i=1 j=1





=

e22 2

E



d i=1

d j=1

AtiAtj  Ptj



e2md2 2

.

The last step is to control the bias term. For this, first note that since

30.6 Notes

370

Atiyti  {0, 1},

E[Y^ti | Ft] = E[min(, Kti)Atiyti | Ft] = AtiytiE[min(, Kti) | Ft]

=

yti

Ati Pti

(1

-

(1

-

Pti) )

,

where the last equality follows from the definition of Kti using a direct calculation. Thus, E[Y^ti | Ft-1] = (1 - (1 - Pti))yti and

n

n

E

A¯t - a, yt - Y^t  E

A¯t, yt - Y^t

t=1

t=1

=E

nd
ytiPti(1 - Pti)
t=1 i=1



dn 2

=

dnm 2

,

where the last inequality follows from using that for x  [0, 1], s > 0, x(1 - x)s  xe-sx  1/s. Putting together all the pieces into Eq. (30.6) leads to

Rn



m(1

+ log(d)) 

+

e2dnm 2

+

dnm 2



m

2(1 + e2)nd(1 + log(d)) .

30.6

Notes
1 For a long time, it was speculated that the dependence of the regret on m3/2 in Theorem 30.1 (bandit feedback) might be improvable to m. Very recently, however, the lower bound was increased to show the upper bound is tight [Cohen et al., 2017]. For semi-bandits the worst-case lower bound is ( dnm) (Exercise 30.8), which holds for large enough n and m  d/2 and is matched up to constant factors by online stochastic mirror descent with a different potential (Exercise 30.7).
2 The implementation of FTPL shown in Algorithm 19 needs to sample Kti for each i with Ati = 1. The conditional expected running time for this is Ati/Pti, which has expectation 1. It follows that the expected running time over the whole n rounds is O(nd) calls to the oracle linear optimisation algorithm. It can happen that the algorithm is unlucky and chooses Ati = 1 for some i with Pti quite small and then sampling Kti could be time-consuming. Note, however, that only min(Kti, ) is actually used by the algorithm, and hence the sampling procedure can be truncated at . This minor modification ensures the algorithm needs at most O(nd) calls to the oracle in the worst case.
3 While FTPL is excellent in the face of semi-bandit information, we do not know of a general result for the bandit model. The main challenge is controlling the variance of the least squares estimator without explicitly inducing exploration using a sophisticated exploration distribution like what is provided by Kiefer­ Wolfowitz.

30.6 Notes

371

4 Combinatorial bandits can also be studied in a stochastic setting. There are several ways to do this. The first mirrors our assumptions for stochastic linear bandits in Chapter 19, where the loss (more commonly reward) is defined by

Xt = At,  + t ,

(30.12)

where   Rd is fixed and unknown and t is the noise on which statistical assumptions are made (for example, conditionally 1-subgaussian). There are
at least two alternatives. Suppose that 1, . . . , n are sampled independently from some multivariate distribution, and define the reward by

Xt = At, t .

(30.13)

This latter version has `parameter noise' (cf. Chapter 29) and is more closely
related to the adversarial set-up studied in this chapter. Finally, one can assume additionally that the distribution of t is a product distribution so that (1i)di=1 are also independent.

5

For some action sets, the off-diagonal elements of are negative, which improves the dependence on m

ttoheHme.ssAianneixnamEqp.le(3w0h.1er0e)

this occurs is when A = {a  {0, 1}d : a 1 = m}. Let i = j, and suppose that z,   Rd and zj  0. Then you can check that a(z + )i  a(z - 2zjej + )i,

and so

2F ()ij = a(z + )i sign(z)jq(z)dz
Rd 

=

(a(z + )i - a(z - 2zjej + )i)q(z)dzjdz-j

Rd-1 0

 0,

where dz-j is shorthand for dz1dz2, . . . dzj-1dzj+1, . . . , dzd. You are asked to complete all the details in Exercise 30.9. This result unfortunately does not hold for every action set (Exercise 30.10).
6 In order to implement mirror descent or follow-the-regularised-leader with bandit or semi-bandit information, one needs to solve two optimisation problems: (a) a convex optimisation problem of the form argminaco(A) F (a) for some convex F and (b) a linear optimisation problem to find a distribution P over A with mean a¯ where a¯  co(A). More or less sufficient is an efficient membership oracle for co(A) and evaluation oracle for F [Gro¨tschel et al., 2012, Lee et al., 2018]. Also necessary for bandits is to identify an exploration distribution, which we discuss in the notes and bibliographic remarks of Chapter 27. This is not required for semi-bandits, however, at least with the negentropy potential used in by Algorithm 18.

30.7 Bibliographic Remarks

372

30.7

Bibliographic Remarks
The online combinatorial bandit was introduced by Cesa-Bianchi and Lugosi [2012], where you will also find the most comprehensive list of known applications for which efficient algorithms exist. The regret bound for Exp3 given in Theorem 30.1 for the bandit case is due to Bubeck and Cesa-Bianchi [2012] (with a slightly different argument). While computational issues remain in the bandit problem, there has been some progress in certain settings. Combes et al. [2015b] propose playing mirror descent on the convex hull of the action set without fancy exploration, which leads to near-optimal bounds for well-behaved action sets. One could also use continuous exponential weights from Chapter 27. These methods lead to computationally efficient algorithms for some action sets, but this must be checked on a case-by-case basis. The full information setting has been studied quite extensively [Koolen et al., 2010, and references from/to]. FTPL was first proposed (in the full information context) by Hannan [1957], rediscovered by Kalai and Vempala [2002, 2005] and generalised by Hutter and Poland [2005]. Poland [2005] and Kujala and Elomaa [2005] independently applied FTPL to finitearmed adversarial bandits and showed near-optimal regret for this case. Poland [2005] also proposed to use Monte Carlo simulation to estimate the probability of choosing each arm needed in the construction of reward estimates. Kujala and Elomaa [2007] extended the result to non-oblivious adversaries. For combinatorial settings, suboptimal rates have been shown by Awerbuch and Kleinberg [2004], McMahan and Blum [2004] and Dani and Hayes [2006]. Semi-bandits seem to have been introduced in the context of shortest-path problems by Gyo¨rgy et al. [2007]. The general set-up and algorithmic analysis of FTPL presented follows the work by Neu [2015a], who also introduced the idea to estimate the inverse probabilities via a geometric random variable. Our analysis based on mirror descent is novel. The analysis follows ideas of Abernethy et al. [2014], who present the core ideas in the prediction with expert advice setting, Cohen and Hazan [2015], who consider the combinatorial full information case, and Abernethy et al. [2015], who study finite-armed bandits. The literature on stochastic combinatorial semibandits is also quite large with algorithms and analysis in the frequentist [Gai et al., 2012, Combes et al., 2015b, Kveton et al., 2015b] and Bayesian settings [Wen et al., 2015, Russo and Van Roy, 2016]. These works focus on the case where the reward is given by Eq. (30.13) and the components of t are independent. When the reward is given by Eq. (30.12), one can use the tools for stochastic linear bandits developed in Part V. Some work also pushes beyond the assumption that the rewards are linear [Chen et al., 2013, Lin et al., 2015, Chen et al., 2016a,b, Wang and Chen, 2018]. The focus in these works is on understanding what are the minimal structural assumptions on the reward function and action spaces for which learning in combinatorially large action spaces is still feasible statistically/computationally. Last of all, we mentioned that travelling salesman is computationally hard to approximate, which you can read about in the paper by Papadimitriou and Vempala [2006], and references there-in.

30.8 Exercises

373

30.8

Exercises

30.1 (Mirror descent for combinatorial bandits) Prove Theorem 30.1.

Hint For the second inequality, you may find it useful to know that for

0  m  n, defining m(n) =

m i=0

n i

,

it

holds

that

(m/n)mm(n)



em.

30.2 (Efficient computation on m-sets) Provide an efficient implementation of Algorithm 18 for the m-set: A = {a  {0, 1}d : a 1 = m}.

30.3 (Efficient computation on shortest-path problems) Playing mirror descent on co(A) leads to a good bound for bandit or semi-bandit problems, but sometimes playing Exp3 over A is more efficient, even when A is exponentially large. Design and analyse a variant of Exp3 for the online shortest-path problem with semi-bandit feedback described in Section 30.2. Your challenge is to ensure the following:
 (a) a regret of Rn = O( n), with dependence on d and m omitted; and (b) polynomial computation complexity in n and d.

Hint This is not the easiest exercise. Start by reading the paper by Takimoto and Warmuth [2003], then follow up with that of Gy¨orgy et al. [2007].

30.4 (Expected supremum norm of Laplace) Let Z be sampled from measure on Rd with density f (z) = 2-d exp(- z 1). The purpose of this exercise is to show that

E[ Z ] =

d

1 i

.

i=1

(30.14)

(a) Let X1, . . . , Xd be independent standard exponentials. Show that Z  and max{X1, . . . , Xd} have the same law.
(b) Let Mj = maxij Xi. Prove for j  2 that

E[Mj] = E[Mj-1] + E[exp(-Mj-1)] .

(c) Prove by induction or otherwise that for all a, j  {1, 2, . . .},

E[exp(-aMj)] = (d) Prove the claim in Eq. (30.14).

a! ba=1(j

+

b)

.

30.5 (Gradient of expected support function) Let A  Rd be a compact set and (x) = maxaA a, x its support function. Let Q be a measure on Rd that is absolutely continuous with respect to the Lebesgue measure, and let Z  Q. Show that
E[(x + Z)] = E [argmaxaA a, x + Z ] .
Hint Recall that the support function  of a non-empty compact set is a proper

30.8 Exercises

374

convex function. Then, note that for any proper convex function f : Rd  R{}, the set Rd \ dom(f ) has Lebesgue measure zero [Rockafellar, 2015, Theorem 25.5]. Next, by Danskin's theorem, the directional derivative of  in the direction v  Rd is given by v(x) = maxaA(x) a, v , where A(x) is the set of maximisers of a  a, x over A [Bertsekas, 2015, Proposition 5.4.8 in Appendix B]. Finally,
it is worth remembering the following result: let f be an extended real-valued function with x  Rd in the interior of its domain. Then, for some g  Rd, vf (x) = g, v holds true for all v  Rd if and only if f (x) exists and is equal to g.
30.6 A function f : Rd  R¯ is closed if its epigraph is a closed set. Let F  be the function defined in Section 30.5 and F be the proper convex closed function and whose Fenchel dual is F .

(a) Show that the function F is well defined (F  is the Fenchel dual of a proper convex closed function, and there is only a single such function).
(b) For the remainder of the exercise, let Q be absolutely continuous with respect to the Lebesgue measure with an everywhere positive density, and let A be the convex hull of finitely many points in Rd whose span is Rd. Show that the function F is Legendre.
(c) Show that int(dom(F )) = int(co(A)).

Hint For Part (a), it may be worth recalling that the bidual (the dual of the dual) of a proper convex closed function f is itself: f = f (= (f )). Furthermore, the Fenchel dual of a proper function is always a proper convex closed function.
30.7 (Minimax bound for combinatorial semi-bandits) Adapt the analysis in Exercise 28.15 to derive an algorithm for combinatorial bandits with semibandit feedback for which the regret is Rn  C mdn for universal constant C > 0.

30.8 (Lower bound for combinatorial semi-bandits) Let m  1 and d = km for some k > 1. Prove that for any algorithm there exists a combinatorial semi-bandit such that Rn  c min{nm, mdn} where c > 0 is a universal constant.

Hint The most obvious choice is A = {a  {0, 1}d : a 1 = m}, which are sometimes called m-sets. A lower bound does hold for this action set [Lattimore et al., 2018]. However, an easier path is to impose a little additional structure such as multi-task bandits.

3pr0o.v9e(tFhoaltlFoTwP-Lthhea-spRernt=urO~b(ed-mlenad)derergrfeotrwmhe-nseAts=)

Use the ideas in Note {a  {0, 1}d : a 1 =

5 to m}.

Hint After proving the off-diagonal elements of the Hessian are negative, you will also need to tune the learning rate. We do not know of a source for this result, but the full information case was studied by Cohen and Hazan [2015].

30.8 Exercises

375

30.10 Construct an action set and i = j and z  Rd with zj > 0 such that a(z)i  a(z - 2zjej)i.

Hint Consider the shortest-path problem defined by the graph below.

start

i

j goal

Choose losses for the edges z, and think about what happens when the loss associated with edge j decreases.

31 Non-stationary Bandits

The competitor class used in the standard definition of the regret is not appropriate when the underlying environment is changing. In this chapter we increase the power of the competitor class to `track' changing environments and derive algorithms for which the regret relative to this enlarged class is not too large. While the results are specified to bandits with finitely many arms (both stochastic and adversarial), many of the ideas generalise to other models such as linear bandits. This chapter also illustrates the flexibility of the tools presented in the earlier chapters, which are applied here almost without modification. We hope (and expect) that this will also be true for other models you might study.

Figure 31.1 This bandit is definitely not stationary!

31.1

Adversarial Bandits

In contrast to stochastic bandits, the adversarial bandit model presented in
Chapter 11 does not prevent the environment from changing over time. The
problem is that bounds on the regret can become vacuous when the losses appear
non-stationary. To illustrate an extreme situation, suppose you face a two-armed adversarial bandit with losses yt1 = I {t  n/2} and yt2 = I {t > n/2}. If we run Exp3 on this problem, then Theorem 11.2 guarantees that

Rn = E

n
ytAt
t=1

n

- min

yti 

i{1,2} t=1

2nk log(k) .

Since mini{1,2}

n t=1

yti

=

n/2,

by

rearranging

we

see

that

E

n
ytAt
t=1



n 2

+

2nk log(k) .

To put this in perspective, a policy that plays each arm with probability half in

every round would have E[

n t=1

ytAt ]

=

n/2.

In

other

words,

the

regret

guarantee

is practically meaningless.

What should we expect for this problem? The sequence of losses is so regular

31.1 Adversarial Bandits

377

that we might hope that a clever policy will mostly play the second arm in the first n/2 rounds and then switch to playing mostly the first arm in the second n/2 rounds. Then the cumulative loss would be close to zero and the regret would be negative. Rather than aiming to guarantee negative regret, we redefine the regret by enlarging the competitor class as a way to ensure meaningful results. Let nm  [k]n be the set of action sequences of length n with at most m - 1 changes:

n-1
nm = (at)  [k]n : I {at = at+1}  m - 1 .
t=1
Then define the non-stationary regret with m - 1 change points by

n

n

Rnm = E

ytAt

t=1

- min E
anm

ytat
t=1

.

The non-stationary regret is sometimes called the tracking regret because a learner that makes it small must `track' the best arm as it changes. Notice that Rn1 coincides with the usual definition of the regret. Furthermore, on the sequence described at the beginning of the section, we see that

n

Rn2 = E

ytAt ,

t=1

which means a policy can only enjoy sublinear non-stationary regret if it detects the change point quickly. The obvious question is whether or not such a policy exists and how its regret depends on m.

Exp4 for Non-stationary Bandits One idea is to use the Exp4 policy from Chapter 18 with a large set of experts, one for each a  nm. Theorem 18.1 shows that Exp4 with these experts suffers regret of at most

Rnm  2nk log |nm| .

(31.1)

Naively bounding log |nm| (Exercise 31.1) and ignoring constant factors shows that

Rnm = O

nmk log

kn m

.

(31.2)

To see that you cannot do much better than this, imagine interacting with m adversarial bandit environments sequentially, each with horizon n/m. No matter what policy you propose, there exist choices of bandits such that the expected regret suffered against each bandit is at least ( nk/m). After summing over the m instances, we see that the worst-case regret is at least
 Rnm =  nmk ,

31.1 Adversarial Bandits

378

which matches the upper bound except for logarithmic factors. Notice how this lower bound applies to policies that know the location of the changes, so it is not true that things are significantly harder in the absence of this knowledge. There is one big caveat with all these calculations. The running time of a naive implementation of Exp4 is linear in the number of experts, which even for modestly sized m is very large indeed.

Online Stochastic Mirror Descent
The computational issues faced by Exp4 are most easily overcome using the tools from online convex optimisation developed in Chapter 28. The idea is to use online stochastic mirror descent and the unnormalised negentropy potential. Without further modification, this would be Exp3, which you will show does not work for non-stationary bandits (Exercise 31.3). The trick is to restrict the action set to the clipped simplex A = Pk-1  [, 1]k where   [0, 1/k] is a constant to be tuned subsequently. The clipping ensures the algorithm does not commit too hard to any single arm. The rationale is that a strong commitment could prevent the discovery of change points.
Let F : [0, )k  R be the unnormalised negentropy potential and P1  A be the uniform probability vector. In each round t, the learner samples At  Pt and updates its sampling distribution using

Pt+1 = argminpA  p, Y^t + DF (p, Pt) ,

(31.3)

where  > 0 is the learning rate and Y^ti = I {At = i} yti/Pti is the importanceweighted estimator of the loss of action i for round t. The solution to the optimisation problem of Eq. (31.3) can be computed efficiently using the two-step process:

P~t+1 = argminp[0,)k  p, Y^t + DF (p, Pt) , Pt+1 = argminpA DF (p, P~t+1) .
The first of these sub-problems can be evaluated analytically, yielding P~t+1,i = Pti exp(-Y^ti). The second can be solved efficiently using the result in Exercise 26.12. The algorithm enjoys the following guarantee on its regret:

Theorem 31.1. The expected regret of the policy sampling At  Pt with Pt defined in Eq. (31.3) is bounded by

Rnm



n(k

-

1)

+

m

log(1/) 

+

nk 2

.

Proof Let a  argminanm

n t=1

ytat

be

an

optimal

sequence

of

actions

in

hindsight constrained to nm. Then let 1 = t1 < t2 < · · · < tm < tm+1 = n + 1

so that at is constant on each interval {ti, . . . , ti+1 - 1}. We abuse notation by

31.2 Stochastic Bandits

379

writing ai = ati . Then the regret decomposes into

Rnm = E

n
(ytAt - ytat )
t=1

=E

m ti+1-1
(ytAt - ytat )
i=1 t=ti

m

ti+1 -1

= EE

(ytAt - ytai ) Pti .

i=1

t=ti

The next step is to apply Eq. (28.11) and the solution to Exercise 28.10 to bound the inner expectation, giving

ti+1 -1

ti+1 -1

E

(ytAt - ytai ) Pti = E

Pt - eai , yt Pti

t=ti

t=ti

ti+1 -1

 (ti+1 - ti)(k - 1) + E

max
pA

Pt - p, yt Pti

t=ti

ti+1 -1

= (ti+1 - ti)(k - 1) + E

max
pA

Pt - p, Y^t Pti

t=ti

 (ti+1 - ti)(k - 1) + E

max
pA

D(p, Pti ) 

+

k(ti+1 2

-

ti)

Pti

.

By assumption, Pti  A and so Ptij   for all j and D(p, Pti )  log(1/). Combining this observation with the previous two displays shows that

Rnm



n(k

-

1)

+

m

log(1/) 

+

nk 2

.

The learning rate and clipping parameters are approximately optimised by

 = 2m log(1/)/(nk) and  = m/(nk) , 
which leads to a regret of Rnm  mnk log(nk/m) + mnk. In typical
applications, the value of m is not known. In this case one can choose = log(1/)/nk and  = 1/nk, and the regret increases by a factor of O( m).

31.2

Stochastic Bandits

To keep things simple, we will assume the rewards are Gaussian and that for each arm i there is a function µi : [n]  R, and the reward is

Xt = µAt (t) + t , where (t)nt=1 is a sequence of independent standard Gaussian random variables. The optimal arm in round t has mean µ(t) = maxi[k] µi(t) and the regret is

n

n

Rn(µ) = µ(t) - E

µAt (t) .

t=1

t=1

31.2 Stochastic Bandits

380

The amount of non-stationarity is modelled by placing restrictions on the functions µi : [n]  R. To be consistent with the previous section, we assume the mean vector changes at most m - 1 times, which amounts to saying that

n-1
max I {µi(t) = µi(t + 1)}  m - 1 .
t=1 i[k]
If the locations of the change points were known then, thanks to the concavity of log, running a new copy of UCB on each interval would lead to a bound of

Rn(µ) = O

m

+

mk min

log

n m

,

(31.4)

where min is the smallest suboptimality gap over all m blocks and n  m. This is a non-vacuous bound for n large. Inspired by the results of the last section that showed that the bound achieved by an omniscient policy that knows when the changes occur can be achieved by a policy that does not, one then wonders whether the same holds concerning the bound in Eq. (31.4). As it turns out, the answer in this case is no.

Theorem 31.2. Let k = 2, and fix   (0, 1) and a policy . Let µ be so that µi(t) = µi is constant for both arms and  = µ1 - µ2 > 0. If the expected regret Rn(µ) of policy  on bandit µ satisfies Rn(µ) = o(n), then for all sufficiently large n, there exists a non-stationary bandit µ with at most two change points and mint[n] |µ1(t) - µ2(t)|   such that Rn(µ )  n/(22Rn(µ)).
The theorem implies that if a policy enjoys Rn(µ) = o(n1/2) for any non-trivial (stationary) bandit, then its minimax regret is at least (n1/2) on some nonstationary bandit. In particular, if Rn(µ) = O(log(n)), then its worst-case regret against non-stationary bandits with at most two changes is at least (n/ log(n)). This dashes our hopes for a policy that outperforms Exp4 in a stochastic setting with switches, even in an asymptotic sense. The reason for the negative result is that any algorithm anticipating the possibility of an abrupt change must frequently explore all suboptimal arms to check that no change has occurred.
There are algorithms designed for non-stationary bandits in the stochastic setting with abrupt change points as described above. Those that come with theoretical guarantees are based on forgetting or discounting data so that decisions of the algorithm depend almost entirely on recent data. In the notes, we discuss these approaches along with alternative models for non-stationarity. For now, the advantage of the stochastic setting seems to be that in the stochastic setting there are algorithms that do not need to know the number of changes, while, as noted beforehand, such algorithms are not yet known (or maybe not possible) in the nonstochastic setting.

Proof of Theorem 31.2 Let (Sj)Lj=1 be a uniform partition of [n] into successive intervals. Let P and E[·] denote the probabilities and expectations with respect to the bandit determined by µ and P with respect to alternative non-stationary

31.3 Notes

381

bandit µ to be defined shortly. By the pigeonhole principle, there exists a j  [L]

such that





E

I {At

=

2}



E[T2(n)] L

.

tSj

(31.5)

Define an alternative non-stationary bandit with µ (t) = µ except for t  Sj

when we let µ2(t) = µ2 + , where  = 2L/E[T2(n)] while µ1(t) = µ1. Then,

by Theorem 14.2 and Lemma 15.1,







P  I {At
tSj

=

2}



|Sj 2

|



+

P

 I {At
tSj

=

2}

<

|Sj|  2



1 2

exp (- D(P, P

))



1 2

exp

-

E[T2(n)]2 2L

=

1 2e

.

By Markov's inequality and Eq. (31.5),









P
tSj

I {At

=

2}



|Sj|  2



2 |Sj

|

E


tSj

I {At

=

2}



2E[T2(n)] L|Sj |



1 2|Sj |

,

where the last inequality follows by choosing L = 22E[T2(n)] and assuming n is large enough that L  n. Then   2 so that µ satisfies the assumptions of
the theorem. Therefore,

Rn(µ ) 

1 2e

-

1 2|Sj |

|Sj | 4



1 2e

-

1 2|Sj |

|Sj | 2



n L

1 4e

-

1 2

.

Then, using Rn(µ) = E [T2(n)], the definition of L and the assumption that Rn(µ) = o(n), it follows that for sufficiently large n,

Rn(µ

)



n 22Rn(µ)

.

where the constant is chosen so that 1/22 < 1/(8e).

31.3

Notes
1 Environments that appear non-stationary can often be made stationary by adding context. For example, when bandit algorithms are used for on-line advertising, gym membership advertisements are received more positively in January than July. A bandit algorithm that is oblivious to the time of year will perceive this environment as non-stationary. You could tackle this problem by using one of the algorithms in this chapter. Or you could use a contextual bandit algorithm and include the time of year in the context. The reader is encouraged to consider whether or not adding contextual information might be preferable to using an algorithm designed for non-stationary bandits.

31.3 Notes

382

2 The negative results for stochastic non-stationary bandits do not mean that trying to improve on the adversarial bandit algorithms is completely hopeless. First of all, the adversarial bandit algorithms are not well suited for exploiting distributional assumptions on the noise, which makes things irritating when the losses/rewards are Gaussian (which are unbounded) or Bernoulli (which have small variance near the boundaries). There have been several algorithms designed specifically for stochastic non-stationary bandits. When the reward distributions are permitted to change abruptly, as in the last section, then the two main algorithms are based on the idea of `forgetting' rewards observed in the distant past. One way to do this is with discounting. Let   (0, 1) be the discount factor , and define

t
µ^i (t) = t-sI {As = i} Xs
s=1

t
Ti (t) = t-sI {As = i} .
s=1

Then, for appropriately tuned constant , the discounted UCB policy chooses

each arm once and subsequently

 At = argmaxi[k] µ^i (t - 1) +

Ti

 (t -

1)

log


k
Ti(t - 1)  .
i=1

The idea is to `discount' rewards that occurred far in the past, which makes the algorithm most influenced by recent events. A similar algorithm called sliding-window UCB uses a similar approach, but rather than discounting past rewards with a geometric discount function, it simply discards them altogether. Let   N+ be a constant, and define

t

µ^i (t) =

I {As = i} Xs

s=t- +1

Then sliding-window UCB chooses

t

Ti (t) =

I {As = i} .

s=t- +1

At = argmaxi[k] µ^i (t - 1) +

Ti

 (t -

1)

log(t





)

.

Regrettably, however, these algorithms suffer from a tuning problem. There is no choice of  and  for which the algorithms enjoy Rn = O( n log(n)) in a minimax sense. On the positive side, there is empirical evidence to support the use of these algorithms when the stochastic assumption holds. Recently, more complicated algorithms were proposed that can adapt to the number of switches in a stochastic environment and match the regret of an optimally tuned adversarial algorithm [Auer et al., 2019, Chen et al., 2019]. 3 An alternative way to model non-stationarity in stochastic bandits is to assume the mean pay-offs of the arms are slowly drifting. One way to do this is to assume that µi(t) follows a reflected Brownian motion in some interval. It is not hard to see that the regret is necessary linear in this case because the best arm changes in any round with constant probability. The objective in this case

31.4 Bibliographic Remarks

383

is to understand the magnitude of the linear regret in terms of the size of the interval or volatility of the Brownian motion. 4 Yet another idea is to allow the means to change in an arbitrary way, but restrict the amount of total variation. Let µt = (µ1(t), . . . , µk(t)) and

n-1

Vn =

µt - µt+1 

t=1

be the cumulative change in mean rewards measured in terms of the supremum norm. Then, for each V  [1/k, n/k], there exists a policy such that for all bandits with Vn  V , it holds that

Rn  C(V k log(k))1/3n2/3 .

(31.6)

This bound is nearly tight in a minimax sense. The lower bound is obtained by

partitioning [n] into m parts, where in each part all arms have equal means

except for constant c

the optimal arm, which is better by  R. The usual argument shows that

=c the total

mk/n regret

for universal is ( kmn),

while Vn  2cm3/2 k/n. Tuning m so that Vn  V completes the proof.

Recent work shows that it is possible to achieve Eq. (31.6) without knowing

V . That is, there exists an algorithm that is able to adapt to V . In fact,

the algorithm mentioned in Note 2, which is able to adapt to the number of

switches, can accomplish this.

31.4

Bibliographic Remarks
Non-stationary bandits have quite a long history. The celebrated Gittins index is based on a model where each arm is associated with a Markov chain that evolves when played, the reward depends on the state, and the state of the chosen Markov chain is observed after it evolves [Gittins, 1979, Gittins et al., 2011]. The classical approaches, as discussed in Chapter 35, address this problem in the Bayesian framework, and the objective is primarily to design efficient algorithms rather than understanding the frequentist regret. Even more related is the restless bandit, which is the same as Gittins's set-up except the Markov chain for every arm evolves in every round, while the learner still only observes the state and reward for the action they chose. As a result, the learner needs to reason about the evolution of all the Markov chains, which makes this problem rather challenging. Restless bandits were introduced by Whittle [1988] in the Bayesian framework, where most of the results are not especially positive. There has been some interest in a frequentist analysis, but the challenging nature of the problem makes it difficult to design efficient algorithms with meaningful regret guarantees [Ortner et al., 2012]. Certainly there is potential for more work in this area.
The ideas in Section 31.1 are mostly generalisations of algorithms designed for the full information setting, notably the fixed share algorithm [Herbster and Warmuth, 1998]. The first algorithm designed for the adversarial non-stationary

31.5 Exercises

384

bandit is Exp3.S by Auer et al. [2002b]. This algorithm can be interpreted as an efficient version of Exp4, where experts correspond to sequences of actions that have the permitted number of changes and where the initialisation is carefully chosen so that the computation needed to run Exp4 is made tractable [Gy¨orgy et al., 2019]. See also the analysis of fixed share in the book by Cesa-Bianchi and Lugosi [2006]. The Exp3.P policy was originally developed in order to prove high-probability bounds for finite-armed adversarial bandits [Auer et al., 2002b], but Audibert and Bubeck [2010b] proved that with appropriate tuning it also enjoys the same bounds as Exp3.S. Presumably this also holds for Exp3-IX. Mirror descent has been used to prove tracking bounds in the full information setting by Herbster and Warmuth [2001]. A more recent reference is by Gy¨orgy and Szepesv´ari [2016], which makes the justification for clipping explicit. The latter paper considers the linear prediction setting and provides bounds on the regret that scale with the complexity of the sequence of losses as measured by the cumulative change of consecutive loss vectors. The advantage of this is that the complexity measure can distinguish between abrupt and gradual changes. This is similar to the approach of Besbes et al. [2014]. The lower bound for stochastic non-stationary bandits is by Garivier and Moulines [2011], though our proof differs in minor ways. We mentioned that there is a line of work on stochastic non-stationary bandits where the rewards are slowly drifting. The approach based on Brownian motion is due to Slivkins and Upfal [2008], while the variant described in Note 4 is by Besbes et al. [2014], who also gave the lower bound described there. The idea of discounted UCB was introduced without analysis by Kocsis and Szepesv´ari [2006]. The analysis of this algorithm and also of sliding-window UCB algorithm is by Garivier and Moulines [2011]. The sliding-window algorithm has been extended to linear bandits [Cheung et al., 2019] and learning in Markov decision processes [Gajane et al., 2018]. Contextual bandits have also been studied in the non-stationary setting [Luo et al., 2018, Chen et al., 2019]. We are not aware of an algorithm for the adversarial setting with Rn = O( mkn log(n)) when the number of switches is unknown. Auer et al. [2018] prove a bound of Rn = O( mkn log(n)) in the stochastic setting when k = 2. The idea underlying this work has been extended to the k-armed case [Auer et al., 2019], as well as to the contextual case [Chen et al., 2019], the latter of which also shows that adapting to the total shift of distributions described in Note 4 is possible. The key novelty in these algorithms is adding explicit exploration whose durations are multi-scale, which is made possible by extra randomisation.

31.5

Exercises
31.1 (Exp4 for non-stationary bandits) Let n, m, k  N+. Prove (31.2). In particular, specify first what the experts predict in each round and how Theorem 18.1 gives rise to (31.1) and how (31.2) follows from (31.1).

31.5 Exercises

385

Hint For the second part, you may find it useful to show the following well-

known inequality: for 0  m  n, defining m(n) =

m i=0

n i

,

it

holds

that

(m/n)mm(n)  em.

31.2 (Lower bound for adversarial non-stationary bandits) Let n, m, k  N+ be such that n  mk. Prove that for any policy  there exists an adversarial bandit (yti) such that
 Rnm  c nmk ,

where c > 0 is a universal constant.

31.3 (Unsuitability of Exp3 for non-stationary bandits) Prove for all sufficiently large n that Exp3 from Chapter 11 has Rn2  cn for some universal constant c > 0.

31.4 (Empirical comparison) Let k = 2 and n = 1000, and define adversarial bandit in terms of losses with yt1 = I {t < n/2} and yt2 = I {t  n/2}. Plot the expected regret of Exp3, Exp3-IX and the variant of online stochastic mirror
descent proposed in this chapter. Experiment with a number of learning rates for
each algorithm.

32 Ranking
Ranking is the process of producing an ordered shortlist of m items from a larger collection of items. These tasks come in several flavours. Sometimes the user supplies a query, and the system responds with a shortlist of items. In other applications the shortlist is produced without an explicit query. For example, a streaming service might provide a list of recommended movies when you sign in. Our focus here is on the second type of problem.
We examine a sequential version of the ranking problem where the learner Figure 32.1 A classic ranking problem: selects a ranking, receives feedback which hats to put where on the stand? Higher about its quality and repeats the and towards the front attracts more attention. process over n rounds. The feedback will be in the form of `clicks' from the user, which comes from the view that ranking is a common application in on-line recommendation systems and the user selects the items they like by clicking on them. The objective of the learner is to maximise the expected number of clicks.
Ranking is a huge topic, and our approach is necessarily quite narrow. In fact there is still a long way to go before we have a genuinely practical algorithm for large-scale online ranking problems. As usual, we summarise alternative ideas in the notes.
Stochastic Ranking A permutation on [ ] is an invertible function  : [ ]  [ ]. Let A be the set of all permutations on [ ]. In each round t the learner chooses an action At  A, which should be interpreted as meaning the learner places item At(k) in the kth position. Equivalently, A-t 1(i) is the position of the ith item. Since the shortlist has length m, the order of At(m + 1), . . . , At( ) is not important and is included

32.1 Click Models

387

only for notational convenience. After choosing their action, the learner observes Cti  {0, 1} for each i  [ ], where Cti = 1 if the user clicked on the ith item. Note that the user may click on multiple items. We will assume a stochastic model where the probability that the user clicks on position k in round t only depends on At and is given by v(At, k), with v : A × [ ]  [0, 1] an unknown function. The regret over n rounds is

n

Rn

=

n

max
aA

v(a, k) - E

Cti .

k=1

t=1 i=1

A naive way to minimise the regret would be to create a finite-armed bandit where each arm corresponds to a ranking of the items and then apply your favourite algorithm from Part II. The problem is that these algorithms treat the arms as independent and cannot exploit any structure in the ranking. This is almost always unacceptable because the number of ways to rank m items from a collection of size is !/( - m)!. Ranking illustrates one of the most fundamental dilemmas in machine learning: choosing a model. A rich model leads to low misspecification error, but takes longer to fit. A coarse model can suffer from large misspecification error. In the context of ranking, a model corresponds to assumptions on the function v.

32.1

Click Models
The only way to avoid the curse of dimensionality is to make assumptions. A natural way to do this for ranking is to assume that the probability of clicking on an item depends on (a) the underlying quality of that item and (b) the location of that item in the chosen ranking. A formal definition of how this is done is called a click model. Deciding which model to use depends on the particulars of the problem at hand, such as how the list is presented to the user and whether or not clicking on an item diverts them to a different page. This issue has been studied by the data retrieval community, and there is now a large literature devoted to the pros and cons of different choices. We limit ourselves to describing the popular choices and give pointers to the literature at the end of the chapter.
Document-Based Model The document-based model is one of the simplest click models, which assumes the probability of clicking on a shortlisted item is equal to its attractiveness. Formally, for each item i  [ ], let (i)  [0, 1] be the attractiveness of item i. The document-based model assumes that
v(a, k) = (a(k))I {k  m} .
The unknown quantity in this model is the attractiveness function, which has just parameters.

32.1 Click Models

388

Position-Based Model The document-based model might occasionally be justified, but in most cases the position of an item in the ranking also affects the likelihood of a click. A natural extension that accounts for this behaviour is called the position-based model, which assumes that
v(a, k) = (a(k))(k) ,
where  : [ ]  [0, 1] is a function that measures the quality of position k. Since the user cannot click on items that are not shown, we assume that (k) = 0 for k > m. This model is richer than the document-based model, which is recovered by choosing (k) = I {k  m}. The number of parameters in the position-based models is m + .

Cascade Model

The position-based model is not suitable for applications where clicking on an

item takes the user to a different page. In the cascade model, it is assumed

that the learner scans the shortlisted items in order and only clicks on the first

item they find attractive. Define  : A × [ ]  [0, 1] by



1

if k = 1

(a, k) = 0 kk-=11(1 - (a(k )))

if k > m otherwise ,

which is the probability that the user has not clicked on the first k - 1 items. Then the cascade model assumes that

v(a, k) = (a(k))(a, k) .

(32.1)

The first term in the factorisation is the attractiveness function, which measures the probability that the user is attracted to the ith item. The second term can be interpreted as the probability that the user examines that item. This interpretation is also valid in the position-based model. It is important to emphasise that v(a, k) is the probability of clicking on the kth position when taking action a  A. This does not mean that Ct1, . . . , Ct are independent. The assumptions only restricts the marginal distribution of each Cti, which is sufficient for our purposes. Nevertheless, in the cascade model, it would be standard to assume that CtAt(k) = 0 if there exists an k < k such that CtAt(k ) = 1, and otherwise
P(CtAt(k) = 1 | At, CtAt(1) = 0, . . . , CtAt(k-1) = 0) = I {k  m} (At(k)) .
Like the document-based model, the cascade model has parameters.

Generic Model We now introduce a model that generalises the last three. Previous models essentially assumed that the probability of a click factorises into an attractiveness probability and an examination probability. We deviate from this norm by making

32.1 Click Models

389

a

a

1

2

i

j

3

4

j

i

5

Figure 32.2 Part (c) of Assumption 32.1 says that the probability of clicking in the second position on the left list is larger than the probability of clicking on the second position on the right list by a factor of (i)/(j). For the fourth position, the probability is larger for the right list than the left by the same factor.

assumptions directly on the function v. Given  : [ ]  [0, 1], an action a is called -optimal if the shortlisted items are the m most attractive sorted by attractiveness: (a(k)) = maxk k (a(k )) for all k  [m].
Assumption 32.1. There exists an attractiveness function  : [ ]  [0, 1] such that the following four conditions are satisfied. Let a  A and i, j, k  [ ] be such that (i)  (j), and let  be the permutation that exchanges i and j.

(a) v(a, k) = 0 for all k > m.

(b)

m k=1

v(a,

k)

=

maxaA

m k=1

v(a,

k)

for

all

-optimal

actions

a.

(c) For all i and j with (i)  (j),

v(a, a-1(i))



(i) (j)

v(

 a, a-1(i)) ,

where  is the permutation on [ ] that exchanges i and j. (d) If a is an action such that (a(k)) = (a(k)) for some -optimal action a,
then v(a, k)  v(a, k) .

These assumptions may appear quite mysterious. At some level they are chosen to make the proof go through, while simultaneously generalising the document-based, position-based and cascade models (32.1). The choices are not entirely without basis or intuition, however. Part (a) asserts that the user does not click on items that are not placed in the shortlist. Part (b) says that -optimal actions maximise the expected number of clicks. Note that there are multiple optimal rankings if  is not injective. Part (c) is a little more restrictive and is illustrated in Fig. 32.2. One way to justify this is to assume that v(a, k) = (a(k))(a, k), where (a, k) is viewed as the probability that the user examines position k. It seems reasonable to assume that the probability the user examines position k should only depend on the first k - 1 items. Hence v(a, 2) = (i)(a, 2) = (i)(a , 2) = (i)/(j)v(a , 2). In order the make the argument for the fourth position, we need to assume that placing less attractive items in the early slots increases the probability that the user examines later positions (searching for a good result). This is true for the position-based and

32.2 Policy

390

cascade models, but is perhaps the most easily criticised assumption. Part (d) says that the probability that a user clicks on a position with a correctly placed item is at least as large as the probability that the user clicks on that position in an optimal ranking. The justification is that the items a(1), . . . , a(k - 1) cannot be more attractive than a(1), . . . , a(k - 1), which should increase the likelihood that the user makes it the kth position.
The generic model has many parameters, but we will see that the learner does not need to learn all of them in order to suffer small regret. The advantage of this model relative to the previous ones is that it offers more flexibility, and yet it is not so flexible that learning is impossible.

32.2

Policy
We now explain the policy for learning to rank when v is unknown, but satisfies Assumption 32.1. After the description is an illustration that may prove helpful.
Step 0: Initialisation The policy takes as input a confidence parameter   (0, 1) and and m. The policy maintains a binary relation Gt  [ ] × [ ]. In the first round t = 1 the relation is empty: G1 = . You should think of Gt as maintaining pairs (i, j) for which the policy has proven with high probability that (i) < (j). Ideally, Gt  {(i, j)  [ ] × [ ] : (i) < (j)}.
Step 1: Defining a Partition In each round t, the learner computes a partition of the actions based on a topological sort according to relation Gt. Given A  [ ], define minGt (A) to be the set of minimum elements of A according to relation Gt:
minGt (A) = {i  A : (i, j) / Gt for all j  Gt} .
Then let Pt1, Pt2, . . . be the partition of [ ] defined inductively by
d-1
Ptd = minGt [ ] \ Ptc .
c=1
Finally, let Mt = max{d : Ptd = }. The reader should check that if Gt does not have cycles, then Mt is well defined and finite and that Pt1, . . . , PtMt is indeed a partition of [ ] (Exercise 32.5). The event that Gt contains cycles is a failure event. In order for the policy to be well defined, we assume it chooses some arbitrary fixed action in this case.
Step 2: Choosing an Action Let It1, . . . , ItMt be a partition of [ ] defined inductively by
Itd = [|cdPtc|] \ [|c<dPtc|] .

32.2 Policy

391

Next let t  A be the set of actions  such that (Itd) = Ptd for all d  [Mt]. The algorithm chooses At uniformly at random from t. Intuitively the policy first shuffles the items in Pt1 and uses these as the first |Pt1| entries in the ranking. Then Pt2 is shuffled, and the items are appended to the ranking. This process is repeated until the ranking is complete. For an item i  [ ], we denote by Dti the unique index d such that i  Ptd.

Step 3: Updating the Relation For any pair of items i, j  [ ], define Stij = where

t s=1

Usij

and

Ntij

=

t s=1

|Usij

|,

Utij = I {Dti = Dtj } (Cti - Ctj ) .

All this means is that Stij tracks the difference between the number of clicks on items i and j over rounds when they share a partition. As a final step, the

relation Gt+1 is given by

  Gt+1 = Gt  (j, i) : Stij 



2Ntij log

c

Ntij 

 ,

where c  3.43 is the universal constant given in Exercise 20.10. In the analysis we will show that if (i)  (j), then with high probability Stji is never large enough for Gt+1 to include (i, j). In this sense, with high probability, Gt is consistent with the order on [ ] induced by sorting in decreasing order with respect to (·). Note that Gt is generally not a partial order because it need not be transitive.

Il lustration Suppose = 5 and m = 4, and in round t the relation is Gt = {(3, 1), (5, 2), (5, 3)}, which is represented in the graph below, where an arrow from j to i indicates that (j, i)  Gt.

Pt1

1

2

4

Pt2

3

Pt3

5

It1 = {1, 2, 3} It2 = {4} It3 = {5}

This means that in round t the first three positions in the ranking will contain items from Pt1 = {1, 2, 4} but with random order. The fourth position will be item 3, and item 5 is not shown to the user.

32.3 Regret Analysis

392

Part (a) of Assumption 32.1 means that items in position k > m are never clicked. As a consequence, the algorithm never needs to actually compute the partitions Ptd for which min Itd > m because items in these partitions are never shortlisted.

32.3

Regret Analysis

Theorem 32.2. Let v satisfy Assumption 32.1, and assume that (1) > (2) >

· · · > ( ). Let ij = (i) - (j) and   (0, 1). Then the regret of TopRank is

bounded by





min{m,j-1}

6((i) + (j)) log

Rn  nm 2 +

1 +

j=1

i=1

ij

cn 

.



Furthermore, Rn  nm 2 + m +

4m3 n log

cn 

.

By choosing  = n-1 the theorem shows that the expected regret is at most





Rn

=

O


j=1

min{m,j-1} i=1

(i) log(n)  ij

and

Rn = O m3 n log(n) .

The algorithm does not make use of any assumed ordering on (·), so the
assumption is only used to allow for a simple expression for the regret. The core
idea of the proof is to show that (a) if the algorithm is suffering regret as a
consequence of misplacing an item, then it is gaining information so that Gt will get larger and, (b) once Gt is sufficiently rich, the algorithm is playing optimally. Let Ft = (A1, C1, . . . , At, Ct) and Pt(·) = P(· | Ft) and Et[·] = E[· | Ft]. For each t  [n], let Ft be the failure event that there exists i = j  [ ] and s < t such that Nsij > 0 and

s
Ssij - Eu-1 [Uuij | Uuij = 0] |Uuij | 
u=1

2Nsij log(c Nsij /) .

Lemma 32.3. Let i and j satisfy (i)  (j) and d  1. On the event that i, j  Psd and d  [Ms] and Usij = 0, the following hold almost surely:

(a)

Es-1[Usij | Usij

= 0] 

ij (i) + (j)

.

(b) Es-1[Usji | Usji = 0]  0 .

Proof For the remainder of the proof, we focus on the event that i, j  Psd and d  [Ms] and Usij = 0. We also discard the measure zero subset of this event where

32.3 Regret Analysis

393

Ps-1(Usij = 0) = 0. From now on, we omit the `almost surely' qualification on conditional expectations. Under these circumstances, the definition of conditional
expectation shows that

Es-1[Usij

| Usij

=

0]

=

Ps-1(Csi

=

1, Csj = 0) - Ps-1(Csi Ps-1(Csi = Csj )

=

0, Csj

=

1)

=

Ps-1(Csi = 1) - Ps-1(Csj Ps-1(Csi = Csj )

=

1)



Ps-1(Csi Ps-1(Csi

= =

1) 1)

- Ps-1(Csj + Ps-1(Csj

= =

1) 1)

=

Es-1[v(As, As-1(i)) Es-1[v(As, As-1(i))

- +

v(As, A-s 1(j))] v(As, As-1(j))]

,

(32.2)

where in the second equality we added and subtracted Ps-1(Csi = 1, Csj = 1). By the design of TopRank, the items in Ptd are placed into slots Itd uniformly at random. Let  be the permutation that exchanges the positions of items i and j.
Then using Part (c) of Assumption 32.1,

Es-1[v(As, As-1(i))] =

Ps-1(As = a)v(a, a-1(i))

aA



(i) (j)

Ps-1(As
aA

=

a)v(



a, a-1(i))

=

(i) (j)

Ps-1(As
aA

=





a)v(



a, (



a)-1(j))

=

(i) (j)

Es-1[v(As

,

As-1(j

))]

,

where the second equality follows from the fact that a-1(i) = (  a)-1(j) and the definition of the algorithm ensuring that Ps-1(As = a) = Ps-1(As =   a). The last equality follows from the fact that  is a bijection. Using this and continuing
the calculation in Eq. (32.2) shows that

Eq.

(32.2)

=

Es-1 Es-1

v(As, As-1(i)) - v(As, As-1(j)) v(As, As-1(i)) + v(As, As-1(j))

=

1-

1 + Es-1

2 v(As, As-1(i))

/Es-1

v(As, As-1(j))



1

-

1

+

2 (i)/(j)

=

(i) - (j) (i) + (j)

=

ij (i) + (j)

.

The second part follows from the first since Usji = -Usij.

The next lemma shows that the failure event occurs with low probability.

Lemma 32.4. It holds that P(Fn)   2.

32.3 Regret Analysis

394

Proof The proof follows immediately from Lemma 32.3, the definition of Fn, the union bound over all pairs of actions, and a modification of the Azuma­Hoeffding inequality in Exercise 20.10.

Lemma 32.5. On the event Ftc, it holds that (i, j) / Gt for all i < j.

Proof Let i < j so that (i)  (j). On the event Ftc, either Nsji = 0 or

s
Ssji - Eu-1[Uuji | Uuji = 0]|Uuji| <
u=1

2Nsji log

c 

Nsji

for all s < t .

When i and j are in different blocks in round u < t, then Uuji = 0 by definition. On the other hand, when i and j are in the same block, Eu-1[Uuji | Uuji = 0]  0
almost surely by Lemma 32.3. Based on these observations,

Ssji <

2Nsji log

c 

Nsji

for all s < t ,

which by the design of TopRank implies that (i, j) / Gt.
Lemma 32.6. Let Itd = min Ptd be the most attractive item in Ptd. Then, on event Ftc, it holds that Itd  1 + c<d |Ptd| for all d  [Mt].
Proof Let i = min cdPtc. Then i  1 + c<d |Ptd| holds trivially for any Pt1, . . . , PtMt and d  [Mt]. Now consider two cases. Suppose that i  Ptd. Then it must be true that i = Itd, and our claim holds. On the other hand, suppose that i  Ptc for some c > d. Then by Lemma 32.5 and the design of the partition, there must exist a sequence of items id, . . . , ic in blocks Ptd, . . . , Ptc such that id < · · · < ic = i. From the definition of Itd, Itd  id < i. This concludes our proof.

Lemma 32.7. On the event Fnc and for all i < j, it holds that



Snij



1

+

6((i) + (j)) ij

log

cn 

.

Proof The result is trivial when Nnij = 0. Assume from now on that Nnij > 0. By the definition of the algorithm, arms i and j are not in the same block once Stij grows too large relative to Ntij, which means that

Snij  1 +

2Nnij log

c 

Nnij .

On the event Fnc and part (a) of Lemma 32.3, it also follows that

Snij



ij Nnij (i) + (j)

-

2Nnij log

c 

Nnij .

32.3 Regret Analysis

395

Combining the previous two displays shows that

ij Nnij (i) + (j)

-

2Nnij log

c 

Nnij  Snij  1 +

2Nnij log

c 

  (1 + 2)

Nnij log

c 

Nnij .

Nnij (32.3)

Using the fact that Nnij  n and rearranging the terms in the previous display shows that

Nnij



(1 + 22)2((i) + 2ij

(j))2

log

cn 

.

The result is completed by substituting this into Eq. (32.3).

Proof of Theorem 32.2 The first step in the proof is an upper bound on the expected number of clicks in the optimal list a. Fix time t, block Ptd and recall that Itd = min Ptd is the most attractive item in Ptd. Let k = A-t 1(Itd) be the position of item Itd and  be the permutation that exchanges items k and Itd. By Lemma 32.6, on the event Ftc, we have Itd  k. From Parts (c) and (d) of Assumption 32.1, we have v(At, k)  v(  At, k)  v(a, k). Hence, on the event Ftc, the expected number of clicks on Itd is bounded from below by those on items in a,

Et-1 CtItd

=

Pt-1(A-t 1(Itd) = k)Et-1[v(At, k) | A-t 1(Itd) = k]

kItd

=

1 |Itd|

Et-1[v(At, k) | A-t 1(Itd)
kItd

=

k]



1 |Itd|

v(a, k) ,
kItd

where we also used the fact that TopRank randomises within each block to guarantee that Pt-1(A-t 1(Itd) = k) = 1/|Itd| for any k  Itd. Using this and the
design of TopRank,

m

Mt

Mt

v(a, k) =

v(a, k) 

|Itd|Et-1 CtItd .

k=1

d=1 kItd

d=1

Therefore, under event Ftc, the conditional expected regret in round t is bounded

32.4 Notes

396

by









m

Mt

v(a, k) - Et-1  Ctj   Et-1  |Ptd|CtItd -

Ctj 

k=1

j=1

d=1

j=1


Mt

= Et-1 

(CtItd - Ctj )

d=1 jPtd

Mt

=

Et-1[UtItdj ]

d=1 jPtd

min{m,j-1}



Et-1 [Utij ] .

j=1

i=1

(32.4)

The last inequality follows To see this, use part (a) of

by noting that Lemma 32.3 to

Et-1[UtItd show that

j]  Et-1

min{m,j-1} i=1

Et-1[Utij

].

[Utij]  0 for i < j and

Lemma 32.6 to show that when Itd > m, then neither Itd nor j are not shown to

the user in round t so that UtItdj = 0. Substituting the bound in Eq. (32.4) into

the regret leads to

min{m,j-1}

Rn  nmP(Fn) +

E [I {Fnc} Snij ] ,

j=1

i=1

(32.5)

where we used the fact that the maximum number of clicks over n rounds is nm. The proof of the first part is completed by using Lemma 32.4 to bound the first term and Lemma 32.7 to bound the second. The problem-independent bound follows from Eq. (32.5) and by stopping early in the proof of Lemma 32.7 (Exercise 32.6).

32.4

Notes

1 At no point in the analysis did we use the fact that v is fixed over time. Suppose that v1, . . . , vn are a sequence of click-probability functions that all satisfy Assumption 32.1 with the same attractiveness function. The regret in this setting is

nm

n

Rn =

vt(a, k) - E

Cti .

t=1 k=1

t=1 i=1

Then the bounds in Theorem 32.2 still hold without changing the algorithm.
2 The cascade model is usually formalised in the following more restrictive fashion. Let {Zti : i  [ ], t  [n]} be a collection of independent Bernoulli random variables with P (Zti = 1) = (i). Then define Mt as the first item i in the

32.4 Notes

397

shortlist with Zti = 1:

Mt = min k  [m] : ZtAt(k) = 1 ,

where the minimum of an empty set is . Finally let Cti = 1 if and only if Mt  m and At(Mt) = i. This set-up satisfies Eq. (32.1), but the independence assumption makes it possible to estimate  without randomisation. Notice that in any round t with Mt  m, all items i with A-t 1(i) < Mt must have been unattractive (Zti = 0), while the clicked item must be attractive (Zti = 1). This fact can be used in combination with standard concentration analysis to estimate the attractiveness. The optimistic policy sorts the items in decreasing order by their upper confidence bounds and shortlists the first m. When the confidence bounds are derived from Hoeffding's inequality , this policy is called CascadeUCB, while the policy that uses Chernoff's lemma is called CascadeKLUCB. The computational cost of the latter policy is marginally higher than the former, but the improvement is also quite significant because in practice most items have barely positive attractiveness.
3 The linear dependence of the regret on is unpleasant when the number of items is large, which is the case in many practical problems. Like for finitearmed bandits, one can introduce a linear structure on the items by assuming that (i) = , i where   Rd is an unknown parameter vector and (i)i=1 are known feature vectors. This has been investigated in the cascade model by Zong et al. [2016] and with a model resembling that of this chapter by Li et al. [2019a].
4 There is an adversarial variant of the cascade model. In the ranked bandit model an adversary secretly chooses a sequence of sets S1, . . . , Sn, with St  [ ]. In each round t the learner chooses At  A and receives a reward Xt(At), where Xt : A  [0, 1] is given by Xt(a) = I {St  {a(1), . . . , a(k)} = }. The feedback is the position of the clicked action, which is Mt = min{k  [m] : At(k)  St}. The regret is

n
Rn = (Xt(a) - Xt(At)) ,
t=1

where a is the optimal ranking in hindsight:

n
a = argminaA Xt(a) .
t=1

(32.6)

Notice that this is the same as the cascade model when St = {i : Zti = 1}. 5 A challenge in the ranked bandit model is that solving the offline problem (Eq.
32.6) for known S1, . . . , Sn is NP-hard. How can one learn when finding an optimal solution to the offline problem is hard? First, hardness only matters if |A| is large. When and m are not too large, then exhaustive search is quite feasible. If this is not an option, one may use an approximation algorithm. It turns out that in a certain sense, the best one can do is to use a greedy

32.5 Bibliographic Remarks

398

algorithm, We omit the details, but the highlight is that there exist efficient algorithms such that

n

E

Xt(At)

t=1



1

-

1 e

n

max
aA

t=1

Xt(a)

-

O

m

n log( )

.

See the article by Radlinski et al. [2008] for more details. 6 By modifying the reward function, one can also define an adversarial variant
of the document-based model. As in the previous note, the adversary secretly chooses S1, . . . , Sn as subsets of [ ], but now the reward is

Xt(a) = |St  {a(1), . . . , a(k)}| .

The feedback is the positions of the clicked items, St  {a(1), . . . , a(k)}. For this model, there are no computation issues. In fact, the problem can be analysed using a reduction to combinatorial semi-bandits, which we ask you to investigate in Exercise 32.3. 7 The position-based model can also be modelled in the adversarial setting by letting Stk  [ ] for each t  [n] and k  [m]. Then, defining the reward by
m
Xt(a) = I {At(k)  Stk} .
k=1
Again, the feedback is the positions of the clicked items, {k  [m] : At(k)  Stk}. This model can also be tackled using algorithms for combinatorial semi-bandits (Exercise 32.4).

32.5

Bibliographic Remarks
The policy and analysis presented in this chapter is by the authors and others [Lattimore et al., 2018]. The most related work is by Zoghi et al. [2017], who assumed a factorisation of the click probabilities v(a, k) = (a(k))(a, k) and then made assumptions on . The assumptions made here are slightly less restrictive, and the bounds are simultaneously stronger. Some experimental results comparing these algorithms are given by Lattimore et al. [2018]. For more information on click models, we recommend the survey paper by Chuklin et al. [2015] and the article by Craswell et al. [2008]. Cascading bandits were first studied by Kveton et al. [2015a], who proposed algorithms based on UCB and KL-UCB and prove finite-time instance-dependence upper bounds and asymptotic lower bounds that match in specific regimes. Around the same time, Combes et al. [2015a] proposed a different algorithm for the same model that is also asymptotically optimal. The optimal regret has a complicated form and is not given explicitly in all generality. We remarked in the notes that the linear dependence on is problematic for large . To overcome this problem, Zong et al. [2016] introduce a linear variant where the attractiveness of an item is assumed to be an inner product between an

32.6 Exercises

399

unknown parameter and a known feature vector. A slightly generalised version of this set-up was simultaneously studied by Li et al. [2016], who allowed the features associated with each item to change from round to round. The position-based model is studied by Lagree et al. [2016], who suggest several algorithms and provide logarithmic regret analysis for some of them. Asymptotic lower bounds are also given that match the upper bounds in some regimes. Katariya et al. [2016] study the dependent click model introduced by Guo et al. [2009]. This differs from the models proposed in this chapter because the reward is not assumed to be the number of clicks and is actually unobserved. We leave the reader to explore this interesting model on their own. The adversarial variant of the ranking problem mentioned in the notes is due to Radlinski et al. [2008]. Another related problem is the rank-1 bandit problem, where the learner chooses one of items to place in one of m positions, with all other positions left empty. This model has been investigated by Katariya et al. [2017a,b], who assume the position-based model. The cascade feedback model is also used in a combinatorial setting by Kveton et al. [2015c], but this paper does not have a direct application to ranking. A more in-depth discussion on ranking can be found in the recent book on bandits in information retrieval by Glowacka [2019], which discusses a number of practical considerations, like the cold-start problem.

32.6

Exercises
32.1 (Click models and assumptions) Show that the document-based, position-based and cascade models all satisfy Assumption 32.1.
32.2 (Diversity) Most ranking algorithms are based on assigning an attractiveness value to each item and shortlisting the m most attractive items. Radlinski et al. [2008] criticise this approach in their paper as follows:
"The theoretical model that justifies ranking documents in this way is the probabilistic ranking principle [Robertson, 1977]. It suggests that documents should be ranked by their probability of relevance to the query. However, the optimality of such a ranking relies on the assumption that there are no statistical dependencies between the probabilities of relevance among documents ­ an assumption that is clearly violated in practice. For example, if one document about jaguar cars is not relevant to a user who issues the query jaguar, other car pages become less likely to be relevant. Furthermore, empirical studies have shown that given a fixed query, the same document can have different relevance to different users [Teevan et al., 2007]. This undermines the assumption that each document has a single relevance score that can be provided as training data to the learning algorithm. Finally, as users are usually satisfied with finding a small number of, or even just one, relevant document, the usefulness and relevance of a document does depend on other documents ranked higher."
The optimality criterion Radlinski et al. [2008] had in mind is to present at least one item that the user is attracted to. Do you find this argument convincing? Why or why not?

32.6 Exercises

400

The probabilistic ranking principle was put forward by Maron and Kuhns [1960]. The paper by Robertson [1977] identifies some sufficient conditions under which the principle is valid and also discusses its limitations.
32.3 (Adversarial ranking as a semi-bandit (i)) Frame the adversarial variant of the document-based model in Note 6 as a combinatorial semi-bandit and use the results in Chapter 30 to prove a bound on the regret of
Rn  2m n(1 + log( )) .
32.4 (Adversarial ranking as a semi-bandit (ii)) Adapt your solution to the previous exercise to the position-based model in Note 7, and prove a bound on the regret of
Rn  m 2 n(1 + log( )) .
32.5 (Cycles in partial order) Prove that if Gt does not contain cycles, then Mt defined in Section 32.2 is well defined and that Pt1, . . . , PtMt is a partition of [ ].
32.6 (Worst-case bound for TopRank) Prove the second part of Theorem 32.2.

33 Pure Exploration

All the policies proposed in this book so far were designed to maximise the cumulative reward. As a consequence, the policies must carefully balance exploration against exploitation. But what happens if there is no price to be paid for exploring? Imagine, for example, that a researcher has k configurations of a new drug and a budget to experiment on n mice. The researcher wants to find the most promising drug configuration for subsequent human Figure 33.1 The mouse never trials, but is not concerned with the outcomes benefits from the experiment. for the mice. Problems of this nature are called pure exploration problems. Although there are similarities to the cumulative regret setting, there are also differences. This chapter outlines a variety of pure exploration problems and describes the basic algorithmic ideas.

33.1

Simple Regret

Let  be a k-armed stochastic bandit and  = (t)tn=+11 be a policy. One way to measure the performance of a policy in the pure exploration setting is the simple
regret,

Rsimple
n

(,

)

=

E

An+1 ()

.

The action chosen in round n + 1 has a special role. In the example with the mice, it represents the configuration recommended for further investigation at the end of the trial. We start by analysing the uniform exploration (UE) policy, which explores deterministically for the first n rounds and recommends the empirically best arm in round n + 1. The pseudocode is provided in Algorithm 20.

Theorem 33.1. Let  be the policy of Algorithm 20 and   ESkG(1) be a 1-

subgaussian bandit. Then, for all n  k,





Rsimple
n

(,

)



min
0



+

i() exp

-

n/k

i ( )2 4

.

i:i ( )>

33.1 Simple Regret

402

1: for t = 1, . . . , n do 2: Choose At = 1 + (t mod k) 3: end for 4: Choose An+1 = argmaxi[k] µ^i(n)
Algorithm 20: Uniform exploration.

Proof Let i = i() and P = P. Assume without loss of generality that 1 = 0, and let i be a suboptimal arm with i > . Observe that An+1 = i implies that µ^i(n)  µ^1(n). Now Ti(n)  n/k is not random, so by Theorem 5.3 and Lemma 5.4,

P (µ^i(n)  µ^1(n)) = P (µ^i(n) - µ^1(n)  0)  exp

- n/k 2i 4

.

(33.1)

The definition of the simple regret yields

k

Rsimple
n

(

,

)

=

iP (An+1 = i)   +

iP (An+1 = i) .

i=1

i:i >

The proof is completed by substituting Eq. (33.1) and taking the minimum over all   0.

The theorem highlights some important differences between the simple regret and the cumulative regret. If  is fixed and n tends to infinity, then the simple regret converges to zero exponentially fast. On the other hand, if n is fixed and  is allowed to vary, then we are in a worst-case regime. Theorem 33.1 can be used to derive a bound in this case by choosing  = 2 log(k)/ n/k , which after a short algebraic calculation shows that for n  k there exists a universal constant C > 0 such that

Rsimple
n

(UE,

)



C

k log(k) n

for all   ESkG(1) .

(33.2)

In Exercise 33.1 we ask you to use the techniques of Chapter 15 to prove that for

all

policies

there

exists

a

bandit





ENk (1)

such

that

Rsimple
n

(

,



)



C

k/n for

some universal constant C > 0. It turns out the logarithmic dependence on k in

Eq. (33.2) is tight for uniform exploration (Exercise 33.2), but there exists another

policy for which the simple regret matches the aforementioned lower bound up to

constant factors. There are several ways to do this, but the most straightforward

is via a reduction from algorithms designed for minimising cumulative regret.

Proposition 33.2. Let  = (t)tn=1 be a policy, and define

n+1(i | a1, x1, . . . , an, xn)

=

1 n

n

I {at = i} .

t=1

33.2 Best-Arm Identification with a Fixed Confidence

403

Then the simple regret of (t)tn=+11 satisfies

Rsimple
n

((t

)tn=+11

,



)

=

Rn(, ) n

,

where Rn(, ) is the cumulative regret of policy  = (t)tn=1 on bandit .

Proof By the regret decomposition identity (4.5),

Rn(, ) = nE

k

i

Ti(n) n

i=1

= nE An+1

=

nRsimple
n

((t

)nt=+11

,

)

,

where the first equality follows from the definition of the cumulative regret, the third from the definition of n+1 and the last from the definition of the simple regret.

Corollary 33.3. For all n there exists a policy  such that for all   ESkG(1)

with

()



[0, 1]k

it

holds

that

Rsimple
n

(,



)



C

k/n, where C is a universal

constant.

Proof Combine the previous result with Theorem 9.1.

Proposition 33.2 raises our hopes that policies designed for minimising the cumulative regret might also have well-behaved simple regret. Unfortunately this is only true in the intermediate regimes where the best arm is hard to identify. Policies with small cumulative regret spend most of their time playing the optimal arm and play suboptimal arms just barely enough to ensure they are not optimal. In pure exploration this leads to a highly suboptimal policy for which the simple regret is asymptotically polynomial, while we know from Theorem 33.1 that the simple regret should decrease exponentially fast. More details and pointers to the literature are given in Note 2 at the end of the chapter.

33.2

Best-Arm Identification with a Fixed Confidence
Best-arm identification is a variant of pure exploration where the learner is rewarded only for identifying an exactly optimal arm. There are two variants of best-arm identification. In this section we consider the fixed confidence setting when the learner is given a confidence level   (0, 1) and should use as few samples as possible to output an arm that is optimal with probability at least 1 - . In the other variant the learner has to make a decision after n rounds and the goal is to minimise the probability of selecting a suboptimal arm. We treat this alternative in the next section.
In the fixed confidence setting, the learner chooses a policy  = (t)t=1 as normal. The number of rounds is not fixed in advance, however, the learner chooses a stopping time  adapted to filtration F = (Ft)t=0 with Ft = (A1, X1, . . . , At, Xt). The learner also chooses a F -measurable random variable  taking values in [k]. The stopping time represents the time when the

33.2 Best-Arm Identification with a Fixed Confidence

404

learner halts and   [k] is the recommended action, which by the measurability assumption only depends on (A1, X1, . . . , A , X ). Note that in line with our definition of stopping times (see Definition 3.6), it is possible that  = , which just means the learner cannot ever make up their mind to stop. This behaviour of a learner, of course, will not be encouraged! The function  is called the selection rule.

Definition 33.4. A triple (, , ) is sound at confidence level   (0, 1) for environment class E if for all   E,

P ( <  and () > 0)   .

(33.3)

The objective in fixed confidence best-arm identification is to find a sound learner for which E[ ] is minimised over environments   E. Since this is a multi-objective criteria, there is a priori no reason to believe that a single optimal learner should exist. Conveniently, however, the condition that the learner must satisfy Eq. (33.3) plays the role of the consistency assumption in the asymptotic lower bounds in Chapter 16, which allows for a sense of instance-dependent asymptotic optimality. The situation in finite time is more complicated, as we discuss in Note 7.

If E is sufficiently rich and  has multiple optimal arms, then no sound learner can stop in finite time with positive probability. The reason is that there is no way to reject the hypothesis that one optimal arm is fractionally better than another. You will investigate this in Exercise 33.10. Also note that in our definition, I { = t} is a deterministic function of A1, X1, . . . , At, Xt. None of the results that follow would change if you allowed  or  to also depend on some exogenous source of randomness.

33.2.1

Lower Bound

We start with the lower bound, which serves as a target for the upper bound to follow. Let E be an arbitrary set of k-armed stochastic bandit environments, and for   E define
i() = argmaxi[k] µi() and Ealt() = {  E : i( )  i() = } ,
which is the set of bandits in E with different optimal arms than .

Theorem 33.5. Assume that (, , ) is sound for E at confidence level   (0, 1),

and let   E. Then E[ ]  c() log

1 4

, where

c()-1 = sup
Pk-1

inf
 Ealt()

k
i D(i, i)
i=1

(33.4)

with c() =  when c()-1 = 0.

33.2 Best-Arm Identification with a Fixed Confidence

405

Proof The result is trivial when E[ ] = . For the remainder, assume that E[ ] < , which implies that P( = ) = 0. Next, let   Ealt() and define event E = { <  and  / i( )}  F . Then,

2  P( <  and  / i()) + P ( <  and  / i( ))  P(Ec) + P (E)



1 2

exp

k
- E [Ti( )] D(i, i)
i=1

,

(33.5)

where the first inequality follows from the definition of soundness and the last
from the Bretagnolle­Huber inequality (Theorem 14.2) and the stopping time
version of Lemma 15.1 (see Exercise 15.7). The second inequality holds because P( = ) = 0 and i()  i( ) =  and

Ec = { = }  { <  and   i( )}  { = }  { <  and  / i()} .

Rearranging Eq. (33.5) shows that

k
E [Ti( )] D(i, i)  log
i=1

1 4

,

(33.6)

which implies that E[ ] > 0. Using this, the definition of c() and Eq. (33.6),

E[ ] c()

=

E[ ] sup
Pk-1 

inf
Ealt ( )

k
i D(i, i)
i=1



E[ ]


inf
Ealt ( )

k i=1

E[Ti( )] E[ ]

D(i, i)

k

=



inf
Ealt ( )

i=1

E[Ti( )]

D(i,

i)

 log

1 4

,

(33.7)

where the last inequality follows from Eq. (33.6). Rearranging completes the proof. Note, in the special case that c()-1 = 0, the assumption that E[ ] <  would lead to a contradiction.

Theorem 33.5 does not depend on E being unstructured. The assumption that the bandits are finite armed could also be relaxed with appropriate measureability assumptions.

In a moment, we will prove that the bound in Theorem 33.5 is asymptotically optimal as   0 when E = ENk (1), a result that holds more generally for Bernoulli bandits or when the distributions come from an exponential family.

33.2 Best-Arm Identification with a Fixed Confidence

406

Before this, we devote a little time to understanding the constant c(). Suppose that ()  Pk-1 satisfies

k

c ( )-1

=



inf
Ealt ( )

i=1

i ( )

D(i,

i) .

A few observations about this optimisation problem:

(a) The value of () is unique when E = ENk (1) and   E has a unique optimal arm. Uniqueness continues to hold when E is unstructured with

distributions from an exponential family.
(b) The inequality in Eq. (33.7) is tightest when E[Ti( )]/E[ ] = i(), which shows a policy can only match the lower bound by playing arm i exactly in proportion to i() in the limit as  tends to zero.
(c) When E = EN2 (1) and   E has a unique optimal arm, then

c ( )-1

=

1 2

sup
[0,1] 

inf
Ealt ( )

(µ1() - µ1( ))2 + (1 - )(µ2() - µ2( ))2

=

1 2

sup (1
[0,1]

-

) (µ1()

-

µ2())2

=

1 8

(µ1()

-

µ2())2

.

In this case we observe that 1() = 2() = 1/2. (d) Suppose that 2  (0, )k is fixed and E = {(N (µi, i2)ik=1 : µ  Rk}. You
are asked in Exercise 33.4 to verify that when k = 2,

c()

=

2(1 + 2)2 22

.

(33.8)

which unsurprisingly shows the problem becomes harder as the variance of either of the arms increases. In Exercise 33.4, you will show when k  2, it holds that

2i2 m2 in

+
i=i

2i2 2i

 c() 

2i2 2min

+
i=i

2i2 i2

+2

2i2 2min

i=i

2i2 2i

,

where min = mini=i i is the smallest suboptimality gap. This bound faithfully captures the intuition that each suboptimal arm must be played sufficiently often to be distinguished from the optimal arm, while the optimal arm must be observed sufficiently many times so that it can be distinguished from the second best arm. For k = 2, this bound is smaller than the value of c(), as shown in (33.8), showing that there is room for improvement in this case.

33.2.2

Policy, Stopping/Selection Rule and Upper Bounds
The bound in Theorem 33.5 is asymptotically tight for many environment classes. For simplicity, we focus on the Gaussian case.

33.2 Best-Arm Identification with a Fixed Confidence

407

For this section, we assume that E = ENk (1) is the set of k-armed Gaussian bandits with unit variance.

We need to construct a triple (, , ) that is sound for E and for which E[ ] matches the lower bound in Theorem 33.5 as   0. Both are derived using
the insights provided by the lower bound. The policy should choose action i in proportion to i(), which must be estimated from data. The stopping rule is motivated by noting that Eq. (33.6) implies that a sound stopping rule must
satisfy

k
E[Ti( )] D(i, i)  log
i=1

1 4

for all   Ealt() .

If the inequality is tight, then we might guess that a reasonable stopping rule as the first round t when

k



inf
Ealt ( )

i=1

Ti(t)

D(i,

i)

log

1 

.

There are two problems: (a)  is unknown, so the expression cannot be evaluated, and (b) we have replaced the expected number of pulls with the actual number of pulls. Still, let us persevere. To deal with the first problem, we can try replacing  by the Gaussian bandit environment with mean vector µ^(t), which we denote by ^(t). Then let

Zt

=



inf
Ealt (^(t))

k i=1

Ti(t) D(^i(t), i)

=

1 2

µ

inf
Ealt (µ^(t))

k
Ti(t)(µ^i(t) - µi(
i=1

))2 .

We will show there exists a choice of t()  log(t/) such that if  = min{t : Zt > t()}, then the empirically optimal arm at time  is the best arm with probability at least 1 - . The next step is to craft a policy for which the expectation of 
matches the lower bound asymptotically. As we remarked earlier, if the policy
is to match the lower bound, it should play arm i approximately in proportion to i(). This suggests estimating () by ^(t) = (^(t)) and then playing the arm for which t^i(t) - Ti(t) is maximised. If ^(t) is inaccurate, then perhaps the samples collected will not allow the algorithm to improve its estimates. To
overcome this last challenge, the policy includes enough forced exploration to ensure that eventually ^(t) converges to () with high probability. Combining
all these ideas leads to the track-and-stop policy (Algorithm 21).

Theorem 33.6. Let (, , ) be the policy, stopping time and selection rule of
track-and-stop (Algorithm 21). There exists a choice of t() such that track-andstop is sound and for all   E with |i()| = 1 it holds that

lim
0

E[ ] log(1/)

=

c() .

33.2 Best-Arm Identification with a Fixed Confidence

408

1: Input  and t()

2: Choose each arm once and set t = k

3: while Zt < t() do  4: if argmini[k] Ti(t)  t then

5:

Choose At+1 = argmini[k] Ti(t)

6: else

7:

Choose At+1 = argmaxi[k](t^i(t) - Ti(t))

8: end if

9: Observe reward Xt+1, update statistics and increment t

10: end while

11: return  = i(^(t)),  = t

Algorithm 21: Track-and-stop.

Note that only  does not depend on  inside the limit statement of the theorem, but the stopping time does. The following lemma guarantees the soundness of (, , ).
Lemma 33.7. Let f : [k, )  R be given by f (x) = exp(k - x)(x/k)k and t() = k log(t2 + t) + f -1(). Then, for  = min{t : Zt  t()}, it holds that P (i(^( )) = i())  .
The inverse f -1() is well defined because f is strictly decreasing on [k, ) with f (k) = 1 and limx f (x) = 0. In fact, the inverse has a closedform solution in terms of the Lambert W function. By staring at the form of f one can check that lim0 f -1()/ log(1/) = 1 or equivalently that f -1() = (1 + o(1)) log(1/).

Proof of Lemma 33.7 Notice that |i(^(t))| > 1 implies that Zt = 0. Hence |i(^( ))| = 1 for  < , and the selection rule is well defined. Abbreviate
µ = µ() and  = (), and assume without loss of generality that 1 = 0. By the definition of  and Zt,

{  Ealt(^( ))} 

1 2

k i=1

Ti( )(µ^i( )

-

µi)2



 ()

.

Using the definition of Ealt(^( )) yields

P (1  i(^( ))) = P (  Ealt(^( )))  P

1 2

k i=1

Ti( )(µ^i( )

-

µi)2



 ()

.

Then apply Lemma 33.8 and Proposition 33.9 from Section 33.2.3.

A candidate for t() can be extracted from the proof and satisfies t()  2k log t + log(1/). This can be improved to approximately k log log(t) + log(1/)

33.2 Best-Arm Identification with a Fixed Confidence

409

by using a law of the iterated logarithm bound instead of Lemma 33.8. Below, we sketch the proof of Theorem 33.6. A more complete outline is given in Exercise 33.6.

Proof sketch of Theorem 33.6 Lemma 33.7 shows that (,  ) are sound. It
remains to control the expectation of the stopping time. The intuition is straightforward. As more samples are collected, we expect that ^(t)  () and µ^  µ and

Zt

=

inf
~Ealt (^(t))

k i=1

Ti(t)(µ^i(t) - 2

µi(~))2



t

inf
~Ealt ( )

k i=1

i()(µi() 2

-

µi(~))2

=

t c()

.

Provided the approximation is reasonably accurate, the algorithm should halt once

t c()



t()

=

(1

+

o(1)) log(1/) ,

which occurs once t  (1 + o(1))c() log(1/).

33.2.3

Concentration

The first concentration theorem follows from Corollary 5.5 and a union bound.

Lemma 33.8. Let (Xt) t=1 be a sequence of independent Gaussian random variables

with

mean

µ

and

unit

variance.

Let

µ^n

=

1 n

n t=1

Xt.

Then

P

exists

n



N+

:

n 2

(µ^n

-

µ)2



log(1/)

+

log(n(n

+

1))

 .

As we remarked earlier, the log(n(n + 1)) term can be improved to approximately log log(n). You can do this using peeling (Chapter 9) or the method of mixtures (Exercise 20.9). Since (Xt) are Gaussian, you can also use the tangent approximation and the Bach´elier­Levy formula (Exercise 9.4).

Proposition 33.9. Let g : N  R be increasing, and for each i  [k], let Si1, Si2, . . . be an infinite sequence of random variables such that for all   (0, 1),
P (exists s  N : Sis  g(s) + log(1/))   .

33.3 Best-Arm Identification with a Budget

410

Then, provided that (Si)ki=1 are independent and x  0,

k
P exists s  Nk : Sisi  kg

k
si

+x



x k

k
exp(k - x) .

i=1

i=1

Proof For i  [k], let Wi = max{w  [0, 1] : Sis < g(s) + log(1/w) for all s  N},
where we define log(1/0) = . Note that Wi are well defined. Then, for any s  Nk,

k

k

k

Sisi  g(si) + log(1/Wi)  kg

i=1

i=1

i=1

k
si
i=1

k
+ log(1/Wi) .
i=1

By assumption, (Wi)ik=1 are independent and satisfy P (Wi  x)  x for all x  [0, 1]. The proof is completed using the result of Exercise 5.16.

33.3

Best-Arm Identification with a Budget

In the fixed-budget variant of best-arm identification, the learner is given the horizon n and should choose a policy  = (t)tn=+11 with the objective of minimising the probability that An+1 is suboptimal. The constraint on the horizon rather than the confidence level makes this setting a bit more nuanced than the fixed
confidence setting, and the results are not as clean.
A naive option is to use the uniform exploration policy, but as discussed in
Section 33.1, this approach leads to poor results when the suboptimality gaps
are not similar to each other. To overcome this problem, the sequential halving
algorithm divides the budget into L = log2(k) phases. In the first phase, the algorithm chooses each arm equally often. The bottom half of the arms are then
eliminated, and the process is repeated.

1: Input n and k

2: Set L = log2(k) and A1 = [k]. 3: for = 1, . . . , L do

4:

Let T =

n L|A |

.

5: Choose each arm in A exactly T times

6: For each i  A compute µ^i as the empirical mean of arm i based on the last T samples

7: Let A +1 contain the top |A |/2 arms in A

8: end for

9: return An+1 as the arm in AL+1

Algorithm 22: Sequential halving.

Theorem 33.10. If   ESkG(1) has mean vector µ = µ() and µ1  · · ·  µk and

33.4 Notes

411

 is sequential halving, then

P(An+1 > 0)  3 log2(k) exp

-

n 16H2(µ)

log2(k)

,

where

H2(µ)

=

maxi:i>0

i i2

.

The assumption on the ordering of the means is only needed for the clean

definition of H2, which would otherwise be defined by permuting the arms. The

algorithm is completely symmetric. In Exercise 33.8 we guide you through the

proof of Theorem 33.10.

The quantity H2(µ) looks a bit unusual, but arises naturally in the

analysis. It is related to a more familiar quantity as follows. Define H1(µ) =

k i=1

min{1/2i ,

1/m2 in}.

Then

H2(µ)  H1(µ)  (1 + log(k))H2(µ) .

(33.9)

Furthermore, both inequalities are essentially tight (Exercise 33.7). Let's see how the bound in Theorem 33.10 compares to uniform exploration, which is the same as Algorithm 20. Like in the proof of Theorem 33.1, the probability that uniform exploration selects a suboptimal arm is easily controlled using Theorem 5.3 and Lemma 5.4:

P,UE(An+1 > 0) 

P (µ^i(n)  µ^1(n)) 

exp

-

n/k 4

2i

.

i:i >0

i:i >0

Suppose that  = 2 = k so that all suboptimal arms have the same suboptimality gap. Then H2 = k/2 and terms in the exponent for sequential halving and uniform exploration are (n2/(k log k)) and (n2/k), respectively,
which means that uniform exploration is actually moderately better than
sequential halving, at least if n is sufficiently large. On the other hand, if 2 =  is small, but i = 1 for all i > 2, then H2 = (1/2) and the exponents are (n2) and (n2/k) respectively and sequential halving is significantly better.
The reason for the disparity is the non-adaptivity of uniform exploration, which
wastes many samples on arms i > 2. Although there are not asymptotically
matching upper and lower bounds in the fixed budget setting, the bound of
sequential halving is known to be roughly optimal.

33.4

Notes
1 The problems studied in this chapter belong to the literature on stochastic optimisation, where the simple regret is called the expected suboptimality. There are many variants of pure exploration. In the example at the start of the chapter, a medical researcher may be interested in getting the most reliable information about differences between treatments. This falls into the class of pure information-seeking problems, the subject of optimal experimental design from statistics, which we have met earlier.

33.4 Notes

412

2 We mentioned that algorithms with logarithmic cumulative regret are not well
suited for pure exploration. Suppose  has asymptotically optimal cumulative regret on E = ENk , which means that limn E[Ti(n)]/ log(n) = 2/i() for all   E. You will show in Exercise 33.5 that for any  > 0, there exists a
  E with a unique optimal arm such that

lim inf
n

- log (P(An+1 log(n)



i()))



1

+

.

This shows that using an asymptotically optimal policy for cumulative regret

minimisation leads to a best-arm identification policy for which the probability

of selecting a suboptimal arm decays only polynomially with n. This result

holds no matter how An+1 is selected.

3 A related observation is that the empirical estimates of the means after running

an algorithm designed for minimising the cumulative regret tend to be negatively

biased. This occurs because these algorithms play arms until their empirical

means are sufficiently small.

4 Although there is no exploration/exploitation dilemma in the pure exploration

setting, there is still an `exploration dilemma' in the sense that the optimal

exploration policy depends on an unknown quantity. This means the policy

must balance (to some extent) the number of samples dedicated to learning

how to explore relative to those actually exploring.

5 Best-arm identification is a popular topic that lends itself to simple analysis

and algorithms. The focus on the correct identification of an optimal arm

makes us question the practicality of the setting, however. In reality, any

suboptimal arm is acceptable provided its suboptimality gap is small enough

relative to the budget, which is more faithfully captured by the simple

regret criterion. Of course the simple regret may be bounded naively by

Rsimple
n



maxi iP

An+1 > 0

,

which

is

tight

in

some

circumstances

and

loose in others.

6 An equivalent form of the bound shown in Theorem 33.5 is

k

k

E[ ]  min

i
i=1

:

1, . . . , k



0,

inf
 Ealt ( )

i=1

iD(i,

i)



log(4/)

.

This form follows immediately from Eq. (33.6) by noting that E[ ] = i E[Ti( )]. The version given in the theorem is preferred because it is
a closed form expression. Exercise 33.3 asks you to explore the relation between
the two forms.

7 The forced exploration in the track-and-stop algorithm is sufficient for

asymptotic optimality. for any threshold Ctp

We are uneasy with p  (0, 1).

about There

the fact that the proof would work is nothing fundamental about t.

We do not currently know of a principled way to tune the amount of forced

exploration or if there is better algorithm design for best-arm identification.

Ideally one should provided finite-time upper bounds that match the finite-time

33.5 Bibliographical Remarks

413

lower bound provided by Theorem 33.5. The extent to which this is possible appears to be an open question. 8 The choice of t() significantly influences the practical performance of trackand-stop. We believe the analysis given here is mostly tight except that the naive concentration bound given in Lemma 33.8 can be improved using a finite-time version of the law of the iterated logarithm (see Exercise 20.9, for example). 9 Perhaps the most practical set-up in pure exploration has not yet received any attention, which is upper and lower instance-dependent bounds on the simple regret. Even better would be to have an understanding of the distribution of An+1 .

33.5

Bibliographical Remarks
In the machine learning literature, pure exploration for bandits seems to have been first studied by Even-Dar et al. [2002], Mannor and Tsitsiklis [2004] and Even-Dar et al. [2006] in the `Probability Approximately Correct' setting, where the objective is to find an -optimal arm with high probability with as few samples as possible. After a dry spell, the field was restarted by Bubeck et al. [2009] and Audibert and Bubeck [2010b]. The asymptotically optimal algorithm for the fixed confidence setting of Section 33.2 was introduced by Garivier and Kaufmann [2016], who also provide results for exponential families as well as in-depth intuition and historical background. Degenne and Koolen [2019] and Degenne et al. [2019] have injected some new ideas into the basic principles of track-andstop by incorporating a kind of optimism and solving the optimisation problem incrementally using online learning, which leads to theoretical and practical improvements. A similar problem is studied in a Bayesian setting by Russo [2016], who focuses on designing algorithms for which the posterior probability of choosing a suboptimal arm converges to zero exponentially fast with an optimal rate. Even more recently, Qin et al. [2017] designed a policy that is optimal in both the frequentist and Bayesian settings. The stopping rule used by Garivier and Kaufmann [2016] is inspired by similar rules by Chernoff [1959]. The sequential halving algorithm is by Karnin et al. [2013], and the best summary of lower bounds is by Carpentier and Locatelli [2016]. Besides this there have been many other approaches, with a summary by Jamieson and Nowak [2014]. The negative result discussed in Note 2 is due to Bubeck et al. [2009]. Pure exploration has recently become a hot topic and is expanding beyond the finite-armed case. For example, to linear bandits [Soare et al., 2014] and continuous-armed bandits [Valko et al., 2013a], tree search [Garivier et al., 2016a, Huang et al., 2017a] and combinatorial bandits [Chen et al., 2014, Huang et al., 2018].
The continuous-armed case is also known as zeroth-order (or derivativefree) stochastic optimisation and is studied under various assumptions on the unknown reward function, usually assuming that A  Rd. Because of the

33.5 Bibliographical Remarks

414

obvious connection to optimisation, this literature usually considers losses, or cost, rather than reward, and the reward function is then called the objective function. A big part of this literature poses only weak assumptions, such as smoothness, on the objective function. Note that in the continuous-armed case, regret minimisation may only be marginally more difficult than minimising the simple regret because even the instance-dependent simple regret can decay at a slow, polynomial rate. While the literature is vast, most of it is focused on heuristic methods without rigorous finite-time analysis. Methods developed for this case maintain an approximation to the unknown objective and often use branch-and-bound techniques to focus the search for the optimal value. For a taster of the algorithmic ideas, see [Conn et al., 2009, Rios and Sahinidis, 2013]. When the search for the optimum is organised cleverly, the methods can adapt to `local smoothness' and enjoy various optimality guarantees [Valko et al., 2013a]. A huge portion of this literature considers the easier problem of finding a local minimiser, or just a stationary point. Another large portion of this literature is concerned with the case when the objective function is convex. Chapter 9 of the classic book by Nemirovsky and Yudin [1983] describes two complementary approaches (a geometric, and an analytic) and sketches their analysis. For the class of strongly convex and smooth functions, it is known that the minimax simple regret is ( d2/n) [Shamir, 2013]. The main outstanding challenge is to understand the dependence of simple regret on the dimension beyond the strongly convex and smooth case. Hu et al. [2016] prove a lower bound of (n-1/3) on the simple-regret for algorithms that construct gradient estimates by injecting random noise (as is done by Katkovnik and Kulchitsky [1972], Nemirovsky and Yudin [1983] and others), which, together with the O(n-1/2) upper bound by Nemirovsky and Yudin [1983] (see also Agarwal et al. 2013, Liang et al. 2014), establishes the inferiority of this approach in the n d regime. Interestingly, empirical evidence favours these gradient-based techniques in comparison to the `optimal algorithms'. Thus, much room remains to improve our understanding of this problem. This setting is to be contrasted to the one when unbiased noisy estimates of the gradient are available where methods such as mirror descent (see Chapter 28) give optimal rates. This is a much better understood problem with matching lower and upper bounds available on the minimax simple regret for various settings (for example, Chapter 5 of Nemirovsky and Yudin [1983], or Rakhlin et al. [2012]).
Variants of the pure exploration problem are studied in a branch of statistics called ranking and selection. The earliest literature on ranking and selection goes back to at least the 1950s. A relatively recent paper that gives a glimpse into a small corner of this literature is by Chan and Lai [2006]. The reason we cite this paper is because it is particularly relevant for this chapter. Using our terminology, Chan and Lai consider the PAC setting in the parametric setting when the distributions underlying the arms belong to some known exponential family of distributions. A procedure that is similar to the track-and-stop procedure considered here is shown to be both sound and asymptotically optimal as the

33.6 Exercises

415

confidence parameter approaches one. We also like the short and readable review of the literature up to the 1980s from the perspective of simulation optimisation by Goldsman [1983].
A related setting studied mostly in the operations research community is ordinal optimisation. In its simplest form, ordinal optimisation is concerned with finding an arm amongst the k arms with the highest pay-offs. Ho et al. [1992], who defined this problem in the stochastic simulation optimisation literature, emphasised that the probability of failing to find one of the `good arms' decays exponentially with the number of observations n per arm, in contrast to the slow n-1/2 decay of the error of estimating the value of the best arm, which this literature calls the problem of cardinal optimisation. Given the results in this chapter, this should not be too surprising. A nice twist in this literature is that the error probability does not need to depend on k (see Exercise 33.9). The price, of course, is that the simple regret is in general uncontrolled. In a way, ordinal optimisation is a natural generalisation of best-arm identification. As such, it also leads to algorithmic choices that are not the best fit when the actual goal is to keep the simple regret small. Based on a Bayesian reasoning, a heuristic expression for the asymptotically optimal allocation of samples for the Gaussian best-arm identification problem is given by Chen et al. [2000]. They call the problem of finding an optimal allocation the `optimal computing budget allocation' (OCBA) problem. Their work can be viewed as the precursor to the results in Section 33.2. Glynn and Juneja [2015] gives further pointers to this literature, while connecting it to the bandit literature.
Best-arm identification has also been considered in the adversarial setting [Jamieson and Talwalkar, 2016, Li et al., 2018, Abbasi-Yadkori et al., 2018]. Another related setting is called the max-armed bandit problem, where the objective is to obtain the largest possible single reward over n rounds [Cicirello and Smith, 2005, Streeter and Smith, 2006a,b, Carpentier and Valko, 2014, Achab et al., 2017].

33.6

Exercises

33.1 (Simple regret lower bound) Show there exists a universal constant

C > 0 such that for all n  k > 1 and all policies , there exists a   ENk such

that

Rsimple
n

(

,



)



C

k/n.

33.2 (Suboptimality of uniform exploration) Show there exists a universal

constant C > 0 such that for all n  k > 1, there exists a   ENk such that

Rsimple
n

(UE,

)



C

k log(k)/n.

33.6 Exercises

416

33.3 Let L > 0 and D  [0, )k \ {0} be non-empty. Show that

-1

inf



1

:   [0, )k, inf , d
dD

L

=

sup inf , d
Pk-1 dD

L.

33.4 (Best-arm identification for Gaussian bandits) Let 12, . . . , k2 be fixed and E = {(N (µi, i2))ki=1 : µ  Rk} be the set of Gaussian bandits with given variances. Let   E be a bandit with µ1() > µi() for all i > 1. Abbreviate
µ = µ() and  = ().

(a) For any   [0, )k show that

inf
~Ealt ( )

k
i D(i, ~i)
i=1

=

1 2

min
i>1

1ii2 1i2 + i12

.

(b) Show that if k = 2, then c() = 2(1 + 2)2/22.

(c)

Show

that

c() 

212 min

k
+
i=2

2i2 2i

.

(d) Show that

c()



212 min

+

k i=2

2i2 2i

+

2

212 2min

k i=2

2i2 i2

.

(33.10)

(e) Show that if i2/2i = 12/2min for all i, then equality holds in Eq. (33.10).

33.5 (Suboptimality of cumulative regret algorithms for best-arm identification) Suppose  is an asymptotically optimal bandit policy in E = ENk in the sense that

lim
n

Rn(, ) log(n)

=

i:i ( )>0

2 i()

for all   E .

(a) For any  > 0, prove there exists a   E with a unique optimal arm such that

lim inf
n

- log(P(An+1 log(n)

>

0))



1

+

.

(b) Can you prove the same result with lim inf replaced by lim sup? (c) What happens if the assumption that  is asymptotically optimal is replaced
with the assumption that there exists a universal constant C > 0 such that

Rn(, )  C
i:i ( )>0

i()

+

log(n) i()

.

33.6 (Analysis of track-and-stop) In this exercise, you will complete the proof of Theorem 33.6. Assume that  has a unique optimal arm. Make E a

33.6 Exercises

417

metric space via the metric d(1, 2) = µ(1) - µ(2) . Let  > 0 be a small constant, and define random times
() = 1 + max {t : d(^t, )  } () = 1 + max {t : () - (^t)   } T () = 1 + max {t : T (t)/t - i()   } .
Note, these are not stopping times. Do the following:
(a) Show that () is unique. (b) Show  is continuous at . (c) Prove that E[()] <  for all  > 0. (d) Prove that E[()] <  for all  > 0. (e) Prove that E[T ()] <  for all  > 0. (f) Prove that lim0 E[ ]/ log(1/)  c().

33.7 (Complexity measure comparison) Prove the following:

(a) Let L = 1 +

k i=3

1 i

and

show

that

H2(µ)



H1(µ)



LH2(µ).

Combine

this

with the fact that L  1 + log(k) to prove that Eq. (33.9) holds.

(b) Find µ and µ such that H2(µ) = H1(µ) and H1(µ ) = LH2(µ ). Conclude the inequalities in Eq. (33.9) are tight.

33.8 (Analysis of sequential halving) The purpose of this exercise is to

prove Theorem 33.10. Assume without loss of generality that µ = µ() satisfies

µ1  µ2  . . .  µk. Given a set A  [k], let









TopM(A, m) = i  [k] : I {j  A}  m
ji

be the top m arms in A. To make life easier, you may also assume that k is a power of two so that |A | = k21- and T = n2 -1/ log2(k).

(a) Prove that |AL+1| = 1. (b) Let i be a suboptimal arm in A , and suppose that 1  A . Show that

P µ^1  µ^i i  A , 1  A

 exp

-T

i2 4

.

(c) Let A = A \ TopM(A , |A |/4 ) be the bottom three-quarters of the arms

in round . Show that if the optimal arm is eliminated after the th phase,

then

N=

I

µ^i  µ^1



1 3

|A

|.

iA

(d) Let i = min A and show that

E[N | A ]  |A | max exp
iA

-

i2n2 4 log2

-1
(k)

 |A | exp

-

16i

ni2 log2(k)

.

33.6 Exercises

418

(e) Combine the previous two parts with Markov's inequality to show that

P (1 / A +1 | 1  A )  3 exp

- T 2i 16 log2(k)i

.

(f) Join the dots to prove Theorem 33.10.

33.9 Let P be a distribution over the measurable set X , µ : X  [0, 1] be measurable, ,   (0, 1), and define µ = inf{y : P (µ(X) < y)  1 - }. Show that if n  log(1/)/ log(1/(1 - )), then for X1, . . . , Xn  P independent, with probability 1 - , it holds that maxi[n] µ(Xi)  µ .
33.10 (Multiple optimal arms and soundness) Throughout this exercise, let k > 1.
(a) Let E = ENk (1). Prove that for any sound pair (,  ) and   E with |i()| > 1, it holds that P( = ) = 1.
(b) Repeat the previous part with E = EBk. (c) Describe an unstructured class of k-armed stochastic bandits E and   E
with |i()| > 1 and sound pair (,  ) for which P( = ) = 0.

33.11 (Probably approximately correct algorithms) This exercise is about designing (, )-PAC algorithms.

(a) For each  > 0 and   (0, 1) and number of arms k > 1, design a policy  and stopping time  such that for all   E,

P(A  )  

and

E[ ]



Ck 2

log

k 

,

for universal constant C > 0. (b) It turns out the logarithmic dependence on k can be eliminated. Design a
policy  and stopping time  such that for all   E,

P(A  )  

and

E[ ]



Ck 2

log

1 

.

(c) Prove a lower bound showing that the bound in part (b) is tight up to constant factors in the worst case.

Hint Part (b) of the above exercise is a challenging problem. The simplest approach is to use an elimination algorithm that operates in phases where at the end of each phase, the bottom half of the arms (in terms of their empirical estimates) are eliminated. For details, see the paper by Even-Dar et al. [2002].

34 Foundations of Bayesian Learning

e!TEX root = ../../book.tex Bayesian methods have been used for bandits from the beginning of the field and
dominated research from 1950 until 1980. This chapter introduces the Bayesian viewpoint and develops the technical tools necessary for applications in bandits. Readers who are already familiar with the measure-theoretic Bayesian analysis can skim Sections 34.4 and 34.6 for the notation used in subsequent chapters.

34.1

Statistical Decision Theory and Bayesian Learning
The fundamental challenge in learning problems is that the true environment is unknown and policies that are optimal in one environment are usually not optimal in another. This forces the user to make trade-offs, balancing performance between environments. We have already discussed this in the context of finitearmed bandits in Part IV. Here we take a step back and consider a more general set-up.
Let E be a set of environments and  a set of policies. These could be bandit environments/policies, but for now an abstract view is sufficient. A loss function is a mapping : E ×   R with (, ) representing the loss suffered by policy  in environment . Of course you should choose a policy that makes the loss small, but most choices are incomparable because the loss depends on the environment. Fig. 34.1 illustrates a typical situation with four policies. Some policies can be eliminated from consideration because they are dominated, which means they suffer at least as much loss as some other policy on all environments and more loss on at least one. A policy that is not dominated is called admissible or Pareto optimal . Choosing between admissible policies is non-trivial. One canonical choice of admissible policy (assuming it exists) is a minimax optimal policy   argmin sup (,  ). Minimax optimal policies enjoy robustness, but the price may be quite large on average. Would you choose the minimax optimal policy in the example in Fig. 34.1?
In the Bayesian viewpoint, the uncertainty in the environment is captured by choosing a prior probability measure on E that reflects the user's belief about the environment the learner will face. Having committed to a prior, the Bayesian optimal policy simply minimises the expected loss with respect to the prior.

34.2 Bayesian Learning and the Posterior Distribution

420

1

1, admissible

Loss

2, dominated 3, minimax optimal

4, admissible

00

1

Environments

Figure 34.1 Loss as a function of the environment for four different polices 1, . . . , 4, when E = [0, 1]. Which policy would you choose?

When E is countable, a measure corresponds to a probability vector q  P(E), and the Bayesian optimal policy with respect to q is an element of
argmax q() (, ) .
E
The Bayesian viewpoint is hard to criticise when the user really does know the underlying likelihood of each environment and the user is risk-neutral. Even when the distribution is not known exactly, however, sensible priors often yield provably sensible outcomes, regardless of whether one is interested in the average loss across the environments, or the worst-case loss, or some other metric.
A distinction is often made between the Bayesian and frequentist viewpoints, which naturally leads to heated discussions on the merits of one viewpoint relative to another. This debate does not interest us greatly. We prefer to think about the pros and cons of problem definitions and solution methods, regardless of the label on them. Bayesian approaches to bandits have their strengths and weaknesses, and we hope to do them a modicum of justice here.

34.2

Bayesian Learning and the Posterior Distribution
The last section explained the `forward view', where a policy is chosen in advance that minimises the expected loss. The Bayesian can also act sequentially by updating their beliefs (the prior) as data is observed to obtain a new distribution

34.2 Bayesian Learning and the Posterior Distribution

421

on the set of environments (more generally, the set of hypotheses). The new distribution is called the posterior. This is simple and well defined when the environment set is countable, but quickly gets technical for larger spaces. We start gently with a finite case and then explain the measure-theoretic machinery needed to rigourously treat the general case.
Suppose you are given a bag containing two marbles. A trustworthy source tells you the bag contains either (a) two white marbles (ww) or (b) a white marble and a black marble (wb). You are allowed to choose a marble from the bag (without looking) and observe its colour, which we abbreviate by `observe white' (ow) or `observe black' (ob). The question is how to update your `beliefs' about the contents of the bag having observed one of the marbles. The Bayesian way to tackle this problem starts by choosing a probability distribution on the space of hypotheses, which, incidentally, is also called the prior. This distribution usually reflects one's beliefs about which hypotheses are more probable. In the lack of extra knowledge, for the sake of symmetry, it seems reasonable to choose P(ww) = 1/2 and P(wb) = 1/2. The next step is to think about the likelihood of the possible outcomes under each hypothesis. Assuming that the marble is selected blindly (without peeking into the bag) and the marbles in the bag are well shuffled, these are

P(ow | ww) = 1 and P(ow | wb) = 1/2 .

The conditioning here indicates that we are including the hypotheses as part of the probability space, which is a distinguishing feature of the Bayesian approach. With this formulation we can apply Bayes' law (Eq. (2.2)) to show that

P(ww | ow)

=

P(ow | ww)P(ww) P(ow)

=

P(ow | ww)P(ww) P(ow | ww)P(ww) + P(ow | wb)P(wb)

=

1

×

1 2

1

×

1 2

+

1 2

×

1 2

=

2 3

.

Of course P(wb | ow) = 1 - P(ww | ow) = 1/3. Thus, while in the lack of

observations, `a priori', both hypotheses are equally likely, having observed a

white marble, the probability that the bag originally contained two white marbles

(and thus the bag has a white marble remaining in it) jumps to 2/3. An alternative

calculation shows that P(ww | ob) = 0, which makes sense because choosing a

black marble rules out the hypothesis that the bag contains two white marbles.

The conditional distribution P( · | ow) over the hypotheses is called the posterior

distribution and represents the Bayesian's belief in each hypothesis after observing

a white marble.

34.2.1

A Rigorous Treatment of Posterior Distributions
A more sophisticated approach is necessary when the hypothesis and/or outcome spaces are not discrete. In introductory texts, the underlying details are often (quite reasonably) swept under the rug for the sake of clarity. Besides the desire

34.2 Bayesian Learning and the Posterior Distribution

422

for generality, there are two reasons not to do this. First, having spent the effort developing the necessary tools in Chapter 2, it would seem a waste not to use them now. And second, the subtle issues that arise highlight some real consequences of the differences between the Bayesian and frequentist viewpoints. As we shall see, there is a real gap between these viewpoints.
Let  be a set called the hypothesis space and G be a -algebra on . While  is often a subset of a Euclidean space, we do not make this assumption. A prior is a probability measure Q on (, G). Next, let (U, H) be a measurable space and P = (P :   ) be a probability kernel from (, G) to (U, H). We call P the model. Let  =  × U and F = G  H. The prior and the model combine to yield a probability P = Q  P on (, F). The prior is now the marginal distribution of the joint probability measure: Q(A) = P(A × U). Suppose a random element X on  describes what is observed. Then, generalizing the previous example with the marbles, the posterior should somehow be the marginal of the joint probability measure conditioned X. To make this more precise, let (X , J ) be a measurable space and X :   X a F/J -measurable map. The posterior having observed that X = x should be a measure Q( · | x) on (, G).
We abuse notation by letting  :    denote the F/G-measurable random element given by the projection: ((, u)) = . This allows  being used as part of the probability expressions below.

Without much thought, we might try and apply Bayes' law (Eq. (2.2)) to claim that the posterior distribution having observed X() = x should be a measure on (, G) given by

Q(A | x)

=

P (



A|

X

=

x)

=

P (X

=

x |   A) P P (X = x)

(



A)

.

(34.1)

The problem with the `definition' in (34.1) is that P (X = x) can have measure zero, and then P (  A | X = x) is not defined. This is not an esoteric problem. Consider the problem when  is randomly chosen from  = R and its distribution is Q = N (0, 1), the parameter  is observed in Gaussian noise with a variance of one: U = R, P = N (, 1) for all   R and X(, u) = u for all (, u)  ×U . Even in this very simple example, we have P (X = x) = 0 for all x  R. Having read Chapter 2, the next attempt might be to define Q(A | X) as a (X)-measurable
random variable defined using conditional expectations: for A  G,

Q(A | x) = E[I {  A} | X](x) ,

where we remind the reader that E[I {  A} | X] is a (X)-measurable random variable that is uniquely defined except for a set of measure zero and also that the notation on the right-hand side is explained in Fig. 2.4 in Chapter 2. For most applications of probability theory, the choice of conditional expectation does not matter. However, as we shortly illustrate with an example, this is not

34.2 Bayesian Learning and the Posterior Distribution

423

true here. A related annoying issue is that Q( · | x) as defined above need not be a measure. By assuming that (, G) is a Borel space, this issue can be overcome by using a regular version (Theorem 3.11), a result that we restate here using the present notation.
Theorem 34.1. If (, G) is a Borel space, then there exists a probability kernel Q : X ×G  [0, 1] such that Q(A | X) = P (  A | X) simultaneously for all A  G outside of some P-null set. Furthermore, for any two probability kernels Q, Q satisfying this condition, Q(· | x) = Q (· | x) for all x in some set of PX -probability one.

The Posterior Density Theorem 34.1 provides weak conditions under which a posterior exists but does not suggest a useful way of finding it. In many practical situations, the posterior can be calculated using densities. Given    let p be the Radon­Nikodym derivative of P with respect to some measure µ and let q() be the Radon­ Nikodym derivative of Q with respect to another measure . Provided all terms are appropriately measurable and non-zero, then

q( | x) =

p (x)q ()  p(x)q()d()

(34.2)

is the Radon­Nikodym derivative of Q( · | x) with respect to , also known as the posterior density of Q. In other words, for any A  G, it holds that Q(A | x) = A q( | x)d(). This corresponds to the usual manipulation of densities when µ and  are the Lebesgue measures.
The reader may wonder about why all the fuss about the existence of Q( · | x) in the previous section if we can get its density with a simple formula like (34.2). In other words, why not flip around things and define Q( · | x) via (34.2)? The crux of the problem is that oftentimes it is hard to come up with an appropriate dominating measure µ, and in general the denominator in the right-hand side of (34.2) could be zero from some particular value of x. But when we can identify an appropriate measure µ and the denominators are non-zero, the above formula can indeed be used as the definition of Q( · | x) (Exercise 34.4).

The Non-uniqueness Issue Frequentists Face A minor annoyance when using Bayesian methods as part of a frequentist argument is that the posterior need not be unique.
Example 34.2. Consider the situation when the hypothesis set is the [0, 1] interval, the prior is the uniform distribution, and the observation is equal to the hypothesis sampled. Formally,  = [0, 1] and the prior Q is the uniform measure on (, B()), P =  is the Dirac measure on [0, 1] at , and X : [0, 1]  [0, 1] is the identity: X(x) = x for all x  [0, 1]. Let C  [0, 1] be an arbitrary countable set and µ be an arbitrary probability measure on ([0, 1], B(R)). It is not hard to

34.3 Conjugate Pairs, Conjugate Priors and the Exponential Family

424

see that the probability kernel
Q(A | x) = x(A) , if x / C ; µ(A) , if x  C
satisfies the conditions of Theorem 34.1 and is thus one of the many versions of the posterior, regardless of the choice of C and µ!
A true Bayesian is unconcerned. If  is sampled from the prior Q, then the event {X  C} has measure zero, and there is little cause to worry about events that happen with probability zero. But for a frequentist using Bayesian techniques for inference, this actually matters. If  is not sampled from Q, then nothing prevents the situation that   C and the non-uniqueness of the posterior is an issue (Exercise 34.12). Probability theory does not provide a way around this issue.
It follows that one must be careful to specify the version of the posterior being used when using Bayesian techniques for inference in a frequentist setting because in the frequentist viewpoint,  is not part of the probability space and results are proven for P for arbitrary fixed   . By contrast, the all-in Bayesians include  in the probability space and thus will not worry about events with negligible prior probability, and for them any version of the posterior will do.
Although it is important to be aware of the non-uniqueness of the posterior, practically speaking it is hard to go wrong. In typical applications, there is a `canonical' choice. For example, in the Gaussian prior and model case studied below, it feels right to choose the posterior to be Gaussian. More generally, preferring posteriors with continuous densities with respect to the Lebesgue measure is generally a parsimonious choice.

34.3

Conjugate Pairs, Conjugate Priors and the Exponential Family
One of the strengths of the Bayesian approach is the ability to incorporate explicitly specified prior beliefs. This is philosophically attractive and can be enormously beneficial when the user has well-grounded prior knowledge about the problem. When it comes to Bayesian algorithms, however, this advantage is belied a little by the competing necessity of choosing a prior for which the posterior can be efficiently computed or sampled from. The ease of computing (or sampling from) the posterior depends on the interplay between the prior and the model. Given the importance of computation, it is hardly surprising that researchers have worked hard to find models and priors that behave well together. A prior and model are called a conjugate pair if the posterior has the same

34.3 Conjugate Pairs, Conjugate Priors and the Exponential Family

425

parametric form as the prior. In this case, the prior is called a conjugate prior to the model.

Gaussian Model/Gaussian Prior Suppose that (, G) = (, F) = (R, B(R)) and X :    is the identity and P is Gaussian with mean  and known signal variance S2 . If the prior Q is Gaussian with mean µP and prior variance P2 , then the posterior distribution having observed X = x can be chosen to be

Q( · | x) = N

µP /P2 + x/S2 1/P2 + 1/S2

,

1 S2

+

1 P2

-1

.

The proof is left to the reader in Exercise 34.1.

Following convention, from now on we sweep under the rug that this posterior is one of many choices, which is justified because all posteriors must agree almost everywhere.

The limiting regimes as the prior/signal variance tend to zero or infinity are quite illuminating. For example, as P2  0 the posterior tends to a Gaussian N (µP , P2 ), which is equal to the prior and indicates that no learning occurs. This is consistent with intuition. If the prior variance is zero, then the statistician
is already certain of the mean, and no amount of data can change their belief. On the other hand, as P2 tends to infinity, we see the mean of the posterior has no dependence on the prior mean, which means that all prior knowledge is
washed away with just one sample. You should think about what happens when S2  {0, }.
Notice how the model has fixed S2 , suggesting that the model variance is known. The Bayesian can also incorporate their uncertainty over the variance. In this case, the model parameters are  = R × [0, ) and P = N (1, 2). But is there a conjugate prior in this case? Already things are getting complicated, so we
will simply let you know that the family of Gaussian-inverse-gamma distributions
is conjugate.

Bernoulli Model/Beta Prior Suppose that  = [0, 1] and P = B() is Bernoulli with parameter . In this case, it turns out that the family of beta distributions is conjugate, which for parameters  = (, )  (0, )2 is given in terms of its probability density function with respect to the Lebesgue measure:

p, (x)

=

x-1(1

-

x)-1

( + ) ()()

,

(34.3)

where (x) is the Gamma function. Then the posterior having observed X = x  {0, 1} is also a beta distribution with parameters ( + x,  + 1 - x). Unlike in

34.3 Conjugate Pairs, Conjugate Priors and the Exponential Family

426

the Gaussian case, the posterior for the Bernoulli model and beta prior is unique (Exercise 34.2).

34.3.1

Exponential Families

Both the Gaussian and Bernoulli families are examples of a more general family. Let h be a measure on (R, B(R)) and S,  : R  R be two `suitable' functions,
where S is called the sufficient statistic. Together, h,  and S define a measure P on (R, B(R)) for each     R in terms of its density with respect to h:

dP dh

(x)

=

exp

(()S(x)

-

A())

,

where A() = log exp(()S(x))dh(x) is the log-partition function and
R
 = dom(A) = { : A() < } is the domain of A. Integrating the density shows that for any B  B(R) and   ,

P(B) =

B

dP dh

(x)

dh(x)

=

exp (()S(x) - A()) dh(x) .
B

The collection (P :   ) is called a single-parameter exponential family. An exponential family is regular if  is non-empty and open. It is non-singular if A () > 0 for all   .

Example

34.3.

Let

2

>0

and

h = N (0, 2)

and

() =

 

and

S(x) =

x 

.

An

easy calculation shows that A() = 2/(22), which has domain  = R and

P = N (, 2).

Example 34.4. Let h = 0 + 1 be the sum of Dirac measures and S(x) = x and () = . Then A() = log(1 + exp()) and  = R and P = B(()), where
() = exp()/(1 + exp()) is the logistic function.

Example 34.5. The same family can be parameterised in many different ways. Let h = 0 + 1, S(x) = x and () = log(/(1 - )). Then A() = - log(1 - ) and  = (0, 1) and P = B().

Exponential families have many nice properties, some of which you will prove
in Exercise 34.5. Of most interest to us here is the existence of conjugate priors.
Suppose that (P :   ) is a single-parameter exponential family determined by h,  and S, where S(x) = x is the identity map. Let x0, n0  R, and define prior measure Q on (, B()) in terms of its density q = dQ/d with  the Lebesgue
measure:

q() =



exp (n0x0() exp (n0x0()

- -

n0A()) n0A())

d

,

(34.4)

where we assume that the integral in the denominator exists and is positive. Suppose we observe X = x. Then a choice of posterior has density with respect

34.3 Conjugate Pairs, Conjugate Priors and the Exponential Family

427

to the Lebesgue measure given by

q( | x) =



exp (()(x + n0x0) - (1 + n0)A()) exp (()(x + n0x0) - (1 + n0)A()) d()

.

What this means is that after observing the value x, the posterior takes the form

of the prior except that the parameters (x0, n0) associated with the prior get updated to ((n0x0 + x)/(n0 + 1), n0 + 1). The posterior is both easy to represent and maintain. To see how exponential families recover previous examples, consider

the Bernoulli case of Example 34.5. Since

exp(n0x0() - n0A()) =

 1-

n0 x0
(1 - )n0 = n0x0 (1 - )n0(1-x0) ,

we see that the prior from (34.4) is a beta distribution with parameters  = 1 + n0x0 and  = 1 + n0(1 - x0), as can be seen from (34.3). As expected, the posterior update also works as described earlier.

There are important parametric families with conjugate priors that are not exponential families. One example is the uniform family (U(a, b) : a < b), which is conjugate to the Pareto family.

34.3.2

Sequences of Random Variables and the Markov Chain View
Let P n = (Pn :   ) be a probability kernel from (, G) to (X n, Hn) and Q a prior on (, G). Then, let  and X1, . . . , Xn be random elements on some probability space (, F, P), where    and Xt  X such that (a) the law of  is P = Q; and (b) P(X1, . . . , Xn  B | ) = P(B) almost surely for all B  Hn.
By definition, the posterior after observing (Xs)ts=1 is a probability kernel Qt from (X t, Ht) to (, G) such that for any B  G,
E[ I{  B} | X1, . . . , Xt] = Qt( B | X1, . . . , Xt) almost surely .
Then, by the tower rule, the conditional distribution of Xt+1 given (Xs)ts=1 almost surely satisfies
P (Xt+1  B | X1, . . . , Xt) = P(Xt+1  B | X1, . . . , Xt)Qt(d | X1, . . . , Xt) .

(34.5)
This identity says that the conditional distribution of Xt+1 can be written in terms of the model and posterior. In the fundamental setting where Pn = P  · · ·  P is a product probability measure, then Eq. (34.5) reduces to
P (Xt+1  B | X1, . . . , Xt) = P(B)Qt(d | X1, . . . , Xt) ,


34.4 The Bayesian Bandit Environment

428

which shows that in this case the posterior summarises all the useful information in (Xs)st=1 for predicting future data. By introducing a little measure-theoretic machinery and making suitable regularity assumptions, it is possible to show that
the sequence Q1, . . . , Qn is a time-inhomogeneous Markov chain. In many cases, the posterior has a simple form, as you can see in the next two examples.

Example 34.6. Suppose  = [0, 1] and G = B([0, 1]) and Q = Beta(, )

and P = B() is Bernoulli. Then the posterior after t observations is Qt =

Beta(+St, +t-St), where St =

t s=1

Xs.

Furthermore,

E[Xt+1

|

X1,

.

.

.

,

Xt]

=

EQt [Xt+1] = ( + St)/( +  + t), and hence

P (St+1

=

St

+

1 | St)

=

 + St ++

t

,

P (St+1

=

St

| St)

=

 + t - St ++t

.

So the posterior after t observations is a Beta distribution depending on St and S1, S2, . . . , Sn follows a Markov chain evolving according to the above display.

Example 34.7. Let (, G) = (R, B(R)) and Q = N (µ, 2) and P = N (, 1). Then, using the same notation as above the posterior is almost surely Qt = N (µt, t2), where

µt

=

µ/2 + St 1/2 + t

and

t2 =

1 2

+

t

-1
.

Then S1, S2, . . . , Sn is a Markov chain with the conditional distribution of St+1 given St a Gaussian with mean St + µt and variance 1 + t2.

34.4

The Bayesian Bandit Environment
The Bayesian bandit model is the same as the frequentist version introduced in Chapter 4, except that at the beginning of the game, an environment is sampled from the prior. Of course, the chosen environment is not revealed to the learner, but its presence forces us to change our conditions on the rewards because the rewards are dependent on each other through the chosen environment. For simplicity, we treat only the finite, k-armed case, but the more general set-up is handled in the same was as in Chapter 4.
A k-armed Bayesian bandit environment is a tuple (E, G, Q, P ), where (E, G) is a measurable space and Q is a probability measure on (E, G) called the prior. The last element P = (Pi :   E, i  [k]) is a probability kernel from E × [k] to (R, B(R)), where Pi is the reward distribution associated with the ith arm in bandit . A Bayesian bandit environment and policy  = (t)nt=1 interact to produce a collection of random variables,   E, (At)tn=1 and (Xt)tn=1 with At  [k] and Xt  R that satisfy
(a) P (  ·) = Q(·);

34.5 Posterior Distributions in Bandits

429

(b) the conditional distribution of action At given , A1, X1, . . . , At-1, Xt-1 is t(· | A1, X1, . . . , At-1, Xt-1) almost surely; and
(c) the conditional distribution of the reward Xt given , A1, X1, . . . , At is PAt almost surely.
The existence of a probability space carrying random elements satisfying these conditions is guaranteed by the Ionescu­Tulcea theorem (Theorem 3.3, Exercise 34.9). The corresponding probability measure will be denoted by PQP .
Most of the structure of a Bayesian bandit environment is in P , which determines the reward distribution for each arm i in bandits   E.

Example 34.8. A k-armed Bayesian Bernoulli bandit environment could be defined by letting E = [0, 1]k, G = B(E) and Pi = B(i). A natural prior in this
case would be a product of Beta(, ) distributions:

k

Q(A) =

qi(xi)dx ,

A i=1

where qi(x) = x-1(1 - x)-1( + )/(()()).

34.5

Posterior Distributions in Bandits

Let (E, G, Q, P ) be a k-armed Bayesian bandit environment. Assuming that (E, G) is a Borel space, Theorem 34.1 guarantees the existence of the posterior: a probability kernel Q( · | ·) from the space of histories to (E, G) so that

Q(A | a1, x1, . . . , at, xt)

is a regular version of E[IA() | A1, X1, . . . , At, Xt]. For explicit calculations, it is worth adding some some extra structure: assume there exists a -finite measure  on (R, B(R)) such that Pi  for all i  [k] and   E. Recall from Chapter 15 that the Radon­Nikodym derivative of P with respect to ( × )n is

n
p(a1, x1, . . . , an, xn) = t(at | a1, x1, . . . , at-1xt-1)pat (xt) ,
t=1

(34.6)

where pa is the density of Pa with respect to . Then the posterior after t rounds is given by

Q(B | a1, x1, . . . , at, xt) = =

B p(a1, x1, . . . , at, xt)dQ()

E p(a1, x1, . . . , at, xt)dQ()

B E

t s=1

pas

(xs

)dQ(

)

t s=1

pas

(xs

)dQ(

)

,

(34.7)

34.6 Bayesian Regret

430

where the second equality follows from Eq. (34.6). The posterior is not defined when the denominator is zero, which only occurs with probability zero (Exercise 34.11). Note that the Radon­Nikodym derivatives pa(x) are only unique up to sets of Pa-measure zero, and so the `choice' of posterior has been converted to a choice of the Radon­Nikodym derivatives, which, in all practical situations is straightforward. Observe also that Eq. (34.7) is only well defined if pas (·) is G-measurable as a function of . Fortunately this is always possible (see Note 8).

Example 34.9. The posterior for the Bayesian bandit in Example 34.8 in terms of its density with respect to the Lebesgue measure is

k

q( | a1, x1, . . . , at, xt) 

i+si(ht)-1(1 - i)+ti(ht)-si(ht)-1 ,

ht

i=1

where si(ht) =

t u=1

xuI

{au

=

i}

and

ti(ht)

=

t u=1

I

{au

=

i}.

This

means

the

posterior is also the product of Beta distributions, each updated according to the

observations from the relevant arm.

34.6

Bayesian Regret

Recall that the regret of policy  in k-armed bandit environment  over n rounds is

n

Rn(, ) = nµ - E

Xt ,

t=1

(34.8)

where µ = maxi[k] µi and µi is the mean of Pi. Given a k-armed Bayesian bandit environment (E, G, Q, P ) and a policy , the Bayesian regret is

BRn(, Q) = Rn(, )dQ() .
E
The dependence on E, G and P is omitted on the grounds that these are always self-evident from the context. The Bayesian optimal regret is BRn (Q) = inf BRn(, Q), and the optimal (regret-minimizing) policy is

 = argmin BRn(, Q) .

(34.9)

Note that the regret-minimising policy is the same as the reward-maximising

policy  = argmax EPQP [

n t=1

Xt],

which

is

known

as

the

Bayesian

optimal

policy under prior Q. In all generality, there is no guarantee that the (Bayes)

optimal policy exists, but the non-negativity of the Bayesian regret ensures that for any  > 0, there exists a policy  with BRn(, Q)  BRn (Q) + .

34.7 Notes

431

The fact that the expected regret Rn(, ) is non-negative for all  and  means that the Bayesian regret is always non-negative. Perhaps less obviously, the Bayesian regret of the Bayesian optimal policy can be strictly greater than zero (Exercise 34.8).

34.7

Notes
1 In Chapter 4, we defined the environment class E as a set of tuples of probability distributions over the reals. In a Bayesian bandit environment (E, G, Q, P ) the set E is arbitrary and the reward distributions are given by the probability kernel P . The probability kernel and the change of notation is needed because we are now integrating the regret over E, which may not be measurable without additional conditions.
2 The Bayesian regret of an algorithm is less informative than the frequentist regret. By this we mean that a bound on BRn(, Q) does not generally imply a meaningful bound on Rn(, ), while if Rn(, )  f () for a measurable function f , then BRn(, Q)  E[f ()]. This is not an argument against using a Bayesian algorithm but rather an argument for the need to analyse the frequentist regret of Bayesian algorithms.
3 The relationship between admissibility, Bayesian optimality and minimax optimality is one of the main topics of statistical decision theory, which intersects heavily with game theory. In many classical statistical settings, all Bayesian optimal policies are admissible (Exercise 34.14), and all admissible policies are either Bayesian optimal for some prior or the limit point of a sequence of Bayesian optimal policies (Exercise 34.13). Be warned, however, that there are counterexamples. A nice book with many examples is by Berger [1985]. In Exercise 34.15, you will prove that all admissible policies for stochastic Bernoulli bandits are Bayesian optimal for some prior.
4 While admissibility and related notions of optimality are helpful in being clear about the goals of algorithm design, we must recognise that these concepts are too binary for most purposes. One problem with the classic decision theory literature is that it puts too much emphasis on these narrow concepts. Who would argue that a policy that is dominated, but just barely, is worth nothing? Especially since the optimal policy is often intractable. Meaningful ways of defining slightly worse usually consider a bigger picture when a policy design approach (policy schema) is evaluated across many problem classes. In the Bayesian setting, one may for example consider all k-armed stochastic Bayesian bandits with (say) bounded rewards and consider policy schema that work no matter what the environment is. An example of a policy schema is Thompson sampling, since it can be instantiated for any of the environments. One may ask whether such a policy schema is near Bayesian (or minimax) optimal across

34.7 Notes

432

all of the considered environments. In fact, most bandit algorithm design is

better viewed as designing policy schema.

5 Many algorithms/statistical methods have Bayesian interpretations. One

example is ridge regression, which we saw in Chapter 20. Using the notation

of that chapter, the estimator given in Eq. (20.1) is the mean of the Bayesian

posterior when the model is Gaussian with known variance and the prior on the

unknown parameter is a Gaussian with zero mean and covariance I/. Another

example is the exponential weighting algorithm for prediction with expert

advice. Consider a sequence y1, . . . , yn  [d] and suppose there are set M of k experts making predictions about yt. We write µ(· | y1, . . . , yt-1)  Pd-1 for the distribution of yt predicted by expert µ  M. In each round the learner observes

the predictions µ(· | y1, . . . , yt-1) for all experts µ  M and should make

a prediction (· | y1, . . . , yt-1)  Pd-1. Notice that defining µ(y1, . . . , yn) =

n t=1

µ(yt

|

y1,

.

.

.

,

yt-1)

makes

µ(·)

into

a

probability

distribution

on

[d]n.

The

regret compares the learner's performance relative to the best expert in M

under the logarithmic loss:

n

Rn

=

max
µM

log

t=1

µ(yt | y1, . . . , yt-1) (yt | y1, . . . , yt-1)

= max log
µM

µ(y1, . . . , yn) (y1, . . . , yn)

.

A Bayesian approach to this problem is to assume that y1, . . . , yn is sampled from some unknown µ  M and choose a prior distribution Q  P(M) over the experts. Then predict to minimise the Bayesian expected loss, which you will show in Exercise 34.6 leads to

predictive dist. of µ

( · | y1, . . . , yt-1) =

µ( · | y1, . . . , yt-1)

µM

µ(y1, . . . , yt-1)Q(µ) M (y1, . . . , yt-1)Q()

.

posterior Qt-1(µ)

(34.10)

You will also show that when Q is taken to be the uniform distribution, the regret is bounded by Rn  log(k) for all sequences y1, . . . , yn. Simple algebraic manipulations show that the posterior is

Qt(µ) =

exp - M exp

t s=1

log

1 µ(ys | y1,...,ys-1)

-

t s=1

log

1 (ys | y1,...,ys-1)

,

which is precisely the exponential weights distribution with learning rate  = 1. The analogy should not be taken too seriously, however. That this algorithm controls the regret for all sequences y1, . . . , yn does not hold for more general loss functions. For this, the learning rate must be chosen much more conservatively. For more on the online learning approach to learning under the logarithmic loss, see chapter 9 of the book by Cesa-Bianchi and Lugosi [2006]. The Bayesian approach is covered in the book by Hutter [2004]. 6 Sion's minimax theorem provides a connection between minimax optimal regret and the maximum Bayesian optimal regret over all priors. Let  be the space

34.7 Notes

433

of all policies and P be a convex space of probability measures over policies and Q be a convex space of probability measures on (E, G). Define L : P × Q  R by

L(S, Q) =

Rn(, )Q(d)S(d) ,

E

which is linear in both arguments because integrals are linear as a function of

the measure. Suppose that L is continuous in both arguments and at least one

of P and Q is compact. Then, by Sion's minimax theorem (Theorem 28.12),

sup inf L(S, Q) = inf sup L(S, Q) .

QQ SP

SP QQ

Usually P and Q include all Dirac measures:

(34.11)

{ :   D}  P and { :   E}  Q ,

where D is the space of deterministic policies. Then the left-hand side of Eq. (34.11) is supQQ BRn (Q), and the right-hand side is the minimax regret Rn (E). Choosing P, Q and a measurable structure on  is not always easy. Examples may be found in Exercises 34.16 and 36.11.

7 The issue of conditioning on measure zero sets has been described in many

places. We do not know of a practical situation where things go awry. Sensible

choices yield sensible posteriors. The curious reader could probably burn a few

weeks reading through the literature on the Borel­Kolmogorov paradox

[Jaynes, 2003, §15.7].

8 Suppose that (P :   ) is a probability kernel from (, G) to (R, B(R)) for which there exists measure  on (R, B(R)) such that P  for all   . Then there exists a family of densities p : R  [0, ) such that p(x) is jointly

measurable as a (, x)  p(x) map and p = dP/d for all   . See the

proof of Lemma 1.2 in Ghosal and van der Vaart [2017] or sections 1.3 and 1.4

of the book by Strasser [2011].

9 The notion of a sufficient statistic is more general than its role in exponential

families. Let X and Y be random elements on the same measurable space

taking values in X and Y respectively. The random element Y is a sufficient

statistic for X given a family of distributions (P) over the probability space

carrying both X and Y if (i) Y is (X)-measurable and (ii) for all   , the

conditional distribution P(X  · |Y ) is independent of the value of . Formally,

(ii) means there exists a probability kernel P from Y to X such that for any

  , P(X  · |Y ) = P (Y, · ) holds P-almost surely. Informally, this means, that given Y , there is no information left about  in X. Denoting by PX, the distribution of X under P and without loss of generality letting Y = y(X)

for some y : X  Y measurable map (recall Lemma 2.5), and assuming that

X, Y take values in Borel spaces, with the help of the disintegration theorem

(Theorem 3.12), it is not hard to see that if (PX,) have a common dominating

-finite

measure

µ

and

for

any





,

dPX, dµ

(x)

=

h(x)g (y (x))

holds

µ-almost

surely for all x  X for some some h : X  [0, ) and g : Y  [0, ) Borel

34.8 Bibliographic Remarks

434

measurable maps, then Y is a sufficient statistic for X. The Fisher­Neyman factorisation theorem states that the converse also holds. With some creative matching of concepts, we can see that in single-parameter exponential families, what we called a sufficient statistic satisfies the more general definition.

34.8

Bibliographic Remarks

The original essay by Thomas Bayes is remarkably

readable [Bayes, 1763]. There are many texts on

Bayesian statistics. For an introduction to the applied

side, there is the book by Gelman et al. [2014]. This

book offers lots of discussions and examples. A more

philosophical book that takes a foundational look

at probability theory from a Bayesian perspective

is by Jaynes [2003]. The careful definition of the

posterior can be found in several places, but the

recent book by Ghosal and van der Vaart [2017]

does an impeccable job. A worthy mention goes

Thomas Bayes

to the article by Chang and Pollard [1997], which

uses disintegration (Theorem 3.12) to formalise the `private calculations' that

probabilists so frequently make before writing everything carefully using Radon­

Nikodym derivatives and regular versions. Theorem 34.1 is a specification of the

theorem guaranteeing the existence of regular conditional probability measures

(Theorem 3.11). For a detailed presentation of exponential families, see the book

by Lehmann and Casella [2006]. A compendium of conjugate priors is by Fink

[1997].

34.9

Exercises
34.1 (Posterior calculations) Evaluate the posteriors for each pair of conjugate priors in Section 34.3.
34.2 (Uniqueness of beta/Bernoulli posterior) Explain why the posterior for the Bernoulli model with a beta prior is unique.
34.3 Use the tower rule to prove the identity in Eq. (34.5).
34.4 (Posterior in terms of density) Let P = (P :   ) be a probability kernel from (, G) to (X , H) and Q be a probability measure on  and P = Q  P on  × X . As usual, let  and X be the coordinate projections on  × X . Let  and µ be probability measures on (, G) and (X , H) such that Q  and

34.9 Exercises

435

P µ for all   , and define

q( | x) =

p (x)q ()

,

 p(x)q()d()

where p(x) = dP/dµ and q() = dQ/d. You may assume that p(x) is jointly measurable in  and x (see Note 8).

(a) Let N = {x :  p(x)q()d() = 0} and show that PX (N ) = 0. (b) Define Q(A | x) = A q( | x)d() for x / N and Q(A | x) be an arbitrary
fixed probability measure for x  N . Show that Q( · | X) is a regular version of P (  · | X).

Hint The `sections' lemma may prove useful (Lemma 1.26 in Kallenberg 2002), along with the properties of the Radon­Nikodym derivative.

34.5 (Exponential families) Let A, T , h,  and  be as in Section 34.3.1.

(a) Prove that P is indeed a probability measure. (b) Let E denote expectations with respect to P. Show that A () = E[T ]. (c) Let    and X  P. Show that for all  with  +   ,
E[exp(T (X))] = exp(A( + ) - A()) .

(d) Given ,   , show that

d(,  ) = E log

p (X ) p (X)

= A( ) - A() - ( - )A () . (34.12)

(e) Let ,    be such that A ( )  A () and X1, . . . , Xn be independent

and

identically

distributed

and

T^

=

1 n

n t=1

T (Xt).

Show

that

P T^  A ( )  exp (-nd( , )) .

Curiously, the function d of Eq. (34.12) is both the relative entropy D(P, P ) and the Bregman divergence between  and  induced by the convex function A. See Section 26.3 for the definition of Bregman divergence.

34.6 (Exponential weights algorithm) Consider the setting of Note 5.
(a) Prove the claim in Eq. (34.10). (b) Prove that when Q(µ) = 1/k is the uniform prior, then the regret is bounded
by Rn  log(k) for any y1, . . . , yn.
34.7 (Measurability of the regret) Let (E, G, Q, P ) be a Bayesian bandit environment and  a policy. Prove that Rn(, ), defined in Eq. (34.8), is Gmeasurable as a function of .
34.8 (Bayesian optimal regret can be positive) Construct an example

34.9 Exercises

436

demonstrating that for some priors over finite-armed stochastic bandits, the Bayesian regret is strictly positive: inf BRn(, Q) > 0.

Hint The key is to observe that under appropriate conditions, BRn(, Q) = 0 would mean that  needs to know the identity of the optimal action under  from round one, which is impossible when  is random and the model is rich enough.
34.9 (Canonical model) Prove the existence of a probability space carrying the random variables satisfying the conditions in Section 34.4.

34.10 (Sufficiency of deterministic policies) Let D be the set of all deterministic policies and  the space of all policies. Prove that for any k-armed Bayesian bandit environment (E, G, Q, P ),

inf


BRn(,

Q)

=

inf
D

BRn(,

Q)

.

34.11 Prove that the denominator in Eq. (34.7) is almost surely non-zero.

34.12 (Bayesian optimal policies can be dominated) Consider the set-up
in Example 34.2. A Bayesian learner observes X  P and should choose an action At  [0, 1] that is (X)-measurable. Their loss is I {At = }.

(a) Show that the optimal choice is At = Xt. (b) Give a Bayesian optimal algorithm with At = Xt on some non-empty
(measure zero) event.
(c) Give a Bayesian optimal algorithm and  such that the loss when  is true (and so X  P) is not zero.

34.13 (Admissible policies are Bayesian for finite environments) Let E = {1, . . . , N } and  be sets. Call the elements of E environments, and the elements of  policies (this is just to help to make connection to the rest of the material). Let :  × E  [0, ) be a positive loss function. Given a policy , let
() = ( (, 1), . . . , (, N )) be the loss vector resulting from policy . Define S = { () :   }  RN and

(S) = {x  cl(S) : y < x for all y  S} ,

where y < x is defined to mean it is not true that yi  xi for all i with strict inequality for at least one i ((S) is the Pareto frontier of set S, and its elements are the non-dominated loss-outcome vectors in cl(S)). Prove that if (S)  S and S is convex, then for every    such that ()  (S), there exists a prior q  P(E) such that

q() (, ) = min q() (, ) .

E

 E

Hint Use the supporting hyperplane theorem, stated in the hint after Exercise 26.2.

34.9 Exercises

437

By identifying elements of E as `criteria', the interpretation of the result of the exercise in multi-criteria optimisation is that for non-empty, convex, closed loss sets, solutions on the Pareto frontier (policies  such that ()  (S)) can be obtained by minimizing a convex combination of the individual criteria. There is also a connection to constrained optimisation where the constraints are expressed as a bounds on linear combinations of the losses.

34.14 (Uniquely Bayes optimal policies are admissible) Let (E, G) be a
measurable space and  an arbitrary set of the elements that we call policies. Let :  × E  R be a function with (, ·) being G-measurable. Given a probability
measure Q on (E, G), a policy is called Bayesian optimal with respect to Q if

(, )dQ() = inf ( , )dQ() .

E

  E

Prove the following:

(a) If  is the unique Bayesian optimal policy given prior Q, then  is admissible. (b) There is an example when  is a Bayesian optimal policy and  is inadmissible. (c) If E is countable and Supp(Q) = E, then any Bayes optimal policy  is
admissible. (d) If  is Bayesian optimal with respect to prior Q, then it is admissible on
Supp(Q)  E.

34.15 (Admissible policies are Bayesian for Bernoulli bandits) Let E be the set of k-armed Bernoulli bandits. Prove that every admissible policy is Bayesian optimal for some prior.

Hint Argue that all policies can be written as convex combinations of
deterministic policies using an appropriate linear structure. Then identify the spaces of environments and policies with compact metric spaces. Let (j)j=1 be a dense subset of E and repeat the argument in the previous exercise with each
finite subset {1, . . . , j}, and then take the limit as j  . You will probably find Theorem 2.14 useful.

34.16 Let E = EBk be the space of k-armed stochastic Bernoulli bandits. Endow E with a topology via the natural bijection to [0, 1]k, and let Q be the space of all probability measures on (E, B(E)) with the weak* topology. Prove that

max
QQ

BRn(Q)

=

Rn (E

)

.

Hint Use Theorem 2.14 and Sion's theorem (Theorem 28.12).

35 Bayesian Bandits

The first section of this chapter provides simple bounds on the Bayesian optimal regret, which are obtained by integrating the regret guarantees for frequentist algorithms studied in Part II. This is followed by a short interlude on the basic theory of optimal stopping, which we will need later. The next few sections are devoted to special cases where computing the Bayesian optimal policy is tractable. We start with the finite horizon Bayesian one-armed bandit problem where the existence of a tractable solution is reduced to the computation of a sequence of functions on the sufficient statistics of the arm with the unknown pay-off. Next, the k-armed setting is considered. The main question is whether there exists a solution that avoids considering joint sufficient statistics over all arms, which would be intractable in the lack of further structure (see Note 2). Avoiding the joint sufficient in general is not possible, but in the remarkable case of the problem of maximising the total expected discounted reward over an infinite horizon, where John C. Gittins's celebrated result shows that the Bayesian optimal policy takes the form of an `index' policy that keeps statistics for each arm separately (updated based on the arm's observations only) to compute a value (`index') for each arm, in each round choosing the arm with the highest index.

35.1

Bayesian Optimal Regret for k-Armed Stochastic Bandits

Even in relatively benign set-ups, the computation of the Bayesian optimal policy

appears hopelessly intractable. Nevertheless, one can investigate the value of the

Bayesian optimal regret by proving upper and lower bounds.

For simplicity, we restrict our attention to Bernoulli bandits, but the arguments

generalise to other models. Let (E, G) = ([0, 1]k, B([0, 1]k)), and for   [0, 1]k

let Pj = B(j). Choose some prior Q on (E, G). The Bayesian optimal regret is

necessarily smaller than the minimax regret, which by Theorem 9.1 means that

BRn (Q)



 C kn

,

where C > 0 is a universal constant. The proof of the lower bound in Exercise 15.2

shows that for each n, there exists a prior Q for which

BRn(Q)



 c kn

,

35.2 Optimal Stopping ( )

439

wsuhpeQreBRc n>(Q)0=is(akunni)v. ersal constant. These two together show that the Turning to the asymptotics for a fixed distribution, recall that that for any fixed

Bernoulli bandit environment, the asymptotic growth rate of regret is (log(n)).

In stark contrast to this, asymptotic growth rate of

the best BRn(Q)

we can say inthe is slower than n,

Bayesian case is that the but for some priors, n is

almost a lower bound on the growth rate. In particular, we ask you to prove the

following theorem in Exercise 35.1:

Theorem 35.1. For any prior Q,

lim sup
n

BRn (Q) n1/2

=

0.

Furthermore, there exists a prior Q such that for all  > 0,

lim inf
n

BRn(Q) n1/2-

=

.

The lower bound has a worst-case flavour in the sense it holds for a specific prior. The prior that yields the lower bound is a little unnatural because it assigns the overwhelming majority of its mass to bandits with small suboptimality gaps. In particular, Q({  E : min()  })  c/ log(1/) for some constant c > 0. For more regular priors, the Bayesian optimal regret satisfies BRn (Q) = (log2(n)). See the bibliographic remarks for pointers to the literature.

35.2

Optimal Stopping ( )

We now make a detour to show some results of optimal stopping, which will be
used in the next sections to find tractable solutions to certain Bayesian bandit
problems.
The first setting we consider will be useful for the one-armed bandit problem. Let (Ut)tn=1 be a sequence of random variables adapted to filtration F = (Ft)nt=1. Optimal stopping is concerned with finding solutions to optimisation problems of
the following form:

sup E[U ] ,
 Rn1

(35.1)

where Rn1 is the set of F-stopping times  with 1    n. When n is finite, the situation is conceptually straightforward. The idea is to use backwards

induction to define the expected optimal utility conditioned on the information

in Ft starting from t = n and working backwards to t = 1. The Snell envelope is a sequence of random variables (Et)nt=1 defined by

Et =

Un , max {Ut, E[Et+1 | Ft]} ,

if t = n ; otherwise .

35.2 Optimal Stopping ( )

440

Intuitively, Et is the optimal expected value one can guarantee provided that stage t was reached.

Theorem 35.2. Assume that n is finite and Ut is integrable for all t  [n]. Then the stopping time  = min{t  [n] : Ut = Et}  Rn1 achieves the supremum in Eq. (35.1).

Backwards induction is not directly applicable when the horizon is infinite. There are several standard ways around this problem. For our purposes, the most convenient workaround is to introduce a Markov structure. The connection to the Bayesian bandit setting is that in the Bayesian setting, posteriors follow a Markov process. The connection will be made explicit in a few examples in later sections.
Let (S, G) be a Borel space and (Px : x  S) be a probability kernel from S to itself and u : S  R be S/B(R)-measurable. A Markov reward process is a Markov chain (St) t=1 evolving according to P and a sequence of random variables (Ut)t=1 with Ut = u(St). Define the filtration F = (Ft) t=1 with Ft = (S1, . . . , St). The (Markov) optimal stopping problem is

sup E[U ] ,
 R1
where R1 is the set of F-adapted stopping times, and the initial distribution of S1 is arbitrary. Inspired by the solution of the finite horizon problem define the value function v : S  R by

v(x) = sup Ex[U ] ,
 R1

(35.2)

where Px is the probability measure on the space carrying (St) t=1 for which Px(S1 = x) = 1 and Ex be the expectation with respect to Px. As before, the idea is to stop when Ut is above S v(y)PSt (dy), the predicted optimal value of continuing. Note that ties can be resolved in any way (depending on St, one may
or may not stop when the predicted optimal value of continuation is equal to Ut).
The next result gives sufficient conditions under which stopping rules of this form

are indeed optimal.

Theorem 35.3. Assume for all x  S that U = limn Un exists Px-a.s. and supn1 |Un| is Px-integrable. Then v satisfies the Wald­Bellman equation,

v(x) = max{u(x), v(y)Px(dy)}
S

for all x  S .

Furthermore, limn v(Sn) = U Px-a.s., and the supremum in Eq. (35.2) is

achieved by any stopping time  such that for all t,

(a)   t on the event that Ut > S v(y)PSt (dy); and (b)  > t on the event that Ut < S v(y)PSt (dy) and   t.
The conditions are satisfied in many practical applications, e.g. if the Markov chain is ergodic and the utility function is bounded over the state space. In

35.3 One-armed Bayesian Bandits

441

our application, Un will be an accumulation of discounted rewards, which in all standard situations converges very fast.
A natural choice of stopping time satisfying conditions (a) and (b) in Theorem 35.3 is  = min{t  1 : v(St) = Ut}. The conditions express that in the indifference region {x  S : u(x) = S v(y)Px(dy)}, both stopping and continuing are acceptable.
The proof of Theorem 35.2 is straightforward (Exercise 35.2). Measurability issues make the proof of Theorem 35.3 more technical (Exercise 35.3). Pointers to the literature are given in the notes, and a solution to the exercise is available.

35.3

One-armed bandits

The one-armed Bayesian bandit problem is a special

case where the Bayesian optimal policy has a simple

form that can often be computed efficiently. Before

reading on, you might like to refresh your memory

by looking at Exercises 4.10 and 8.2. Let (E, G, Q, P )

be a two-armed Bayesian bandit environment, where

P2 = µ2 is a Dirac at fixed constant µ2  R for all   E. Because the mean of the second arm is

known in advance, we call this a one-armed Bayesian

£34.5

bandit problem. In Part (a) of Exercise 4.10, you

showed that when the horizon is known, retirement

policies that choose the first arm until some random Figure 35.1 When will you

time before switching to the second arm until the stop playing? A one-armed end of the game (pointwise over ) dominate all Bayesian bandit.

other policies in terms of regret. Since we care about

Bayesian optimal policies, the result of Exercise 34.10 allows us to restrict our

attention to deterministic retirement policies.

These facts allow us to frame the Bayesian one-armed bandit problem in

terms of optimal stopping. Define a probability space (, F, P) carrying random

elements   E and Z = (Zt)tn=1 where

(a) the law of  is P = Q; and (b) P(Z  · | ) = Pn1(·), which means that after conditioning on , the sequence
(Zt)nt=1 is independent and identically distributed according to P1.

Given a deterministic retirement policy  = (t)tn=1, define the random variable

 = min{t  1 : t(2 | 1, Z1, . . . , 1, Zt-1) = 1} ,

where the minimum of an empty set in this case is n+1. Clearly  is an F-stopping

35.3 One-armed Bayesian Bandits

442

time, where F = (Ft)tn=+11 with Ft = (Z1, . . . , Zt-1). In fact, this correspondence between deterministic retirement policies and F-stopping times is a bijection. The Bayesian expected reward when following the policy associated with stopping
time  is

 -1

n

E

Zt + µ2 = E [U ] ,

t=1

t=

where Ut =

t-1 s=1

Zs

+

(n

-

t

+

1)µ2.

Since

minimizing

the

Bayesian

regret

is

equivalent to maximising the Bayesian expected cumulative reward, the problem

of finding the Bayesian optimal policy has been reduced to an optimal stopping

problem.

Proposition 35.4. If Z1 is integrable, then the Bayesian regret is minimised by the retirement policy associated with stopping time  = min{t  1 : Ut = Et}, where

Et =

Ut , max{Ut, E[Et+1 | Ft]} ,

if t = n + 1 ; otherwise .

The interpretation of Et is that it is the total expected optimal value

conditioned on the information available at the start of round t. The proposition

is an immediate corollary of Theorem 35.2 and the fact that integrability of

Z1 is equivalent to integrability of (Ut)tn=+11. The optimal stopping time in

Proposition 35.4 can be rewritten in a more convenient form. For 1  t  n + 1,

define Wt = Et -

t-1 s=1

Zs,

which

can

be

seen

as

the

optimal

value

to

go

for

the

last n - t + 1 rounds. The definition of Et shows that Wn+1 = 0 and for t  n,

t-1
Wt = max (n - t + 1)µ2, E[Et+1 | Ft] - Zs
s=1
= max ((n - t + 1)µ2, E [Zt + Wt+1 | Ft]) .

(35.3)

Hence the optimal stopping time can be rewritten as   = min{t : Ut = Et} = min {t : Wt = (n - t + 1)µ2} .

This should make intuitive sense. It is optimal to continue only if the expected
future reward from doing so is at least as large as what can be obtained by stopping immediately. The difficulty is that E[Zt + Wt+1 | Ft] can be quite a complicated object. We now give two examples where E[Zt + Wt+1 | Ft] has a simple representation and thus computing the optimal stopping rule becomes practical. The idea is to find a sequence of sufficient statistics (St)tn=0 so that St  S is Ft-measurable and P1(Z1, . . . , Zt  · | St) is independent of . Then Et is (St)-measurable, and by Lemma 2.5 it follows that Et = vt(St) for an appropriately measurable function vt : S  R. For more on this, read the next two subsections, and then do Exercise 35.4.

35.3 One-armed Bayesian Bandits

443

35.3.1

Bernoulli Rewards

Let E = [0, 1], G = B([0, 1]) and for   E, let P1 = B() and P2 = µ2 : the first arm is Bernoulli, and the second is a Dirac at some fixed value µ2  [0, 1]. For the prior, choose Q = Beta(, ), a Beta prior. By the argument in Example 34.6 the

posterior at the start of round t is a Beta distribution Beta( + St,  + t - 1 - St)

where St =

t-1 s=1

Zs.

Letting

pt(s)

=

(

+

s)/(

+



+

t

-

1),

it

follows

that

E[Zt | Ft]

=



 + St ++t-1

=

pt(St) ,

P (St+1 = St + 1 | St) = pt(St) ,

P (St+1 = St | St) = 1 - pt(St) .

Now let wn+1(s) = 0 for all s and

wt(s) = max {(n - t + 1)µ2, pt(s) + pt(s)wt+1(s + 1) + (1 - pt(s))wt+1(s)} .

Then Wt = wt(St), and hence the optimal policy can be computed by evaluating wt(s) for all s  {0, . . . , t} starting with t = n, then n - 1 and so on until t = 1. The total computation for this backwards induction is O(n2), and the output is a policy that can be implemented over all n rounds. By contrast, the typical frequentist stopping rule requires only O(n) computations, so the overhead is quite severe. The improvement in terms of the Bayes regret is not insignificant, however, as illustrated by the following experiment.

Experiment 35.1 The horizon is set to n = 500 and µ2 = 1/2. The stopping rules we compare are the Bayesian optimal policy with a Beta(1, 1) prior and the `frequentist' stopping rule given by

 = min

t



2

:

µ^t-1

<

µ2

and

d(µ^t-1, µ2)



log(n/t) t-1

,

(35.4)

where d(p, q) is the binary relative entropy and µ^t =

t s=1

Xs/t

is

the

empirical

estimate of µ1 based on the first t observations. Fig. 35.2 shows the expected regret

for different values of µ, with horizontal dotted lines indicating the expected regret

averaged over the prior. Note that although the prior is symmetric, the one-armed

bandit problem is not, which explicates the asymmetric behaviour of the Bayesian

optimal algorithm. The frequentist algorithm is even more asymmetric with very

small regret for µ1 > 1/2, but large regret for µ1 < 1/2. This is caused by a

conservative confidence interval in Eq. (35.4), which makes it stop consistently

later than its Bayesian counterpart, which makes it `win' for µ1 > 1/2, but it also

makes it `lose' when µ1 < 1/2, with an overall loss (naturally) when considering the average over all environments.

35.3.2

Gaussian Rewards Let (E, G) = (R, B(R)), where for   R, we let P1 = N (, 1) and P2 = µ2 for µ2  R fixed. Choose a Gaussian prior Q = N (µP , P2 ) with mean µP  R

35.3 One-armed Bayesian Bandits

444

Bayesian optimal

8

Frequentist

6

Expected regret

4

2

0

0.2

0.4

0.6

0.8

µ1

Figure 35.2 The plot shows the expected regret for the Bayesian optimal algorithm compared to the `frequestist' algorithm in Eq. (35.4) on the Bernoulli 1-armed bandit where µ2 = 1/2 and µ1 varies on the x-axis. The horizontal lines show the average regret for each algorithm with respect to the prior, which is uniform.

and variance P2 > 0. By the results in Section 34.3, the posterior Q(· | x1, . . . , xt)
after observing rewards x1, . . . , xt from the first arm is almost surely Gaussian with mean µt and variance t2 given by

µt =

µP P2

+

t s=1

xs

1 + P-2

and

t2 =

t

+

1 P2

-1
.

(35.5)

The posterior variance is independent of the observations, so the posterior is

determined entirely by its mean. As in the Bernoulli case, there exist functions (wt)tn=+11 such that Wt = wt(µt-1) almost surely for all t  [n]. Precisely, wn+1(µ) = 0 and for t  n,

wt(µ) = max

(n

-

t

+

1)µ2,

µ

+

1 2


exp
-

-

x2 2t2-1

wt+1(µ + x)dx . (35.6)

The integral on the right-hand side does not have a closed-form solution, which forces the use of approximate methods. Fortunately wt is a well-behaved function and can be efficiently approximated. The favourable properties are summarised in the next lemma, the proof of which is left to Exercise 35.5.

Lemma 35.5. The following hold:

(a) The function wt is increasing. (b) The function wt is convex. (c) limµ wt(µ)/µ = n - t + 1 and limµ- wt(µ) = (n - t + 1)µ2.

There are many ways to approximate a function, but in order to propagate the approximation using Eq. (35.6), it is convenient to choose a form for which the integral in Eq. (35.6) can be computed analytically. Given the properties in

35.4 Gittins Index

445

Lemma 35.5, a natural choice is to approximate wt using piecewise quadratic functions. Let w~n+1(µ) = 0 and

w¯t(µ) = max

(n

-

t

+

1)µ2,

µ

+

1 2


exp
-

-

x2 2t2

w~t+1(µ + x)dx

.

Then let - < x1  x2  . . .  xN < , and for µ  [xi, xi+1], define w~t(µ) = aiµ2 + biµ + ci to be the unique quadratic approximation of w¯t(µ) such
that

w~t(xi) = w¯t(xi) ,
w~t(xi+1) = w¯t(xi+1) ,
w~t((xi + xi+1)/2) = w¯t((xi + xi+1)/2) .
For µ < x1, we approximate wt(µ) = (n - t + 1)µ2, and for µ > xN , the linear approximation w~t(µ) = (n-t+1)µ is reasonable by Lemma 35.5. The computation time for calculating the coefficients ai, bi, ci for all t and i  [N ] is O(N n). We encourage the reader to implement this algorithm and compare it to its natural frequentist competitors (Exercise 35.11).

35.4

Gittins Index
Generalising the analysis in the previous section to multiple actions is mathematically straightforward, but computationally intractable. The computational complexity of backwards induction increases exponentially with the number of arms, which is impractical unless the number of arms and horizon are both small.
An index policy is a policy that in each round computes a real-valued index for each arm and plays the arm with the largest index, while the index of an arm is restricted to depend on statistics collected for that arm only (the time horizon can also be used). Many policies we met earlier are index policies. For example, most variants of the upper confidence bound algorithm introduced in Part II are index policies. Sadly, however, the Bayesian optimal policy for finite horizon bandits is not usually an index policy (see Note 6). John C. Gittins proved that if one is prepared to modify the objective to a special kind of infinite horizon problem, then the Bayesian optimal policy becomes an index policy. In the remainder of this chapter, we explore his ideas.

35.4.1

A Discounted Retirement Game
We start by describing the discounted setting with one action and then generalise to multiple actions. Besides discounting, another change is that the rewardgenerating process is made into a Markov reward process, a strict generalisation of the previous case. The motivation is that, as hinted on before, the posterior of the arm with the unknown payoff evolves as a Markov process.

35.4 Gittins Index

446

Let (St) t=1 be a Markov chain on Borel space (S, G) evolving according to probability kernel (Px : x  S). As in Section 35.2, let (, F , Px) be a probability space carrying (Sn) n=1 with Sn  S such that

(a) Px(S1 = x) = 1; and (b) Px(Sn+1  · | Sn) = PSn (·) with Px-probability one.

Expectations with respect to Px are denoted by Ex. Next, let   R and r : S  R be a G/B(R)-measurable function, both of which are known to the learner. In each round t = 1, 2, . . ., the learner observes the state St and chooses one of two
options: (a) to retire and end the game or (b) pay the fixed cost  to receive
a reward of r(St) and continue for another round. The policy of a learner in this game corresponds to choosing a F-stopping time  with F = (Ft)t and Ft = (S1, . . . , St), where  = t means that the learner retires after observing St at the start of round t. The -discounted value of the game when starting in
state S1 = x is

 -1

v(x) = sup Ex

t-1(r(St) - ) ,

 1

t=1

(35.7)

where   (0, 1) is the discount factor. To ensure that this is well defined, we need the following assumption:



Assumption 35.6. For all x  S, it holds that Ex

t-1|r(St)| < .

t=1

If the rewards are bounded, the assumption will hold. When the rewards are unbounded, the assumption restricts the rate of growth of rewards over time.
The presence of discounting encourages the learner to obtain large rewards earlier rather than later and is one distinction between this model and the finitehorizon model studied for most of this book. A brief discussion of discounting is left for the notes.
Fix a state x  S. The map   v(x) is decreasing and is always non-negative. In fact, if  is large enough, it is easy to see that retiring immediately ( = 1) achieves the supremum in the definition of v(x), and thus v(x) = 0. The Gittins index, or fair charge, of a state x is the smallest value of  for which the learner is indifferent between retiring immediately and playing for at least one round:

g(x) = inf {  R : v(x) = 0} .

(35.8)

Straightforward manipulation (Exercise 35.6) shows that

Ex g(x) = sup

 -1 t=1

t-1r(St

)

.

 2 Ex

 -1 t=1

t-1

(35.9)

The form in (35.9) will be useful for computation. It is not immediately clear that

35.4 Gittins Index

447

a stopping time attaining the supremum in (35.9) exists. The following lemma shows that it does and gives an explicit form.
Lemma 35.7. Let x  S be arbitrary. The following hold under Assumption 35.6:
(a) v(x) = max{0, r(x) -  +  S v(y)Px(dy)} for all   R. (b) If   g(x), then v(x) = r(x) -  +  S v(y)Px(dy). (c) The stopping time  = min{t  2 : g(St)  } attains the supremum in
Eq. (35.9).
The result is relatively intuitive. The Gittins index represents the price the learner should be willing to pay for the privilege of continuing to play. The optimal policy continues to play as long as the actual value of the game is not smaller than this price was at the start. The proof of Lemma 35.7 uses Theorem 35.3 and is left for the reader in Exercise 35.7.

35.4.2

Discounted Bandits and the Index Theorem
The generalisation of the discounted retirement game to multiple arms is quite straightforward. As we will see, this will lead to a solution to the infinite horizon discounted Bayesian k-armed bandit problem where the prior factorises over the arms.
There are now k independent Markov chains sharing the same state space S. We are also given a reward function r : S  R. In each round t, the learner first observes the state of all chains S1(t), . . . , Sk(t) and then chooses an action At  [k] to receive a reward r(SAt (t)) and to make the state of the chain underlying arm k move according to a fixed transition kernel that is common to all chains. The states of the other chains do not move. The goal is still to maximise the total expected discounted reward. The interaction protocol is illustrated on Fig. 35.3.

The assumption that the Markov chains evolve on the same state space with the same transition kernel is non-restrictive since the state space can always be taken to be the union of k state spaces and the transition kernel defined with k disconnected components.

Because the learner observes the state of all chains in each round, a policy  now is a collection (t) t=1, where t is a probability kernel from (Sk × [k])t-1 × Sk (history, including past observed states and actions) to [k]. Given a discount
rate   (0, 1), the objective is to find the policy maximising the cumulative
discounted reward:



argmax E

t-1r(SAt (t)) ,

t=1

where the expectation is taken with respect to the distribution on state/action sequences induced by the interaction of  and the k Markov chains.

35.4 Gittins Index

448

t = 1 and initialise S1(1), . . . , Sk(1)

Observe states S1(t), . . . , Sk(t)

Choose action At  [k] Receive reward r(SAt (t))

Increment t
Update Si(t + 1) = Si(t) for i = At, and SAt (t + 1)  PSAt (t)(·)

Figure 35.3 Interaction protocol for discounted bandits with Markov pay-offs

Example 35.8 (Bayesian k-armed Bernoulli bandits in the Markov framework).

To see the relation to Bayesian bandits with discounted rewards, consider the

following set-up. Let S = [0, ) × [0, ) and G = B(S). Then let the initial state

of each Markov chain be Si(1) = (1, 1), and define probability kernel (Ps : s  S) from (S, G) to itself by

P(x,y)(A)

=

x

x +

y IA((x

+

1, y))

+

x

y +

y IA((x, y

+

1)) .

The reward function is r(x, y) = x/(x + y). The reader should check that this corresponds to a Bernoulli bandit with Beta(1, 1) prior on the mean reward of each arm (Exercise 35.8). The role of the state space is to maintain a sufficient statistic for the posterior while the reward function is the expected reward given the posterior.

Returning to the general problem, let g be the Gittins index function as defined
in Eq. (35.8) associated with the probability kernel (Px : x  S) and reward function r. A policy  that chooses in round t the arm At  argmaxi[k] g(Si(t)) is called a Gittins index policy. One of the most celebrated theorems in the
study of bandits is that these policies are Bayesian optimal.

Theorem 35.9. Let  be a policy choosing in round t At = argmaxi g(Si(t)) with ties broken arbitrarily. Then, provided Assumption 35.6 holds for all Markov chains (Siu)u=1, then





E

t-1r(SAt (t)) = sup E

t-1r(SAt (t)) ,

t=1



t=1

where the supremum is taken over all policies.

The remainder of the section is devoted to proving Theorem 35.9. The choice of actions produces an interleaving of the rewards generated by each Markov chain, and it will be useful to have a notation for these interleavings. For each

35.4 Gittins Index

449

i  [k], let gi = (git)t=1 be a real-valued sequence and g = (g1, . . . , gk) be the tuple of these sequences.
While this notation breaks our convention of putting the time index first in the reward sequences of a multi-armed bandit, we prefer this notation here as we need to consider reward sequences underlying individual arms.

Given an infinite sequence (at) t=1, taking values in [k], define the interleaving sequence I(g, a) = (It(g, a)) t=1 by

It(g, a) = gat,1+nat (a,t-1)

with

t-1
ni(a, t - 1) = I {as = i} .
s=1

Note that this is the same as the `reward-stack model' of bandits mentioned on page 65 in Chapter 4 except that here we have fixed sequences. The next lemma follows from the Hardy­Littlewood inequality, a generalisation of the trivial observation that the identical ordering of two sequences of numbers maximises their inner product. We leave the proof to Exercise 35.9.

Lemma 35.10. Suppose that gi is decreasing for all i  [k] and (at) t=1 is defined recursively by at = argmaxi gi,1+ni(a,t-1) and I(g) = I(g, a). Then, for any   (0, 1),





t-1It(g) = sup

t-1It(g, a) .

t=1

a[k]N t=1

Proof of Theorem 35.9 Given a policy  = (t)t=1, let (, F , P) be a probability space carrying random elements S1, . . . , Sk, where Si = (Siu) u=1 is a sequence of states and (At) t=1 is a sequence of actions such that

(a) P(Si,u+1  · | Si1, Si2, . . . , Siu) = PSiu (·); (b) The sequences (Siu) u=1 and (Sju) u=1 are independent for all i = j; and (c) P(At  · | S(1), A1, . . . , At-1, S(t)) = t(· | S(1), A1, . . . , At-1, S(t)), where

Si(t) = Si,(1+Ti(t-1)) is the state of machine i observed by the learner at the

start of round t with Ti(t) =

t s=1

I

{As

=

i}.

Let Ft = (S(1), A1, S(2), . . . , At-1, S(t), At) be the -algebra containing information available to the learner after choosing their action in round t. As usual, E denotes the expectation with respect to P.
Given an arm i and round t, the prevailing charge is a random variable
Gi(t) = minst g(Si(s)). The name comes from one of the early proofs of Gittins theorem that constructed a game in which the prevailing charge was the fee paid
by the learner to play arm i in round t. The proof is decomposed into two steps.
In the first step, we relate the prevailing charge to the discounted cumulative
reward. The second step completes the proof by combining the first with an
interleaving argument using Lemma 35.10.

35.4 Gittins Index

450

Part 1: The Prevailing Charge Fix an arm i. We claim that





E

t-1r(Si(t))I {At = i}  E

t-1Gi(t)I {At = i} .

t=1

t=1

Furthermore, equality holds for  = . To prove this claim, let 1, 2, . . . be a sequence of stopping times defined recursively by

1 = min{t  1 : At = i} and j+1 = min{t > j : At = i and g(Si(t))  Gi(j)} ,
where the minimum of the empty set is defined to be infinite. Next, let

Tj = {t : At = i and j  t < j+1} and j = Gi(j) .

Note that on the event {j < }, Gi(t) = j for all t  Tj. Furthermore,

g(Si(j)) = j. By definition, we have









E

t-1 (r(Si(t)) - Gi(t)) I {At = i} = E  t-1(r(Si(t)) - j) .

t=1

j=1

tTj

The claim follows by showing the term inside the sum on the right-hand side
vanishes for the Gittins index policy and is not positive for any other policy. Fix j  1. By definition, for t  Tj it holds that gi(Si(t))  Gi(t) = j.
Combining this with Part (b) of Lemma 35.7, on {t  Tj}, thanks to {t  Tj}  Ft,

vj (Si(t)) + j - r(Si(t)) =  vj (y)PSi(t)(dy) = E[vj (Si(t + 1)) | Ft] .
S

From this it follows that









E  t-1(r(Si(t)) - j ) = E  t-1 vj (Si(t)) - vj (Si(t + 1)) 

tTj

tTj

 0,

where the final inequality holds since vj is non-negative, vj (Si(j)) = 0 and by telescoping the sum, which is possible because whenever t is the smallest element

larger than t in Tj, then Si(t ) = Si(t + 1). We now argue that the inequality

is replaced by an equality for the Gittins index policy. The key observation

is that having played Aj = i, the Gittins index policy continues playing arm i until g(Si(t))  j, which means that Tj = {j, j + 1, . . . , j - 1}, where

j = min{t > j : g(Si(t))  j}, which by Part (c) of Lemma 35.7 means that





E  t-1(r(Si(t)) - j ) | Fj  = vj (Si(j )) = 0 .
tTj

35.5 Computing the Gittins Index

451

Part 2: Interleaving Prevailing Charges
Let Hiu = minvu g(Siv). The key point is that the distribution of H = (Hiu) does not depend on the choice of policy, and clearly Hiu is decreasing in u for each i. For the Gittins index policy ,





E

t-1r(SAt (t)) = E

t-1GAt (t)

t=1

t=1



= E

t-1It(H, A)

t=1



= E

t-1It(H) ,

t=1

where the first equality follows from part 1, the second by the definition of It and H and the third by the definitions of It from Lemma 35.10 and that of the Gittins index policy, which always chooses an action that maximises the
prevailing charge. On the other hand, for any policy ,





E

t-1r(SAt (t))  E

t-1GAt (t)

t=1

t=1

n

= E

t-1It(H, A)

t=1

n

 E

t-1It(H) ,

t=1

where the last line follows from Lemma 35.10. Finally, note that the law of H under P does not depend on , and hence

n

n

E

t-1It(H) = E

t-1It(H) .

t=1

t=1

Therefore, for all ,





E

t-1r(SAt (t))  E

t-1r(SAt (t)) ,

t=1

t=1

which completes the proof.

35.5

Computing the Gittins Index
We describe a simple approach that depends on the state space being finite. References to more general methods are given in the bibliographic remarks. Assume without loss of generality that S = {1, 2, . . . , |S|} and G = 2S . The matrix form of the transition kernel is P  [0, 1]|S|×|S| and is defined by Pij = Pi({j}). We also let r  [0, 1]|S| be the vector of rewards so that ri = r(i). The standard

35.6 Notes

452

basis vector is ei  R|S|, and 1  R|S| is the vector with one in every coordinate. For C  S, let QC be the transition matrix with (QC )ij = PijIC (j). For each i  S, the goal is to find

Ei g(i) = sup

 -1 t=1

t-1r(St

)

,

 2 Ei

 -1 t=1

t-1

where Ei is the expectation with respect to the measure Pi for which the initial state is S1 = i. Lemma 35.7 shows that the stopping time  = min{t  2 : g(St)  g(i)} attains the supremum in the above display. The set Ci = {j : g(j) > g(i)} is called the continuation region, and Si = S \ Ci is the stopping region. Then
the Gittins index can be calculated as

Ei g(i) =

 -1 t=1

t-1

r(St)

=

Ei

 -1 t=1

t-1

 t=1

t-1

ei

 t=1

t-1ei

QtC-i 1r QCt-i 11

=

ei ei

(I (I

- QCi )-1r - QCi )-11

.

All this suggests an induction approach where the Gittins index is calculated for each state in decreasing order of their indices. To get started, note that the maximum possible Gittins index is maxi ri and that this is achievable for state i = argmaxj rj with the deterministic stopping time  = 2. For the induction step, assume that g(i) is known for the j states C = {i1, i2, . . . , ij} with the largest Gittins indices. Then ij+1 is given by

ij+1

=

argmaxi/C

ei ei

(I (I

- QC )-1r - QC )-11

.

If Gauss­Jordan elimination is used for matrix inversion, then the computational complexity of this algorithm is O(|S|4). A more sophisticated inversion algorithm would reduce the complexity to O(|S|3+) for some   0.373, but these are
seldom practical. When  is relatively small, the inversion can be replaced by
directly calculating the sums to some truncated horizon with little loss in accuracy.

35.6

Notes
1 Bayesian methods automatically and optimally exploit the assumptions encoded in their prior. If we think of the prior as a way of enriching and refining the standard formulation of bandits, this is an advantage. However, this blessing can also be a curse. A policy that exploits its assumptions too heavily can be brittle when those assumptions turn out to be wrong. This can have a devastating effect in bandits where the cost of overly aggressive confidence intervals is large.
2 We claimed that computing the Bayesian optimal policy is generally intractable without discounting. This is a widely held belief, but we are not aware of any lower-bound on the computation complexity. A good place to start might be

35.6 Notes

453

to lower bound the computation complexity of finding the optimal action for k-armed Bayesian bandits when the prior is a product of Beta distributions, but without discounting. 3 The solution to optimal stopping problems is essentially a form of dynamic programming, which is a method that trades memory for computation by introducing recursively defined value functions that suffice for reconstructing an optimal policy. In the one-armed bandit optimal stopping problem, thanks to the factorisation lemma (Lemma 2.5), for any 0  t  n, there exists a function wt : Rt  R such that Wt = wt(X1, . . . , Xt) almost surely. This function can be seen as the value function that captures the optimal value-to-go from stage t on, and (35.3) gives a recursive construction for it, wn(x1, . . . , xn) = 0, and for t < n,
wt(x1, . . . , xt) = max((n - t)µ2, xt+1 + wt+1(x1, . . . , xt, xt+1)dPt(xt+1)) ,
where Pt is the distribution of Xt+1 given X1, . . . , Xt. The problem with this general recursion is that the computation is prohibitive. The example with Bernoulli rewards shows that sometimes a similar recursion holds on a reduced `state space' that avoids the combinatorial explosion that typically arises. For Gaussian rewards, even the reduced `state space' was uncountably large, and a piecewise quadratic approximation was suggested. When this kind of approximation is used, we get an instance of approximate dynamic programming. 4 Discounted bandits with Markov pay-offs (Fig. 35.3) are a special case of discounted Markov decision processes on which there is a large literature. More details are in the bibliographic remarks in Chapter 38. 5 Economists have long recognised the role of time in the utility people place on rewards. Most people view a promise of pizza (freshly made) a year from today as less valuable than the same pizza tomorrow. Discounting rewards is one way to model this kind of preference. The formal model is credited to renowned American economist Paul Samuelson [1937], who, according to Frederick et al. [2002], had serious reservations about both the normative and descriptive value of the model. While discounting is not very common in the frequentist bandit literature, it appears often in reinforcement learning, where it offers certain technical advantages [Sutton and Barto, 1998]. 6 Theorem 35.9 only holds for geometric discounting. If t-1 is replaced by (t), where (·) is not an exponential, then one can construct Markov chains for which the optimal policy is not an index policy. The intuition behind this result is that when (t) is not an exponential function, then the Gittins index of an arm can change even in rounds you play a different arm, and this breaks the interleaving argument [Berry and Fristedt, 1985, chapter 6]. The Gittins index theorem is brittle in other ways. For example, it no longer holds in the multiple-play setting, where the learner can choose multiple arms in each round [Pandelis and Teneketzis, 1999].

35.7 Bibliographical Remarks

454

7 The previous note does not apply to one-armed bandits for which the interleaving argument is not required. Given a Markov chain (St)t and horizon n, the undiscounted Gittins index of state s is

Es gn(s) = sup
2 n

 -1 t=1

r(St)

Es[ - 1]

.

If the learner receives reward µ2 by retiring, then the Bayesian optimal policy is to retire in the first round t when gn-t+1(St)  µ2. A reasonable strategy for undiscounted k-armed bandits is to play the arm At that maximises gn-t+1(Si(t)). Although this strategy is not Bayesian optimal anymore, it nevertheless performs well in practice. In the Gaussian case, it even enjoys frequentist regret guarantees similar to UCB [Lattimore, 2016c].
8 The form of the undiscounted Gittins index was analysed asymptotically by Burnetas and Katehakis [1997b], who showed the index behaves like the upper confidence bound provided by KL-UCB. This should not be especially surprising and explains the performance of the algorithm in the previous note. The asymptotic nature of the result does not make it suitable for proving regret guarantees, however.
9 We mentioned that computing the Bayesian optimal policy in finite horizon bandits is computationally intractable. But this is not quite true if n is small. For example, when n = 50 and k = 5, the dynamic program for computing the exact Bayesian optimal policy for Bernoulli noise and Beta prior has approximately 1011 states. A big number to be sure, but not so large that the table cannot be stored on disk. And this is without any serious effort to exploit symmetries. For mission-critical applications with small horizon, the benefits of exact optimality might make the computation worth the hassle.
10 The algorithm in Section 35.5 for computing Gittins index is called Varaiya's algorithm. In the bibliographic remarks, we give some pointers on where to look for more sophisticated methods. The assumption that |S| is finite is less severe than it may appear. When the discount rate is not too close to one, then for many problems the Gittins index can be approximated by removing states that are not reachable from the start state before the discounting means they becomes close to irrelevant. When the state space is infinite, there is often a topological structure that makes a discretisation possible.

35.7

Bibliographical Remarks
The classic text on optimal stopping is by Robbins et al. [1971], while a more modern text is by Peskir and Shiryaev [2006], which includes a proof of Theorem 35.2 (see theorem 1.2). With a little extra work, you can also extract the proof of Theorem 35.3 from section 1.2 of that book. We are not aware of a reference for Theorem 35.1, but Lai [1987] has shown that for sufficiently

35.8 Exercises

455

regular priors and noise models, the asymptotic Bayesian optimal regret is BRn  c log(n)2 for some constant c > 0 that depends on the prior/model (see theorem 3 of Lai [1987]). The Bayesian approach dominated research on bandits from 1960 to 1980, with Gittins's result (Theorem 35.9) receiving the most attention [Gittins, 1979]. Gittins et al. [2011] has written a whole book on Bayesian bandits. Another book that focusses mostly on the Bayesian problem is by Berry and Fristedt [1985]. Although it is now more than 30 years old, this book is still a worthwhile read and presents many curious and unintuitive results about exact Bayesian policies. The book by Presman and Sonin [1990] also considers the Bayesian case. As compared to the other books, here the emphasis is on a case that is more similar to partial monitoring, the subject of Chapter 37 (in the adversarial setting). As far as we know, the earliest fully Bayesian analysis is by Bradt et al. [1956], who studied the finite horizon Bayesian one-armed bandit problem, essentially writing down the optimal policy using backwards induction, as presented here in Section 35.3. More general `approximation results' are shown by Burnetas and Katehakis [2003], who show that under weak assumptions the Bayesian optimal strategy for one-armed bandits is asymptotically approximated by a retirement policy reminiscent of Eq. (35.4). The very specific approach to approximating the Bayesian strategy for Gaussian one-armed bandits is by one of the authors [Lattimore, 2016a], where a precise approximation for this special case is also given. There are at least four proofs of Gittins's theorem [Gittins, 1979, Whittle, 1980, Weber, 1992, Tsitsiklis, 1994]. All are summarised in the review by Frostig and Weiss [1999]. There is a line of work on computing and/or approximating the Gittins index, which we cannot do justice to. The approach presented here for finite state spaces is due to Varaiya et al. [1985], but more sophisticated algorithms exist with better guarantees. A nice survey is by Chakravorty and Mahajan [2014], but see also the articles by Chen and Katehakis [1986], Kallenberg [1986], Sonin [2008], Nin~o-Mora [2011] and Chakravorty and Mahajan [2013]. There is also a line of work on approximations of the Gittins index, most of which are based on approximating the discrete time stopping problem with continuous time and applying free boundary methods [Yao, 2006, and references therein]. The Gittins index has been generalised to continuous time, where the challenge is to ensure the existence of solutions to the resulting stochastic differential equations [Karoui and Karatzas, 1994]. We mentioned restless bandits in Chapter 31 on non-stationary bandits, but they are usually studied in the Bayesian context [Whittle, 1988, Weber and Weiss, 1990]. The difference is that now the Markov chains for all actions evolve regardless of the action chosen, but the learner only gets to observe the new state for the action they chose.

35.8

Exercises
35.1 (Bounding the Bayesian optimal regret) Prove Theorem 35.1.

35.8 Exercises

456

Hint For the first part, you should use the existence of a policy for Bernoulli bandits such that

Rn(, )  C min

 kn,

k log(n) min ( )

,

where C > 0 is a universal constant and min() is the smallest positive suboptimality gap. Then let En be a set of bandits for which there exists a small enough positive suboptimality gap and integrate the above bound on En and Enc. The second part is left as a challenge, though the solution is available.
35.2 (Finite horizon optimal stopping) Prove Theorem 35.2.
Hint Prove that (Et)tn=1 is a F-adapted supermartingale and that for stopping time  satisfying the conditions of the theorem that (Mt)tn=1 defined by Mt = Et is a martingale. Then apply the optional stopping theorem (Theorem 3.8).
35.3 (Infinite horizon optimal stopping) Prove Theorem 35.3.

Hint This is a technical exercise. Use theorem 1.7 of Peskir and Shiryaev [2006], and pass to the limit using the almost-sure convergence of (Ut)t as t  . You may find the ideas in the proof of theorem 1.11 of the same book useful. Be careful, Peskir and Shiryaev adopt the convention that stopping times are almost surely finite, while here we permit infinite stopping times.
35.4 This exercise uses the notation and setting of Section 35.3. Suppose that (St)nt=0 is a sequence of random elements taking values in measurable space (S, H) and with St being Ft/H-measurable and P1(Z1, . . . , Zt  · | St) is independent of . Show that Et is (St)-measurable, and there exists a H/B(R))-measurable function vt : S  R such that Et = vt(St). You may assume that (E, G) is Borel.

35.5 Prove Lemma 35.5.

35.6 (Equivalence of Gittins definitions) Prove that the definitions of the Gittins index given in Eq. (35.8) and Eq. (35.9) are equivalent.

35.7 Prove Lemma 35.7.

Hint Find a way to apply Theorem 35.3.
35.8 Consider that the discounted bandit with Markov pay-offs described in Example 35.8. Show that there is a one-to-one correspondence  between the policies for this problem and the discounted Bayesian bandit with Beta(1, 1) on the mean reward of each arm such that the total expected discounted reward (value) is invariant under .

35.9 Prove Lemma 35.10.

Hint Use the Hardy­Littlewood inequality, which for infinite sequences states

35.8 Exercises

457

that for any real, increasing sequences (xn)n=1, (yn) n=1 and any bijection

 : N+  N+ it holds that

 n=1

xnyn



 n=1

xny(n)

.

35.10 (Correctness of Varaiya's algorithm) Prove the correctness of Varaiya's algorithm, as explained in Section 35.5.

35.11 In this exercise, you will implement some Bayesian (near-)optimal 1-armed bandit algorithms.
(a) Reproduce the experimental results in Experiment 1. (b) Implement an approximation of the optimal policy for one-armed Gaussian
bandits and compare its performance to the stopping rule  defined below for a variety of different choices of  > 0.

 = min t  2 : µ^t-1 +

2 max{0, log(n/t)} t-1



µ2

.

36 Thompson Sampling
"As all things come to an end, even this story, a day came at last when they were in sight of the country where Bilbo had been born and bred, where the shapes of the land and of the trees were as well known to him as his hands and toes." ­ Tolkien [1937].
Like Bilbo, as the end nears, we return to where it all began, to the first algorithm for bandits proposed by Thompson [1933]. The idea is a simple one. Before the game starts, the learner chooses a prior over a set of possible bandit environments. In each round, the learner samples an environment from the posterior and acts according to the optimal action in that environment. Thompson only gave empirical evidence (calculated by hand) and focused on Bernoulli bandits with two arms. Nowadays these limitations have been eliminated, and theoretical guarantees have been proven demonstrating the approach is often close to optimal in a wide range of settings. Perhaps more importantly, the resulting algorithms are often quite practical both in terms of computation and empirical performance. The idea of sampling from the posterior and playing the optimal action is called Thompson sampling, or posterior sampling.
The exploration in Thompson sampling comes from the randomisation. If the posterior is poorly concentrated, then the fluctuations in the samples are expected to be large and the policy will likely explore. On the other hand, as more data is collected, the posterior concentrates towards the true environment and the rate of exploration decreases. We focus our attention on finite-armed stochastic bandits and linear stochastic bandits, but Thompson sampling has been extended to all kinds of models, as explained in the bibliographic remarks.
Randomisation is crucial for adversarial bandit algorithms and can be useful in stochastic settings (see Chapters 23 and 32 for examples). We should be wary, however, that injecting noise into our algorithms might come at a cost in terms of variance. What is gained or lost by the randomisation in Thompson sampling is still not clear, but we leave this cautionary note as a suggestion to the reader to think about some of the costs and benefits.

36.1 Finite-Armed Bandits

459

36.1

Finite-Armed Bandits
Recalling the notation from Section 34.5, let k > 1 and (E, B(E), Q, P ) be a k-armed Bayesian bandit environment. The learner chooses actions (At)tn=1 and receives rewards (Xt)tn=1, and the posterior after t observations is a probability kernel Q( · | ·) from ([k] × R)t to (E, B(E)). Denote the mean of the ith arm in bandit   E by µi() = R xdPi(x). In round t, Thompson sampling samples a bandit environment t from the posterior of Q given A1, X1, . . . , At-1, Xt-1 and then chooses the arm with the largest mean (Algorithm 23). A more precise definition is that Thompson sampling is the policy  = (t)t=1 with
t(a | a1, x1, . . . , at-1, xt-1) = Q(Ba | a1, x1, . . . , at-1, xt-1) ,
where Ba = {  E : µa() = argmaxb µb()}  B(E), with ties in the argmax are resolved in an arbitrary, but systematic fashion.

1: Input Bayesian bandit environment (E, B(E), Q, P ) 2: for t = 1, 2, . . . , n do 3: Sample t  Q( · | A1, X1, . . . , At-1, Xt-1) 4: Choose At = argmaxi[k] µi(t) 5: end for
Algorithm 23: Thompson sampling.

Thompson sampling has been analysed in both the frequentist and the Bayesian settings. We start with the latter where the result requires almost no assumptions on the prior. In fact, after one small observation about Thompson sampling, the analysis is almost the same as that of UCB.
Theorem 36.1. Let (E, B(E), Q, P ) be a k-armed Bayesian bandit environment such that for all   E and i  [k], the distribution Pi is 1-subgaussian (after centering) with mean in [0, 1]. Then the policy  of Thompson sampling satisfies
BRn(, Q)  C kn log(n) ,
where C > 0 is a universal constant.
Proof Abbreviate µi = µi() and let A = argmaxi[k] µi be the optimal arm, which depends on  and is a random variable. When there are ties, we use the same tie-breaking rule as in the algorithm in the definition of A. For each t  [n] and i  [k], let

Ut(i) = clip[0,1] µ^i(t - 1) +

2 log(1/) 1  Ti(t - 1)

,

where µ^i(t - 1) is the empirical estimate of the reward of arm i after t - 1 rounds and we assume µ^i(t - 1) = 0 if Ti(t - 1) = 0. Let E be the event that for all

36.2 Frequentist Analysis

460

t  [n] and i  [k],

|µ^i(t - 1) - µi| <

2 log(1/) 1  Ti(t - 1)

.

In Exercise 36.2, we ask you to prove that P (Ec)  2nk. Let Ft = (A1, X1, . . . , At, Xt) be the -algebra generated by the interaction sequence by the end of round t. Note that Ut(i) is Ft-1-measurable. The Bayesian regret is

n

n

BRn = E

(µA - µAt ) = E

E [µA - µAt | Ft-1] .

t=1

t=1

The key insight (Exercise 36.3) is to notice that the definition of Thompson sampling implies the conditional distributions of A and At given Ft-1 are the
same:

P (A = · | Ft-1) = P (At = · | Ft-1) a.s.

(36.1)

Using the previous display,

E [µA - µAt | Ft-1] = E [µA - Ut(At) + Ut(At) - µAt | Ft-1] = E [µA - Ut(A) + Ut(At) - µAt | Ft-1] (Eq. (36.1)) = E [µA - Ut(A) | Ft-1] + E [Ut(At) - µAt | Ft-1] .

Using the tower rule for expectation shows that

n

n

BRn = E

(µA - Ut(A)) + (Ut(At) - µAt ) .

t=1

t=1

(36.2)

On the event Ec the terms inside the expectation are bounded by 2n, while on

the event E, the first sum is negative and the second is bounded by

n

nk

I {E} (Ut(At) - µAt ) = I {E}

I {At = i} (Ut(i) - µi)

t=1

t=1 i=1

kn



I {At = i}

i=1 t=1

8 log(1/) 1  Ti(t - 1)



k i=1

Ti (n) 0

k

=

32Ti(n) log(1/)  32nk log(1/) .

i=1

8

log(1/) s

ds

The proof is completed by choosing  = n-2 and the fact that P (Ec)  2nk.

36.2

Frequentist Analysis
Bounding the frequentist regret of Thompson sampling is more technical than the Bayesian regret. The trouble is the frequentist regret does not have an expectation with respect to the prior, which means that At is not conditionally distributed in

36.2 Frequentist Analysis

461

the same way as the optimal action (which is not random). Thompson sampling can be viewed as an instantiation of follow-the-perturbed-leader, which we already saw in action for adversarial combinatorial semi-bandits in Chapter 30. Here we work with the stochastic setting and consider the general form algorithm given in Algorithm 24.
1: Input Cumulative distribution functions F1(1), . . . , Fk(1) 2: for t = 1, . . . , n do 3: Sample i(t)  Fi(t) independently for each i 4: Choose At = argmaxi[k] i(t) 5: Observe Xt and update:
Fi(t + 1) = Fi(t) for i = At and FAt (t + 1) = Update(FAt (t), At, Xt)
6: end for
Algorithm 24: Follow-the-perturbed-leader
Thompson sampling is recovered by choosing F1(1), . . . , Fk(1) to be the cumulative distribution functions of the mean reward of each arm for a prior that is independent over the arms (a product prior). Then letting Update be the function that updates the posterior for the played arm. There are, however, many alternatives ways to configure this algorithm.
The core property that we use in the analysis of Algorithm 24 (to be presented soon) is that Fi(t + 1) = Fi(t) whenever At = i. When Update(·) is a Bayesian update this corresponds to choosing an independent prior on the distribution of each arm.

Let Fis be the cumulative distribution function used for arm i in all rounds t with Ti(t - 1) = s. This quantity is defined even if Ti(n) < s by using the reward-stack model from Section 4.6.

Theorem 36.2. Assume that arm 1 is optimal. Let i > 1 be an action and   R be arbitrary. Then the expected number of times Algorithm 24 plays action i is
bounded by

n-1
E[Ti(n)]  1 + E
s=0

1 G1s

-

1

where Gis = 1 - Fis(µ1 - ).

n-1

+E

I {Gis > 1/n} ,

s=0

(36.3)

In applications,  is normally chosen to be a small positive constant. In this case, the first sum in Eq. (36.3) measures the probability that the sample corresponding to the first arm is nearly optimistic and tends to be smaller when the variance of the perturbation is larger. The second sum measures the likelihood that the sample from arm i is close to µ1 and is small when the variance of the

36.2 Frequentist Analysis

462

perturbation is small. Balancing these two terms corresponds to optimising the exploration/exploitation trade-off.

Proof of Theorem 36.2 Let Ft = (A1, X1, . . . , At, Xt) and Ei(t) = {i(t)  µ1 - }. By definition,

P (1(t)  µ1 -  | Ft-1) = G1T1(t-1) a.s.

We start with a straightforward decomposition:

n

E[Ti(n)] = E

I {At = i}

t=1

n

n

=E

I {At = i, Ei(t)} + E

I {At = i, Eic(t)} .

t=1

t=1

(36.4)

In order to bound the first term, let At = argmaxi=1 i(t). Then

P (At = 1, Ei(t) | Ft-1)  P (At = i, Ei(t), 1(t)  µ1 -  | Ft-1)

= P (1(t)  µ1 -  | Ft-1) P (At = i, Ei(t) | Ft-1)



1

G1T1 (t-1) - G1T1(t-1)

P

(At

=

i, Ei(t) | Ft-1)

,

(36.5)

where in the first equality we used the fact that 1(t) is conditionally independent of At and Ei(t) given Ft-1. In the second inequality, we used the definition of G1s and the fact that

P (At = i, Ei(t) | Ft-1)  (1 - P (1(t) > µ1 -  | Ft-1))P (At = i, Ei(t) | Ft-1) ,

which is true since {At = i, Ei(t) occurs}  {At = i, Ei(t) occurs}  {1(t)  µ1 - }, and the two intersected events are conditionally independent given Ft-1.
Therefore using Eq. (36.5), we have

P (At = i, Ei(t) | Ft-1)  

1 G1T1 (t-1)

-1

1 G1T1 (t-1)

-1

P (At = 1, Ei(t) | Ft-1) P (At = 1 | Ft-1) .

Substituting this into the first term in Eq. (36.4) leads to

n

n

E

I {At = i, Ei(t) occurs}  E

t=1

t=1

1 G1T1 (t-1)

-1

P (At = 1 | Ft-1)

n
=E
t=1

1 G1T1 (t-1)

-

1

I {At = 1}

n-1
E
s=0

1 G1s

-

1

,

(36.6)

where in the last step we used the fact that T1(t - 1) = s is only possible for one

36.2 Frequentist Analysis

463

round where At = 1. Let T = {t  [n] : 1 - FiTi(t-1)(µ1 - ) > 1/n}. After some calculation (Exercise 36.5), we get

n

E

I {At = i, Eic(t) occurs}  E

I {At = i} + E

I {Eic(t)}

t=1

tT

t/T

E

n-1
I {1 - Fis(µ1 - ) > 1/n}
s=0

+E

1 n
t/T

n-1

E

I {Gis > 1/n} + 1 .

s=0

Putting together the pieces completes the proof.

By instantiating Algorithm 24 with different choices of perturbations, one can prove that Thompson sampling enjoys frequentist guarantees in a number of settings. The following theorem shows that Thompson sampling with an appropriate prior is asymptotically optimal for the set of Gaussian bandits. The reader is invited to prove this result by following the steps suggested in Exercise 36.6.

Theorem 36.3. Suppose that Fi(1) =  is the Dirac at infinity and let
Update(Fi(t), At, Xt) be the cumulative distribution function of the Gaussian N (µ^i(t), 1/t). Then the regret of Algorithm 24 on Gaussian bandit   ENk (1) satisfies

lim
n

Rn log(n)

=

i:i >0

2 i

.

Furthermore, there exists a universal constant C > 0 such that Rn  C nk log(n).

The choice of update and initial distributions in Theorem 36.3 correspond to Thompson sampling when the prior mean and variance are sent to infinity at appropriate rates. For this choice, a finite-time analysis is also possible (see the exercise).
Experiment 36.1 Empirically the algorithm described in Theorem 36.3 has a smaller expected regret than the version of UCB analysed in Chapter 7. Compared to more sophisticated algorithms, however, it has larger regret and larger variance. AdaUCB (which we briefly met in Section 9.3) and Thompson sampling were simulated on a two-armed Gaussian bandit with mean vector µ = (1/5, 0) and unit variance and a horizon of n = 2000. The expected regret as estimated over 100,000 independent runs was 23.8 for AdaUCB and 29.9 for Thompson sampling. The figure below shows that contribution of the second moment of R^n = i iTi(n) for each algorithm, which shows that Thompson sampling has a much larger variance than AdaUCB, despite its inferior expected regret.

36.3 Linear Bandits

464

Proportion × Regret2

300 Thompson sampling

300

AdaUCB

200

200

100

100

0 0 100 200 300 400
Regret

0 0 100 200 300 400
Regret

36.3

Linear Bandits

While the advantages of Thompson sampling in finite-armed bandits are relatively
limited, in the linear setting there is much to be gained, both in terms of computation and empirical performance. Let A  Rd and (E, B(E), Q, P ) be a Bayesian bandit environment where E  Rd and for   E and a  A, Pa is 1-subgaussian with mean , a . Let  : E  Rd be the identity map, which is a random vector on (E, B(E), Q).

1: Input Bayesian bandit environment (E, B(E), Q, P ) 2: for t  1, . . . , n do 3: Sample t from the posterior 4: Choose At = argmaxaA a, t 5: Observe Xt 6: end for
Algorithm 25: Thompson sampling for linear bandits.

The Bayesian regret is controlled using the techniques from the previous section in combination with the concentration analysis in Chapter 20. A frequentist analysis is also possible under slightly unsatisfying assumptions, which we discuss in the notes and bibliographic remarks.

Theorem 36.4. Assume that  2  S with Q-probability one and supaA a 2  L and supaA | a,  |  1 with Q-probability one. Then the Bayesian regret of Algorithm 25 is bounded by

BRn  2 + 2

2dn2 log

1

+

nS2L2 d

,

where  = 1 +

2 log(n) + d log

1

+

nS2L2 d

.

For fixed S and L, the upper bound obtained here is of order

36.3 Linear Bandits

465

O(d n log(n) log(n/d)), which matches the upper bound obtained for Lin-UCB in Corollary 19.3.

Proof We apply the same technique as used in the proof of Theorem 36.1. Define the upper confidence bound function Ut : A  R by

Ut(a) = a, ^t-1 +  a , Vt--11

where

Vt

=

1 S2

I

t
+ AsAs
s=1

.

By Theorem 20.5 and Eq. (20.9), P(exists t  n : ^t-1 -  Vt-1 > )  1/n. Let

Et be the event that ^t-1 - Vt-1  , E =

n t=1

Et

and

A

=

argmaxaA

a, 

.

Note that A is a random variable because  is random. Then

n

BRn = E

A - At, 

t=1

n

n

= E IEc

A - At,  + E IE

A - At, 

t=1

t=1

n
 2 + E IE A - At, 

t=1

n

2+E

IEt A - At,  .

t=1

(36.7)

Let Ft = (A1, X1, . . . , At, Xt) and let Et-1[·] = E[· | Ft-1]. As before, P (A = · | Ft-1) = P (At = · | Ft-1), and Ut(a), for any fixed a  A, is Ft-1measurable, and so Et-1(Ut(A)) = Et-1(Ut(At)). It follows that the second term in the above display is bounded by

Et-1 [IEt A - At,  ] = IEt Et-1 [ A,  - Ut(A) + Ut(At) - At,  ]  IEt Et-1 [Ut(At) - At,  ]

 IEt Et-1 At, ^t-1 -  +  At Vt-1

 IEt Et-1 At Vt-1 ^t-1 -  Vt +  At Vt-1

 2 At . Vt-1
Substituting this combined with IEt A - At,  Eq. (36.7), we get

 2 into the second term of

n

E

IEt A - At, 

t=1

n

 2E

(1  At ) Vt-1

t=1

n

2

n2E

(1 
t=1

At

) 2
Vt-1

(Cauchy-Schwarz)

2

2dn2E log

1

+

nS2L2 d

.

(Lemma 19.4)

36.4 Information Theoretic Analysis

466

Putting together the pieces shows that

BRn  2 + 2

2dn2 log

1

+

nS2L2 d

.

36.3.1

Computation

An implementation of Thompson sampling for linear bandits needs to sample t from the posterior and then find the optimal action for the sampled parameter:

At = argmaxaA a, t .

For some priors and noise models, sampling from the posterior is straightforward. The most notable case is when Q is a multivariate Gaussian and the noise is Gaussian with a known variance. More generally, there is a large literature devoted to numerical methods for sampling from posterior distributions. Having sampled t, finding At is a linear optimisation problem. By comparison, LinUCB needs to solve

At

=

argmaxaA

max
~C

a, ~

,

which for large or continuous action sets is often intractable.

36.4

Information Theoretic Analysis
We now examine a Bayesian version of the adversarial k-armed bandit. As we will see, the natural generalisation of Thompson sampling is still a reasonable algorithm. Recall that in the adversarial bandit model studied in Part III, the adversary secretly chooses a matrix x  [0, 1]n×k at the start of the game and the reward in round t is xtAt . In the Bayesian set-up, there is a prior probability measure Q on [0, 1]n×k with the Borel -algebra. At the start of the game, a reward matrix X is sampled from Q, but not revealed. The learner then chooses actions (At)tn=1 and the reward in round t is XtAt . Formally, let  = (t)nt=1 be a policy and X  [0, 1]n×k and (At)tn=1 be random elements on some probability space (, F, P) such that:
(a) the law of X is PX = Q; and (b) P(At  · | X, Ht-1) = t( · | Ht-1) with Ht = (A1, X1A1 , . . . , At, XtAt ).
The inclusion of X in the conditional expectation in Part (b) implies that
P(At  · | X, Ht-1) = P(At  · | Ht-1) ,
which means that At and X are conditionally independent given Ht-1. This is consistent with our definition of the model where X is sampled first from Q and

36.4 Information Theoretic Analysis

467

then At depends on X only through the history Ht-1. The optimal action is

A = argmaxa[k]

n t=1

Xta

with

ties

broken

arbitrarily.

The

Bayesian

regret

is

n

BRn = E

(XtA - XtAt ) .

t=1

Like in the previous sections, Thompson sampling is a policy  = (t)nt=1 that plays each action according to the conditional probability that it is optimal, which
means the following holds almost surely:

t( · | A1, X1A1 , . . . , At-1, Xt-1At-1 ) = P(A  · | A1, X1A1 , . . . , At-1, Xt-1At-1 ) .

The main result of this section is the following theorem:

Theorem 36.5. The Bayesian regret of Thompson sampling for Bayesian k-armed adversarial bandits satisfies

BRn  kn log(k)/2 .

The proof is done through a generic theorem that is powerful enough to analyse
a wide range of settings. For stating this result, we need some preparation. Let Ft = (A1, X1A1 , . . . , At, XtAt ) and Et[·] = E[· | Ft] and Pt(·) = P( · | Ft). Let t = XtA - XtAt denote the immediate regret of round t.
The promised generic theorem bounds the regret in terms of an `information
ratio' that depends on the ratio of the squared expected instantaneous regret
conditioned on the past and a Bregman divergence with respect to some convex
function F to be chosen later.

Theorem 36.6. Let F : Rk  R  {} be convex, and suppose there exists a constant   0 such that

Et-1[t]  Et-1 [DF (Pt(A = ·), Pt-1(A = ·))] a.s.

Then BRn  ndiamF (Pk-1).
Proof Let Mt = Pt(A = ·)  Pk-1. Using the directional derivative definition of the Bregman divergence combined with Fatou's lemma and convexity of F ,

Et-1[DF (Mt, Mt-1)] = Et-1 F (Mt) - F (Mt-1) - Mt-Mt-1 F (Mt-1)

= Et-1

lim inf
h0+

F

(Mt)

-

F

(Mt-1)

-

F

((1

-

h)Mt-1

+ hMt) h

-

F

(Mt-1)

 lim inf
h0+

Et-1

F

(Mt)

-

F

(Mt-1)

-

F

((1

-

h)Mt-1

+ hMt) h

-

F

(Mt-1)

=

Et-1

[F (Mt)]

-

F (Mt-1)

+

lim inf
h0+

F (Mt-1)

-

Et-1[F ((1 h

-

h)Mt-1

+

hMt)]



Et-1

[F (Mt)]

-

F (Mt-1)

+

lim inf
h0+

F (Mt-1)

-

F (Et-1[(1 h

-

h)Mt-1

+

hMt])

= Et-1 [F (Mt)] - F (Mt-1) ,

(36.8)

36.4 Information Theoretic Analysis

468

where the first inequality follows from Fatou's lemma and the second from the convexity of F . The last equality is because Et-1[Mt] = Mt-1. Hence,

n

n

BRn = E

t  E

t=1

t=1

Et-1[DF (Mt, Mt-1)]

n

 nE

Et-1[DF (Mt, Mt-1)]  ndiamF (Pk-1) ,

t=1

where the first inequality follows from the assumption in the theorem, the second by Cauchy­Schwarz, while the third follows by Eq. (36.8), telescoping and the definition of the diameter.

It remains to choose F and show that the condition of the previous result can

be met. As you might have guessed, a good choice is the unnormalised negentropy

potential F (p) =

k a=1

pa

log(pa)

-

pa.

Remember

that

in

this

case

the

resulting

Bregman divergence DF (p, q) is the relative entropy, D(p, q), between categorical

distributions parameterised by p and q, respectively.

Lemma 36.7. If Xti  [0, 1] almost surely for all t  [n] and i  [k] and At is chosen by Thompson sampling using any prior, then

Et-1[t] 

k 2

Et-1[D(Pt(A



·),

Pt-1(A



·))]

.

Proof Given a measure P, we write PX|Y ( · ) for P(X  · | Y ). In our application below, X is a random variable, and hence P(X  · | Y ) can be chosen to be a probability measure by Theorem 3.11. When Y is discrete, we write PX|Y =y(·) for P(X  · | Y = y). The result follows by chaining Pinsker's inequality and Cauchy­Schwarz:

k
Et-1[t] = Pt-1(At = a) (Et-1[Xta | A = a] - Et-1[Xta])

a=1

k
 Pt-1(At = a)
a=1

1 2

D(Pt-1,Xta|A=a,

Pt-1,Xta )



k 2

k
Pt-1(At
a=1

=

a)2

D(Pt-1,Xta|A=a, Pt-1,Xta )



k 2

k
Pt-1(At
a=1

=

a)

k b=1

Pt-1(A

=

a) D(Pt-1,Xta|A=b, Pt-1,Xta )

=

k 2

Et-1

[D(Pt(A



·),

Pt-1(A



·))]

,

where the final equality follows from Bayes' law and is left as an exercise.

36.5 Notes

469

Proof of Theorem 36.5 The result follows by combining Lemma 36.7, Theorem 36.6 and the fact that the diameter of the unnormalised negentropy potential is diamF (Pk-1) = log(k).
The reason for the name `information-theoretic' is that historically Theorem 36.6 was specified to the unnormalised negentropy when the expected Bregman divergence is called the information gain or mutual information. In this, sense Theorem 36.6 shows that the Bayesian regret is well controlled if Et-1[t] can be bounded in terms of the information gain about the optimal action, which seems rather natural. Other potentials can be useful, however, as you will show in Exercise 36.10.

36.5

Notes
1 There are several equivalent ways to view Thompson sampling in stationary stochastic multi-armed bandits: (a) select an arm according to the posterior probability that the arm is optimal, or (b) sample an environment from the posterior and play the optimal action in that environment. When the mean rewards for each arm are independent under the posterior, then also equivalent is (c) sample the mean reward for each arm and choose the arm with the largest mean (Exercise 36.1). The algorithms in this chapter are based on (b), but all are equivalent and simply correspond to sampling from different push-forward measures of the posterior. Historically it seems that Thompson [1933] had the form in (a) in mind, but there are reasons to remember the alternative views. Though we are not aware of an example, in some instances beyond finite-armed bandits, it might be more computationally efficient to sample from a push-forward of the posterior than the posterior itself. Furthermore, in more complicated situations like reinforcement learning, it may be desirable to `approximate' Thompson sampling, and approximating a sample from each of the above three choices may lead to different algorithms. It is also good to keep in mind that in the non-Bayesian setting there can be cheaper ways of inducing sufficient exploration than sampling from a posterior, especially in the context of structured bandit problems.
2 Thompson sampling is known to be asymptotically optimal in a variety of settings ­ most notably, when the noise model follows a single-parameter exponential family and the prior is chosen appropriately [Kaufmann et al., 2012b, Korda et al., 2013]. Unfortunately, Thompson sampling is not a silver bullet. The linear variant in Section 36.3 is not asymptotically optimal by the same argument we presented for optimism in Chapter 25. Characterising the conditions under which Thompson sampling is close to optimal remains an open challenge.

36.5 Notes

470

3 For the Gaussian noise model, it is known that Thompson sampling is not minimax optimal. Its worst-case regret is Rn = ( nk log(k)) [Agrawal and Goyal, 2013a].
4 An alternative to sampling from the posterior is to choose in each round the arm that maximises a Bayesian upper confidence bound, which is a quantile of the posterior. The resulting algorithm is called BayesUCB and has excellent empirical and theoretical guarantees [Kaufmann et al., 2012a, Kaufmann, 2018].
5 The prior has a significant effect on the performance of Thompson sampling. In classical Bayesian statistics, a poorly chosen prior is quickly washed away by data. This is not true in (stochastic, non-Bayesian) bandits because if the prior underestimates the quality of an arm, then Thompson sampling may never play that arm with high probability and no data is ever observed. We ask you to explore this situation in Exercise 36.16.
6 An instantiation of Thompson sampling for stochastic contextual linear bandits is known to enjoy near-optimal frequentist regret. In each round the algorithm samples t  N (^t-1, rVt--11), where r = (d) is a constant and

t
Vt = I + AsAs
s=1

t

and

^t = Vt-1

XsAs .

s=1

Then At = argmaxaAt t, a . This corresponds to assuming the noise is Gaussian with variance r and choosing prior Q = N (0, I). Provided the

risewRanrd=s arO~e(cdo3n/2ditino)n,awllyhi1c-hsuibsgwauosrssieant,htahne

frequentist regret of this LinUCB by a factor of

algorithm d. The

increased regret is caused by the choice of noise model, which assumes the

variance is r = (d) rather than r = 1. The reason to do this comes from the

analysis, which works by showing the algorithm is `optimistic' with reasonable

probability. Very recently, an example was constructed showing that the blowup

of the variance is necessary, though the example heavily relies on the contextual

nature of the problem with changing action sets [Hamidi and Bayati, 2020].

Empirically, r = 1 leads to superior performance on many instances.

7 The analysis in Section 36.4 can be generalised to structured settings such as linear bandits [Russo and Van Roy, 2016]. For linear bandits with an infinite action set, the entropy of the optimal action may be infinite. The analysis can be corrected in this case by discretising the action set and comparing to a near-optimal action. This leads to a trade-off between the fineness of the discretisation and its size, and when the trade-off is resolved in an optimal fashion, one obtains an upper bound of order O(d n log(1 + n/d)) on the Bayesian regret, slightly improving previous analysis. The reader is referred to the recent article by Dong and Van Roy [2018] for this analysis.

8 The information-theoretic ideas in Section 36.4 suggest that rather than sampling At from the posterior on A, one can sample At from the distribution

36.5 Notes

471

Pt given by

Pt = argminpPk-1

k a=1

k a=1

pa

(Et-1

[Xta

|

A

=

a]

-

Et-1

[Xta])

paEt-1 [DF (Pt-1(A = · | Xta), Pt-1(A =

·))]

.

When F is the unnormalised negentropy, the resulting policy is called

information-directed sampling. Bayesian regret analysis for this algorithm

follows along similar lines to what was presented in Section 36.4. See

Exercise 36.9 or the paper by Russo and Van Roy [2014a] for more details.

9 The proof of Theorem 36.6 only used the fact that Mt = Pt(A = ·) is a

martingale. The posterior is just one possible choice, but in some cases an

alternative martingale leads to improved bounds. 10 Replacing the unnormalised negentropy potential with F (p) = -2

k i=1

pi

leads to a bound of BRn  2nk for any prior for finite-armed bandits

[Lattimore and Szepesv´ari, 2019c]. You will prove this in Exercise 36.10.

The same potential also led to minimax bounds for adversarial bandits in

Exercise 28.15, which suggests there is some kind of connection. This was

explored by Zimmert and Lattimore [2019], who show that the same techniques

used to bound the dual norm `stability' terms in the analysis of mirror descent

also control the information ratio for a version of Thompson sampling.

11 Let E = [0, 1]n×k be the set of all adversarial bandits and  the set of all

randomised policies and Q be the set of all finitely supported distributions on

E, which means that Q  Q is a function Q : E  [0, 1] with Supp(Q) = {x :

Q(x) > 0} a finite set and xSupp(Q) Q(x) = 1. Given x  E and   , let Ex be the expectation with respect to the interaction between policy  and

environment x. Then,

n

Rn (E)

=

min


sup
xE

Ex

max
i[k]

(xti
t=1

-

xtAt )

Adversarial regret

n

=

sup
QQ

min


xSupp(Q)

Q(x)Ex

max
i[k]

(xti
t=1

-

xtAt )

(36.9)

Bayesian optimal regret

 nk log(k)/2 ,

where the second equality follows from Sion's minimax theorem (Exercise 36.11) and the inequality follows from Theorem 36.5. This bound is a factor of two better than what we gave in Theorem 11.2 and can be improved to 2nk using the argument from the previous note and Exercise 36.10. The approach has been used in more sophisticated settings, like the first near-optimal analysis for adversarial convex bandits [Bubeck et al., 2015a, Bubeck and Eldan, 2016] or partial monitoring [Lattimore and Szepesva´ri, 2019c]. As noted earlier, the main disadvantage is that the technique does not lead to algorithms for the adversarial setting.

36.6 Bibliographic Remarks

36.6 Bibliographic Remarks

472

Thompson sampling has the honor of being the first bandit algorithm and is named after its inventor [Thompson, 1933], who considered the Bernoulli case with two arms. Thompson provided no theoretical guarantees, but argued intuitively and gave hand-calculated empirical analysis. It would be wrong to say that Thompson sampling was entirely ignored for the next eight decades, but it was definitely not popular until recently, when a large number of authors independently rediscovered the article/algorithm [Graepel et al., 2010, Granmo, 2010, Ortega and Braun, 2010, Chapelle and Li, 2011, May et al., 2012]. The surge in interest was mostly empirical, but theoreticians followed soon with regret guarantees. For the frequentist analysis, we followed the proofs by Agrawal and Goyal [2012, 2013a], but the setting is slightly different. We presented results for the `realisable' case where the pay-off distributions are actually Gaussian, while Agrawal and Goyal use the same algorithm but prove bounds for rewards bounded in [0, 1]. Agrawal and Goyal [2013a] also analyse the Beta/Bernoulli variant of Thompson sampling, which for rewards in [0, 1] is asymptotically optimal in the same way as KL-UCB (see Chapter 10). This result was simultaneously obtained by Kaufmann et al. [2012b], who later showed that for appropriate priors, asymptotic optimality also holds for single-parameter exponential families [Korda et al., 2013]. For Gaussian bandits with unknown mean and variance, Thompson sampling is asymptotically optimal for some priors, but not others ­ even quite natural ones [Honda and Takemura, 2014]. The Bayesian analysis of Thompson sampling based on confidence intervals is due to Russo and Van Roy [2014b]. Recently the idea has been applied to a wide range of bandit settings [Kawale et al., 2015, Agrawal et al., 2017] and reinforcement learning [Osband et al., 2013, Gopalan and Mannor, 2015, Leike et al., 2016, Kim, 2017]. The BayesUCB algorithm is due to Kaufmann et al. [2012a], with improved analysis and results by Kaufmann [2018]. The frequentist analysis of Thompson sampling for linear bandits is by Agrawal and Goyal [2013b], with refined analysis by Abeille and Lazaric [2017a] and a spectral version by Koca´k et al. [2014]. A recent paper analyses the combinatorial semi-bandit setting [Wang and Chen, 2018]. The information-theoretic analysis is by Russo and Van Roy [2014a, 2016], while the generalising beyond the negentropy potential is by Lattimore and Szepesva´ri [2019c]. As we mentioned, these ideas have been applied to convex bandits [Bubeck et al., 2015a, Bubeck and Eldan, 2016] and also to partial monitoring [Lattimore and Szepesv´ari, 2019c]. There is a tutorial on Thompson sampling by Russo et al. [2018] that focuses mostly on applications and computational issues. We mentioned there are other ways to configure Algorithm 24, for example the recent article by Kveton et al. [2019].

36.7 Exercises

473

36.7

Exercises

36.1 (Equivalent views) Prove the claimed equivalences in Note 1.

36.2 (Filling in steps in the proof of Theorem 36.1 (i)) Consider the event E defined in Theorem 36.1, and prove that P (Ec)  2nk.

36.3 (Filling in steps in the proof of Theorem 36.1 (ii)) Prove Eq. (36.1).

36.4 (Removing logarithmic factors) Improve the bound in Theorem 36.1 to show that BRn  C kn where C > 0 is a universal constant.

Hint Replace the naive confidence intervals used in the proof of Theorem 36.1 by the more refined confidence bounds used in Chapter 9. The source for this result is the paper by Bubeck and Liu [2013].

36.5 (Filling in steps in the proof of Theorem 36.2) Let Gi(s) = 1 - Fis(µ1 - ). Show that

n

(a) I {At = i}  I {Gi(s - 1) > 1/n}; and

tT

s=1

(b) E

I {Eic(t)}  E

1/n .

t/T

t/T

36.6 (Frequentist bound for Thompson sampling) In this exercise you will prove Theorem 36.3.

(a) Show that there exists a universal constant c > 0 such that


E
t=1

1 G1s()

-

1



c 2

log

1 

.

(b) Show that

E

n
I {Gis > 1/n}
s=1



2 log(n) (i - )2

+

o(log(n)) .

(c) Use Theorem 36.2 and the fundamental regret decomposition (Lemma 4.5) to prove Theorem 36.3.

Hint For (a) you may find it useful to know that for y  0,

1 - (y)  exp(-y2/2) , y + y2 + 4

where

(y)

=

1 2

y -

exp(-x2/2)dx

is

the

cumulative

distribution

function

of

the standard Gaussian [Abramowitz and Stegun, 1964, §7.1.13].

36.7 Prove the final equality in the proof of Lemma 36.7.

36.7 Exercises

474

36.8 (Prediction with expert advice) Consider the adversarial Bayesian framework from Section 36.4, but assume the learner observes the whole vector Xt rather than just XtAt , which corresponds to the prediction with expert advice setting. Prove that Thompson sampling in this setting has a Bayesian regret of at most

BRn  n log(k)/2 .

36.9 (Information-directed sampling) Prove that for any prior such that Xti  [0, 1] almost surely, the Bayesian regret of information-directed sampling (see Note 8) satisfies

BRn  kn log(k)/2 .

36.10 (Minimax Bayesian regret for Thompson sampling) Prove that for

any prior over adversarial k-armed bandits such that Xti [0, 1] almost surely, the Bayesian regret of Thompson sampling satisfies BRn  2kn.

Hint

Use the potential F (p) = -2

k i=1

pi

and

the

fact

that

the

total

variation distance is upper-bounded by the Hellinger distance.

36.11 (From Bayesian to adversarial regret) Let E = {0, 1}n×k and Q be the space of probability measures on E. Prove that

Rn (E) = sup BRn (Q) .
QQ

Hint Repeat the argument in the solution to Exercise 34.16, noting that Q is finite dimensional. Take care to adapt the result in Exercise 4.4 to the adversarial setting.
36.12 (From Bayesian to adversarial regret) Let E = [0, 1]n×k. Prove that

Rn (E) = sup BRn (Q) ,
QQ

where Q is the set of probability measures on (E, 2E ) with finite support.

Hint That E is uncountably large introduces some challenges. Like in the previous exercise, the idea is to express the regret of a policy as an integral over the regret of deterministic policies, which can be viewed as functions  : tn=1[0, 1]t-1  [k]. Use Tychonoff's theorem to argue that the space of all deterministic policies is compact with respect to the product topology. Then the space of regular probability measures over deterministic policies is compact with the weak* topology by Theorem 2.14. Then carefully check continuity and linearity of the Bayesian regret, and apply Sion's theorem. Details are by Lattimore and Szepesva´ri [2019c].
36.13 (Binary is the worst case) Prove that Rn ({0, 1}n×k) = Rn ([0, 1]n×k).

36.7 Exercises

475

Hint Think about how to use a minimax optimal policy for {0, 1}n×k for bandits in [0, 1]n×k.
36.14 (Implementation (i)) In this exercise, you will reproduce the results in Experiment 1.
(a) Implement Thompson sampling as described in Theorem 36.3 as well as UCB and AdaUCB.
(b) Reproduce the figures in Experiment 1 as well as UCB. (c) How consistent are these results across different bandits? Run a few
experiments and report the results. (d) Explain your findings. Which algorithm do you prefer and why.
36.15 (Implementation (ii)) Implement linear Thompson sampling with a Gaussian prior as defined in Note 6 as well as LinUCB from Chapter 19 and Algorithm 12. Compare these algorithms in a variety of regimes, report your results, and tell an interesting story. Discuss the pros and cons of different choices of r.
36.16 (Misspecified prior) Fix a Gaussian bandit with unit variance and mean vector µ = (0, 1/10) and horizon n = 1000. Now consider Thompson sampling with a Gaussian model with known unit covariance and a prior on the unknown mean of each arm given by a Gaussian distribution with mean µP and covariance P2 I.
(a) Let the prior mean be µP = (0, 0), and plot the regret of Thompson sampling as a function of the prior variance P2 .
(b) Repeat the above with µP = (0, 1/10) and (0, -1/10) and (2/10, 1/10). (c) Explain your results.

Part VIII
Beyond Bandits

37 Partial Monitoring

While in a bandit problem, the feedback that the learner receives from the

environment is the loss of the chosen action, in partial monitoring the coupling

between the loss of the action and the feedback received by the learner is loosened.

Consider the problem of learning to match

pennies when feedback is costly. Let c > 0 be

a known constant. At the start of the game, the

adversary secretly chooses a sequence i1, . . . , in  {heads, tails}. In each round, the learner chooses

an action At  {heads, tails, uncertain}. The

loss for choosing action a in round t is  0 , if a = it ;

Figure 37.1 Spam filtering is a potential application of

yta

=

1c

, ,

if a = uncertain ; otherwise .

partial monitoring. The turtle (called Spam) was inherited by one of the authors.

So far this looks like a bandit problem. The difference is that the learner never directly observes ytAt . Instead, the learner observes nothing unless At = uncertain, in which case they observe the value of it. As usual, the goal is to minimise the (expected) regret, which is

n

Rn = max E
a[k]

(ytAt - yta)
t=1

.

How should a learner act in problems like this, where the loss is not directly observed? Can we find a policy with sublinear regret? In this chapter we give a more or less complete answer to these questions for finite adversarial partial monitoring games, which include the above problems as a special case.

Matching pennies with costly feedback seems like an esoteric problem. But think about adding contextual information and replace the pennies with emails to be classified as spam or otherwise. The true label is only accessible by asking a human, which replaces the third action. While the chapter does not cover the contextual version, some pointers to the literature are added at the end.

37.1 Finite Adversarial Partial Monitoring Problems

478

37.1

Finite Adversarial Partial Monitoring Problems

A finite, k-action, d-outcome adversarial partial monitoring problem is specified by a loss matrix L  Rk×d and a feedback matrix   k×d, where  is called the set of signals. We let m be the maximum number of distinct
symbols in any row of . At the beginning of the game, the learner is given L and
, and the environment secretly chooses n outcomes i1, . . . , in with it  [d]. The loss of action a  [k] in round t is yta = Lait . In each round t, the learner chooses At  [k] and receives feedback t = Atit . Given a partial monitoring problem G = (, L), the regret of policy  when the adversary chooses i1:n = (it)nt=1 is

n

Rn(,

i1:n,

G)

=

max
a[k]

E

(ytAt - yta)
t=1

.

We omit the arguments of Rn when they can be inferred from the context.

To reduce clutter, we slightly abuse notation by using (ei) to denote the standard basis vectors of Euclidean spaces of potentially different dimensions.

37.1.1

Examples
The partial monitoring framework is rich enough to model a wide variety of problems, a few of which are illustrated in the examples that follow. Many of the examples are quite artificial and are included only to highlight the flexibility of the framework and challenges of making the regret small.

Example 37.1 (Hopeless problem). Some partial monitoring problems are completely hopeless in the sense that one cannot expect to make the regret small. A simple example occurs when k = d = 2, m = 1 and


L = 0 1 , 10


 =  


 . 

(37.1)

Note that rows/columns correspond to choices of the learner/adversary, respectively. In both rows, the feedback matrix has identical entries for both columns. As the learner has no way of distinguishing between different sequences of outcomes, there is no way to learn and avoid linear regret. The reader is encouraged to think of generalisations of this example where the game is still hopeless.

37.1 Finite Adversarial Partial Monitoring Problems

479

Two feedback matrices   k×d and ~  ~k×d encode the same information

if the pattern of identical entries in each row match. For example,









 = 1

4 2

2 

and

~ = 

 



311



both encode the same information. Note that for these matrices m = 2 since in any row there are at most two distinct symbols.

Example 37.2 (Trivial problem). Just as there are hopeless problems, there are

also trivial problems. This happens when one action dominates all others as in

the following problem: 





L = 0 0 , 11

 =   . 

In this game the learner can safely ignore the second action and suffer zero regret, regardless of the choices of the adversary.

Example 37.3 (Matching pennies). The penny-matching problem mentioned in

the introduction has k = 3 actions d = 2 outcomes and is described by







L = 01 10 ,

 =   .

(37.2)

cc

HT

Matching pennies is a hard game for c > 1/2 in the sense that the adversary can force the regret of any policy to be at least (n2/3). To see this, consider the
randomised adversary that chooses the first outcome with probability p and the second with probability 1 - p. Let  > 0 be a small constant to be chosen later and assume p is either 1/2 +  or 1/2 - . The techniques in Chapter 13 show that
the learner can only distinguish between these environments by playing the third action about 1/2 times. If the learner does not choose to do this, then the regret
is expected to be (n). Taking these together shows the regret is lower-bounded by Rn = (min(n, (c - 1/2 + )/2)). Choosing  = n-1/3 leads to a bound of Rn = ((c - 1/2)n2/3). Notice that the argument fails when c  1/2. We encourage you to pause for a minute to convince yourself about the correctness of the above argument and to consider what might be the situation when c  1/2.

Example 37.4 (Bandits). Finite-armed adversarial bandits with binary losses

37.1 Finite Adversarial Partial Monitoring Problems

480

can be represented in the partial monitoring framework. When k = 2, this is

possible with the following matrices:









L = 0 1 0 1 , 0011

 = L = 0 1 0 1 . 0011

The number of columns for this game is 2k. For non-binary rewards, you would need even more columns. A partial monitoring problem where  = L can be called a bandit problem because the learner observes the loss of the chosen action. In bandit games, Exp3 from Chapter 11 guarantees a regret of O( kn log(k)), and as noted there, a more sophisticated algorithm will also remove the log(k) factor. If you completed Exercise 15.4 then you will know that, up to a constant factor, kn is also the best possible regret in adversarial bandits with binary losses.

Example 37.5 (Full information problems). One can also represent problems

where the learner observes all the losses. With binary losses and two actions, we

have









L = 0 1 0 1 , 0011

 = 1 2 3 4 . 1234

Like for bandits, the size of the game grows quickly as more actions/outcomes are added. A partial monitoring game where ai = i for all a  [k] and i  [d] can be called full information because the signal reveals the losses for all actions.

Example 37.6 (Dynamic pricing). A charity worker is going door to door selling calendars. The marginal cost of a calendar is close to zero, but the wages of the

door knocker represents a fixed cost of c > 0 per occupied house. The question

is how to price the calendar. Each round corresponds to an attempt to sell a

calendar, and the action is the seller's asking price from one of d choices. The

potential buyer will purchase the calendar if the asking price is low enough. Below

we give the corresponding matrices for case where both the candidate asking prices

and the possible values for the buyer's private valuations are {$1, $2, $3, $4}:









L

=

c

- c c

1

c

c-1 c-2
c c

c-1 c-2 c-3
c

c c c

- - -

321

,

c-4

 = YNN

Y Y N

Y Y Y

YYY .

NNNY

Notice that observing the feedback is sufficient to deduce the loss so the problem could be tackled with a bandit algorithm. But there is additional structure in the losses here because the learner knows that if a calendar did not sell for $3, then it would not sell for $4.

37.2 The Structure of Partial Monitoring

481

37.2

The Structure of Partial Monitoring

The minimax regret of partial monitoring problem G = (L, ) is

Rn (G)

=

inf


max
i1:n

Rn(,

i1:n,

G)

.

One of the core questions in partial monitoring is to understand the growth of Rn (G) as a function of n for different games. We have seen examples where

Rn (G) = 0 Rn (G) = (n1/2) Rn (G) = (n2/3) Rn (G) = (n) .

(Example 37.2) (Example 37.4) (Example 37.3) (Example 37.1)

The main result of this chapter is that there are no other options. A partial monitoring game is called trivial if Rn (G) = 0, easy if Rn (G) = (n1/2), hard if Rn (G) = (n2/3) and hopeless if Rn (G) = (n). Furthermore, we will show that any game can be classified using elementary linear algebra.
What makes matching pennies hard and bandits easy? To get a handle on this, we need a geometric representation of partial monitoring games. The next few paragraphs introduce a lot of new terminology that can be hard to grasp all at once. At the end of the section, there is an example illustrating the concepts (Example 37.10).

37.2.1

The Geometry of Losses and Actions

The geometry underlying partial monitoring comes from viewing the problem as

a linear prediction problem, where the adversary plays on the (d - 1)-dimensional

probability simplex and the learner plays on the rows of L. Define a sequence of

vectors (ut)tn=1 by ut = eit and let a  Rd be the ath row of matrix L. The loss

suffered in round t when choosing action a is yta = a, ut .

Let

u¯t

=

1 t

t s=1

us



Pd-1

be

the

probability

vector

of

proportions

of

the adversary's choices over t rounds. An action a is optimal in hindsight if

a, u¯n  minb=a b, u¯n . The cell of an action a is the subset of Pd-1 on which

it is optimal:

Ca =

u



Pd-1

:

max
b[k]

a - b, u  0

,

which is a convex polytope. The collection {Ca : a  [k]} is called the cell decomposition of Pd-1. Actions with Ca =  are called dominated because they are never optimal, no matter how the adversary plays. For non-dominated actions we define the dimension of an action to be the dimension of the affine hull of Ca. Readers unfamiliar with the affine hull should read Note 4 at the end of the chapter. A non-dominated action is called Pareto optimal if it has dimension d - 1, and degenerate otherwise. Actions a and b are duplicates if

37.2 The Structure of Partial Monitoring

482

a = b. The set of all Pareto optimal actions is denoted by   [k]. A partial monitoring game is called degenerate if it has any degenerate or duplicate actions.
Dominated and degenerate actions can never be uniquely optimal in hindsight, but their presence can make the difference between a hard game and a hopeless one. Consider the matching pennies game (Example 37.3). When c > 1/2, the third action is dominated, but without it the learner would suffer linear regret. Duplicate actions are only duplicate in the sense that they have the same loss. They may have different feedback structures and so cannot be trivially combined.

Neighbourhood relation Pareto optimal actions a and b are neighbours if Ca  Cb has dimension d - 2. Note that if a and b are Pareto optimal duplicates, then Ca  Cb has dimension d - 1, and the definition means that a and b are not neighbours. For Pareto optimal action a we let Na be the set consisting of a and its neighbours. Given a pair of neighbours e = (a, b), we let Ne = Nab = {c  [k] : Ca  Cb  Cc} to be the set of actions that are incident to e. The neighbourhood relation defines an undirected graph over [k] with edges E = {(a, b) : a and b are neighbours}, which is called the neighbourhood graph.
The next result, which shows the connectedness of the neighborhood graph induced by a set of actions whose cells cover the whole simplex, will play an important role in subsequent proofs:
Lemma 37.7. Suppose that S is any set of Pareto optimal actions such that aS Ca = Pd-1. Then the graph with vertices S and edges from E is connected.
Let e = (a, b)  E. The next lemma characterises actions in Ne as either a, b, duplicates of a, b or degenerate actions c for which c is a convex combination of a and b. The situation is illustrated when d = 2 in Fig. 37.2.
Lemma 37.8. Let e = (a, b)  E be neighbouring actions and c  Ne be an action such that c / { a, b}. Then
(a) there exists an   (0, 1) such that c =  a + (1 - ) b; (b) Cc = Ca  Cb; and (c) c has dimension d - 2.
Proof We use the fact that if X  Y  Rd and dim(X ) = dim(Y), then aff(X ) = aff(Y) (Exercise 37.2). Introduce ker (x) = {u  Rd : u x = 0, u 1 = 1}. Clearly, Ca Cb  Ca Cc and aff(Ca Cb) = ker ( a - b) and aff(Ca Cc) = ker ( a - c). By assumption dim(Ca  Cb) = d - 2. Since Ca  Cb  Ca  Cc, it holds that dim(Ca  Cc)  d - 2. Furthermore, dim(Ca  Cc)  d - 2, since otherwise c = a. Hence dim(Ca  Cc) = d - 2 and thus by the fact mentioned and our earlier

37.2 The Structure of Partial Monitoring

483

losses

3, (u, 1 - u)

u) , (u, 1 -
1

2 , (u, 1 - u)

0

u

1

Figure 37.2 The figure shows the situation when d = 2 and 1 = (1, 0) and 2 = (0, 1) and 3 = (1/2, 1/2). The x axis corresponds to P1 = [0, 1], the y axis to the losses. Then C1 = [0, 1/2] and C2 = [1/2, 1], which both have dimension 1 = d - 1. Then C3 = {1/2} = C1  C2, which has dimension 0.

findings, ker ( a - b) = ker ( a - c). This implies (Exercise 37.3) that a - b is proportional to a - c so that (1 - )( a - b) = a - c for some  = 1. Rearranging shows that
c =  a + (1 - ) b .
Now we show that   (0, 1). First note that  / {0, 1} since otherwise c  { a, b}. Let u  Ca be such that a, u < b, u , which exists since dim(Ca) = d - 1 and dim(Ca  Cb) = d - 2. Then
a, u  c, u =  a, u + (1 - ) b, u = a, u + ( - 1) a - b, u ,
which by the negativity of a - b, u implies that   1. A symmetric argument shows that  > 0. For (b), it suffices to show that Cc  Ca  Cb. By de Morgan's law, for this it suffices to show that Pd-1 \ (Ca  Cb)  Pd-1 \ Cc. Thus, pick some u  Pd-1 \ (Ca  Cb). The goal is to show that u  Cc. The choice of u implies that there exists an action e such that a - e, u  0 and b - e, u  0 with a strict inequality for either a or b (or both). Therefore, using the fact that   (0, 1), we have
c, u =  a, u + (1 - ) b, u > e, u ,
which by definition means that u / Cc, completing the proof of (b). Finally, (c) is immediate from (b) and the definition of neighbouring actions.

37.2.2

Estimating Loss Differences
In order to achieve small regret, the learner needs to identify an optimal action. How efficiently this can be done depends on the loss and feedback matrices. An initial observation is that since the loss matrix is known, the learner can restrict the search for the optimal action to the Pareto optimal actions. Furthermore, by Lemma 37.7, it suffices to estimate the loss differences between neighbours and then chain the estimates together along a connecting path. The second important point is that to minimise the regret the learner only needs to estimate

37.2 The Structure of Partial Monitoring

484

the differences in losses between Pareto optimal actions and not the actual losses themselves. In fact, there exist games for which estimating the actual losses is impossible, but estimating the differences is straightforward:

Example 37.9. Consider the partial monitoring game with









L = 0 1 10 11 , 1 0 11 10

 =     . 

The learner can never tell if the environment is playing in the first two columns or the last two, but the differences between the losses of actions are easily deduced from the feedback no matter the outcome and the action.

Only the loss differences between Pareto optimal actions need to be estimated. There are games that are easy, but where some loss differences cannot be estimated. For example, there is never any need to estimate the losses of a dominated action.

Having decided we need to estimate the loss differences between neighbouring
Pareto optimal actions, the next question is how the learner can do this. Focusing
our attention on a single round, suppose the adversary secretly chooses an outcome i  [d] and the learner samples an action A from distribution p  ri(Pk-1) and observes  = Ai. We are interested in finding an unbiased estimator of Lai - Lbi for neighbouring actions a and b. Without loss of generality, the estimator can be in the form of f (A, )/pA with some function f : [k] ×   R. Then, the unbiasedness requirement takes the convenient form

E

f (A, ) pA

k
= f (c, ci) .
c=1

In other words, f (A, )/pA is an unbiased estimator of Lai - Lbi regardless of the adversaries' choice if and only if

k
f (c, ci) = Lai - Lbi
c=1

for all i  [d] .

(37.3)

A pair of neighbours a and b are called globally observable if there exists a function f satisfying Eq. (37.3). The set of all functions f : [k] ×   R satisfying Eq. (37.3) is denoted by Eagblo. A pair of neighbours a and b are locally observable if f can be chosen satisfying Eq. (37.3) with f (c, ) = 0 whenever c / Nab. The set of functions satisfying this additional requirement are Ealobc. A partial monitoring problem is called globally/locally observable if all pairs of neighbouring actions are
globally/locally observable. The global/local observability conditions formalise
the idea introduced in Example 37.3. Games that are globally observable but not
locally observable are hard because the learner cannot identify the optimal action

37.3 Classification of Finite Adversarial Partial Monitoring

485

by playing near-optimal actions only. Instead it has to play badly suboptimal actions to gain information, and this increases the minimax regret.
Example 37.10. The partial monitoring problem illustrated in Fig. 37.3 has six actions, three feedbacks and three outcomes. The cell decomposition is shown on the right with the 2-simplex parameterised by its first two coordinates u1 and u2 so that u3 = 1 - u2 - u1. Actions 1, 2 and 3 are Pareto optimal. There are no dominated actions while actions 4 and 5 are 1-dimensional and action 6 is 0dimensional. The neighbours are (1, 3) and (2, 3), which are both locally observable, and so the game is locally observable. Note that (1, 2) are not neighbours because the intersection of their cells is (d - 3)-dimensional. Finally, N3 = {1, 2, 3} and N1 = {1, 3} and N23 = {2, 3, 4}. Think about how we decided on what losses to use to get the cell decomposition shown in Fig. 37.3.









u2

L = 130//1124

1 0 1/2 1/4 1/2

311///11242

 = 11

2   2 

33 

C6 C5

C4 C2
C3 C1

1 1/4 3/4



u1

Figure 37.3 Partial monitoring game with k = 6 and d = 3 and m = 3.

37.3

Classification of Finite Adversarial Partial Monitoring

The terminology in the last section finally allows us to state the main theorem of this chapter that classifies finite adversarial partial monitoring games.

Theorem 37.11. The minimax regret of partial monitoring problem G = (L, )

falls into one of four categories:



Rn (G)

=

0 ,(n1/2) ((nn)2/,3)

, ,

if G has no pairs of neighbouring actions ; if G is locally observable and has neighbouring actions ; if G is globally observable, but not locally observable ; otherwise .

The Landau notation is used in the traditional mathematical sense and obscures dependence on k, d, m and the finer structure of G = (L, ).

37.4 Lower Bounds

486

The proof is split into parts by proving upper and lower bounds for each part. First up is the lower bounds. We then describe a policy and analyse its regret.

37.4

Lower Bounds

Like for bandits, the lower bounds are most easily proven using a stochastic

adversary. In stochastic partial monitoring, we assume that u1, . . . , un are chosen independently at random from the same distribution. To emphasise

the randomness, we switch to capital letters. Given a partial monitoring game
G = (L, ) and probability vector u  Pd-1, the stochastic partial monitoring environment associated with u samples a sequence of independently and identically distributed random variables I1, . . . , In with P (It = i) = ui and Ut = eIt . In each round t, a policy chooses action At and receives feedback t = AtIt . The regret is

n

n

Rn(,

u)

=

max
a[k]

E

t=1

At - a, Ut

= max E
a[k]

t=1

At - a, u

.

The reader should check that Rn (G)  inf maxuPd-1 Rn(, u), which allows us to restrict our attention to stochastic partial monitoring problems. Given
u, q  Pd-1, let D(u, q) be the relative entropy between categorical distributions with parameters u and q respectively:

d
D(u, q) = ui log
i=1

ui qi



d i=1

(ui

- qi)2 qi

,

(37.4)

where the second inequality follows from the fact that for measures P, Q we have D(P, Q)  2(P, Q) (see Note 5 in Chapter 13).

Theorem 37.12. Let G = (L, ) be a globally observable partial monitoring
problem that is not locally observable. Then there exists a constant cG > 0 such that Rn (G)  cGn2/3.

Proof The proof involves several steps. Roughly, we need to define two alternative stochastic partial monitoring problems. We then show these environments are hard to distinguish without playing an action associated with a large loss. Finally we balance the cost of distinguishing the environments against the linear cost of playing randomly. Without loss of generality assume that  = [m].

Step 1: Defining the Alternatives Let a, b be a pair neighbouring actions that are not locally observable. Then, by definition, Ca  Cb is a polytope of dimension d - 2. Let u be the centroid of Ca  Cb and

 = min c - a, u .
c/Nab

(37.5)

37.4 Lower Bounds

487

Ca

ua

u

Cb

ub Cc

Figure 37.4 Lower-bound construction for hard partial monitoring problems. Shown is Pd-1, the cells Ca and Cb of two Pareto optimal actions, and two alternatives ua  Ca and ub  Cb that induce the same distributions on the outcomes under both a and b.

The value of  is well defined, since by global observability of G, but nonlocal
observability of (a, b), there must exist some action c / Nab. Furthermore, since c / Nab, it follows that  > 0. As in the lower-bound constructions for stochastic
bandits, we now define two stochastic partial monitoring problems ua, ub by choosing a direction q  Rd and a small value  such that ua = u - q  Ca and ub = u + q  Cb (see Fig. 37.4). This means that action a is optimal if the
environment plays ua on average and b is optimal if the environment plays ub
on average. The direction q will be chosen so that using a and b alone it is not
possible to distinguish between ua and ub. The vector q is chosen as follows: Since (a, b) are not locally observable, Ealobc = .
Equivalently, there does not exist a function f : [k] ×   R such that for all i  [d],

f (c, ci) = ai - bi .
cNab

(37.6)

In this form, it does not seem obvious what the next step should be. To clear
things up, we introduce some linear algebra. Let Sc  {0, 1}m×d be the matrix with (Sc)i = I {ci = }, which is chosen so that Scei = eci . Define the linear map S : Rd  R|Nab|m by


S = SS...ab , Sc

which is the matrix formed by stacking the matrices {Sc : c  Nab}. Then, an elementary argument shows that there exists a function f satisfying Eq. (37.6) if

37.4 Lower Bounds

488

and only if there exists a w  R|Nab|m such that

a- b =S w.

In other words, actions (a, b) are locally observable if and only if a - b  im(S ).
Since we have assumed that (a, b) are not locally observable, we must have
a - b / im(S ). Let z  im(S ) and w  ker(S) be such that a - b = z + w, which is possible since im(S )ker(S) = Rd. Since a - b / im(S ), it holds that w = 0 and a - b, w = z + w, w = w, w = 0. Note also that 1  im(S ) and hence 1, w = 0. Finally, let q = w/ a - b, w . By construction, q  Rd, q = 0 while Sq = 0, a - b, q = 1 and 1, q = 0. Let  > 0 be some small constant
to be chosen subsequently. With this, we define ua = u - q and ub = u + q so
that

b - a, ua =  and

a - b, ub =  .

(37.7)

We note that if  is sufficiently small, then ua  Ca and ub  Cb because a and b are Pareto optimal.

Step 2: Calculating the Relative Entropy Given action c and r  Pd-1, let Pcr be the distribution on the feedback observed by the learner when playing action c in stochastic partial monitoring environment determined by r. That is Pcr() = (Scr). Further, let Pr be the distribution on the histories Hn = (A1, 1, . . . , An, n) arising from the interaction of the
learner's policy with the stochastic environment determined by r. Expectations with respect to Pr are denoted by Er. A modification of Lemma 15.1 shows that

D(Pua , Pub ) =

Eua [Tc(n)] D(Pcua , Pcub ) .

c[k]

(37.8)

By the definitions of ua and ub, we have Scua = Scub for all c  Nab. Therefore, Pcua = Pcub and D(Pcua , Pcub ) = 0 for all c  Nab. On the other hand, if c / Nab, then by the data processing inequality (Exercise 14.9) and Eq. (37.4),
for   mini:qi=0 ui/(2|qi|),

D(Pcua , Pcub )  D(ua, ub) 

d i=1

(uai - ubi)2 ubi



k
42
i=1

qi2 ui - |qi|

 C~u2 ,

where we used that u  Ca  Cb is not on the boundary of Pd-1, so ui > 0 for all i and we defined C~u as a suitably large constant that depends on u (q is entirely determined by a and b). Therefore,

D(Pua , Pub )  C~u

E[Tc(n)]2 .

c/Nab

(37.9)

Step 3: Comparing the Regret By Eq. (37.5) and H¨older's inequality, for c / Nab we have c - a, ua   - c - a, q   -  q 1 and c - b, ub   -  q 1, where, for simplicity

37.4 Lower Bounds

489

and without the loss of generality, we assumed that the losses lie in [0, 1]. Define T~(n) to be the number of times an arm not in Nab is played:

T~(n) =

Tc(n) .

c/Nab

By Lemma 37.8, for each action c  Nab, there exists an   [0, 1] such that c =  a + (1 - ) b. Therefore, by Eq. (37.7),

c - a, ua + c - b, ub = (1 - ) b - a, ua +  a - b, ub =  , (37.10)

which means that max( c - a, ua , c - b, ub )  /2. Define T¯(n) as the number of times an arm in Nab is played that is at least /2 suboptimal in ua:

T¯(n) =

I

cNab

c-

a, ua



 2

Tc(n) .

It also follows from (37.10) that if c  Nab and

c - a, ua

<

 2

,

then

c- is at

b, ub least

 (n

 2
-

.T¯H(enn)c)e, /u2n.dAersusub,mtheetrhaantdomispscehuodsoe-nresgureffit,cienctTlyc

(n) c- b, ub , small so that

 q 1  /2. By the above,

Rn(, ua) +Rn(, ub)







= Eua  Tc(n) c - a, ua  + Eub  Tc(n) c - b, ub 

c[k]

c[k]



 2

Eua

T~(n)

+

n 4

Pua (T¯(n)  n/2) + Pub (T¯(n) < n/2)



 2

Eua

T~(n)

+

n 8

exp (-

D(Pua ,

Pub ))



 2

Eua

T~(n)

+

n 8

exp

-C~u2Eua

T~(n)

,

where the second inequality follows from the Bretagnolle­Huber inequality (Theorem 14.2) and the third from Eqs. (37.8) and (37.9). The bound is completed by choosing

 = min

min
i:qi =0

ui 2|qi|

,

2

q

 1n1/3

,

which is finite since q = 0. Straightforward calculation concludes the result (Exercise 37.7).

We leave the following theorems as exercises for the reader (Exercises 37.8 and 37.9):

Theorem 37.13. If G is not globally observable and has at least two nondominated actions, then there exists a constant cG > 0 such that Rn (G)  cGn.

37.5 Policy and Upper Bounds

490

Proof sketch Since G is not globally observable, there exists a pair of
neighbouring actions (a, b) that are not globally observable. Let u be the centroid of CaCb. Let S  Rkm×d be the stack of matrices from {Sc : c  [k]}. Then, using the same argument as the previous proof, we have a - b / im(S ). Now define q  Rd such that 1, q = 0, a - b, q = 1 and Sq = 0. Let  > 0 be sufficiently small and ua = u-q and ub = u+q. Show that D(Pua , Pub ) = 0 for all policies and complete the proof in the same fashion as the proof of Theorem 37.12.

Theorem 37.14. Let G = (L, ) be locally observable and have at least one pair

of n

tnheeigmhbinouimrsa.xTrheegnretthsearteisefixeisstsRan (cGo)nstacnGt cGn.>

0

such

that

for

al l

large

enough

Proof sketch By assumption, there exists a pair of neighbouring actions (a, b). Define u as the centroid of Ca  Cb and ua and ub be the centroids of Ca and Cb respectively. For sufficiently small  > 0, let va = (1 - )u - ua and vb = (1 - )u + ub. Then

D(Pva , Pvb ) 

d
n
i=1

(vai - vbi)2 vbi

 cGn2 ,

 where cG > 0 is a game-dependent constant. Let  = 1/ n and apply the ideas

in the proof of Theorem 37.12.

37.5

Policy and Upper Bounds

We now describe a policy for globally and locally observable games, and prove its regret is O(n1/2) for locally observable games and O(n2/3) otherwise. For
the remainder of this section, fix a globally observable game G = (L, ). The estimation functions in Eagblo and Ealobc are designed to combine with importanceweighting to estimate the loss differences between actions a and b. For this section,
it is more convenient to define estimation functions for the whole loss vector up to constant shifts. Let E vec be the set of all functions f : [k] ×   Rk such that:

(a) f (a, )b = 0 for all b / ; and (b) for each outcome i  [d], there exists a constant c  R with

k
f (a, ai)b = Lbi + c for all b   .
a=1
The intuition is that E vec is the set of functions that serve as unbiased loss difference estimators in the sense that when A  p  ri(Pk-1), then

E

ea - eb, f (A, Ai) pA

= a - b, ei

for all Pareto optimal a, b and i  [d] .

As we will see in the proof of Theorem 37.16, if G is globally observable, then

37.5 Policy and Upper Bounds

491

E vec is non-empty. By identifying functions and vectors, E vec  Rk(km), a view that will be useful later.
The policy for partial monitoring combines exponential weights with a careful
exploration strategy. A little reminder about exponential weights and some new
notation will be useful. Given a probability vector q  Pk-1, define a function q : Rk  R by

q(z) = q, exp(-z) + z - 1 ,

where the exponential function is applied component-wise. You might recognise q as the Bregman divergence

q(z) = DF  (F (q) - z, F (q)) ,

where F is the unnormalised negentropy potential. Suppose that (y^t)tn=1 is an arbitrary sequence of vectors with y^t  Rk,  > 0 and

Qta =

exp -

t-1 s=1

y^sa

,

k b=1

exp

-

t-1 s=1

y^sb

t  [n] .

Recall from Theorem 28.4 that for any a  [k],

n

k

Qta(y^ta

-

y^ta )



log(k) 

+

1 

n

Qt (y^t) .

t=1 a=1

t=1

(37.11)

Exp3 is derived by defining y^t as the importance-weighted loss estimator and sampling At from Qt. We will do something similar in partial monitoring, but with two significant differences: (a) the importance-weighted estimator must depend on the feedback and loss matrices, and (b) the algorithm will sample At from an alternative distribution Pt that is optimised to balance the regret suffered relative to Qt and the information gained.

The definition of global observability does not imply that loss differences between dominated and degenerate actions can be estimated. Consequentially, the distribution Qt used by the new algorithm will be supported on Pareto optimal actions only. The actual distribution Pt used when choosing an action may also include degenerate actions, however.

The optimisation problem for balancing information and regret explicitly optimises a worst case upper bound on the right-hand side of Eq. (37.11). For  > 0 and q  Pk-1 with Supp(q)  , let

optq() = fiEnvfec

max
i[d]

pri(Pk-1 )

1 

(p

-

q)

Lei

+

1 2

k

paq

a=1

f (a, ai) pa

. (37.12)

37.5 Policy and Upper Bounds

492

Of course, optq() depends on the game G, which is hidden from the notation to reduce clutter. The first term in the right-hand side of Eq. (37.12) measures the additional regret when playing p rather than q, while the second corresponds to the expectation of the second term in Eq. (37.11) when the algorithm uses importance-weighting using estimation function f . The optimisation problem is convex and hence amenable to efficient computation (see Note 9 for some details). The worst-case value over all q is
opt() = sup{optq() : q  Pk-1, Supp(q)  } .
The function q  optq() is generally not convex, so opt() may be hard to compute. This causes a minor problem when setting the learning rate, which can be mitigated by adapting the learning rate online as discussed in Note 7.

We say that f  E vec and p  ri(Pk-1) solve Eq. (37.12) with precision   0 if

max
i[d]

1 

(p

-

q)

Lei

+

1 2

k
paq
a=1

f (a, ai) pa

 optq() +  . (37.13)

Such approximately optimal solutions exist for any  > 0, but may not exist for  = 0 because the constraint on p is not compact.

The convexity of the inner maximum in Eq. (37.12) can be checked using the following construction. The perspective of a convex function f : Rd  R is a function g : Rd+1  R given by

g(x, u) = uf (x/u) , if u > 0 ;

,

otherwise .

(37.14)

The perspective is known to be convex (Exercise 37.1). Since q is convex and the max of convex functions is convex, it follows that the term inside of the infimum of Eq. (37.12) is convex.

The full algorithm is given as Algorithm 26.

Theorem 37.15. For any  > 0 and  > 0, the regret of Algorithm 26 is bounded by

Rn



log(k) 

+

n(opt() + ) .

Proof The result follows from the definitions of E vec and the regret, and the

bound for exponential weights in Eq. (37.11). Let a = argmina

n t=1

a, ut .

37.5 Policy and Upper Bounds

493

1: Input: , , L and  2: for t  1, . . . , n do 3: Compute exponential weights distribution Qt  Pk-1 by:

I(a) exp - Qta =
b exp -

t-1 s=1

y^sa

t-1 s=1

y^sb

.

4: Solve Eq. (37.12) with q = Qt and precision  to find Pt  Pk-1 and ft  E vec
5: Sample At  Pt and observe t 6: Set y^t = ft(At, t)/PtAt
7: end for

Algorithm 26: Exponential weights for partial monitoring. Recall that  denotes the set of Pareto optimal actions.

Then,

Rn = E =E =E =E

n

LAtit - Lait
t=1

nk

Pta(Lait - Lait )
t=1 a=1

nk
Qta(Lait - Lait )
t=1 a=1

+E

nk
(Pta - Qta)Lait
t=1 a=1

nk

nk

Qta(y^ta - y^ta ) + E

(Pta - Qta)Lait .

t=1 a=1

t=1 a=1

The first expectation is bounded using the definition of Qt and Eq. (37.11) by

E

n

k

Qta(y^ta - y^ta )



log(k) 

+

1 

E

n
Qt (y^t)

t=1 a=1

t=1

=

log(k) 

+

1 

E

n

k
PtaQt

t=1 a=1

ft(a, ait ) Pta

.

Combining the two displays, using the definitions of Pt, ft and t, and substituting the definition of optQt ()  opt() completes the proof.
The extent to which this result is useful depends on the behaviour of opt() for different classes of games. The following two theorems bound the value of the optimisation problem for globally observable and locally observable games respectively. An apparently important quantity in the regret upper bounds for both globally and locally observable games is the minimum magnitude of the

37.5 Policy and Upper Bounds

494

estimation functions. Let

vglo

=

max
eE

min
f Eeglo

f



and

vloc

=

max
eE

min
f Eeloc

f

.

In the remainder of this chapter we assume that the losses are between zero and one L  [0, 1]k×d.

Theorem 37.16. For all globally observable games, opt()  2vglok2/ for all   1/ max{1, vg2lok4}. Theorem 37.17. For all locally observable games, opt()  9k3 max(1, vl2oc) for all   1/(2k2 max(1, vloc)).
The proofs follow in subsequent sections. Combining Theorem 37.15 with Theorem 37.17 shows that for an appropriately tuned learning rate, the regret of Algorithm 26 on locally observable games is bounded by
Rn = O vlock3/2 n log(k) .
By using Theorem 37.16, it follows that for globally observable games the regret is bounded by
Rn = O (vglokn)2/3(log(k))1/3 .
These results establish the upper bounds in the classification theorem for locally and globally observable games. The quantities vglo and vloc only depend on G but may be exponentially large in d. We walk you through the proof of the following proposition in Exercise 37.12.
Proposition 37.18. The following hold:
(a) If G is globally observable, then vglo  d1/2kd/2. (b) If G is locally observable, then vloc  d1/2kd/2. (c) If G is locally observable and non-degenerate, then vloc  m.
The only property of non-degenerate games used in Part (c) is that |Ne| = 2 for all e  E. It is illustrative to bound opt() for well-known games. The next proposition shows that Algorithm 26 recovers the usual bounds for bandits and the full information setting.
Proposition 37.19. The following hold:
(a) For bandit games ( = L), opt()  k/2. (b) For full information games (ai = i for all a and i), opt()  1/2.
You will prove this proposition in Exercise 37.14 by making explicit choices of p  ri(Pk-1) and f  E vec.

37.6 Proof of Theorem 37.16

495

37.6

Proof of Theorem 37.16

The definition of global (and local) observability is defined in terms of the existence
of functions serving as unbiased loss estimators between pairs of neighbouring actions. To make a connection between E vec and E glo (and E loc) we need the
concept of an in-tree on the neighbourhood graph. Let S be a subset of Pareto
optimal actions with no duplicate actions and aS Ca = Pd-1. An in-tree on the graph (S, E) is a set of edges T  E such that (S, T ) is a directed tree with all
edges pointing towards a special vertex called the root, denoted by rootT and such that V (T ), the set of vertices underlying T , is the same as S. Provided
the game is non-trivial, then such a tree exists by Lemma 37.7. Given a Pareto
optimal action b, let pathT (b)  T denote the path from b to the root. The path is empty when b is the root. When b is not the root, we let parT (b) denote the unique Pareto optimal action such that (b, parT (b))  T .
Abbreviate v = vglo and let T  E be an arbitrary in-tree over the Pareto optimal actions. For each e  E, let fe  Eeglo be such that fe   v. Then define f : [k] ×   Rk by

f (a, )b =

fe(a, ) .

epathT (b)

By the triangle inequality, maxa[k], f (a, )   kv. Furthermore, f  E vec, since for any outcome i,

k

k

f (a, ai)b =

fe(a, ai) = Lbi - Lroot(T )i .

a=1

a=1 epathT (b)

Let p = (1 - )q + 1/k with  = vk2. By the condition in the theorem that

  1/ max{1, v2k4}, it holds that   1 and hence p  ri(Pk-1). The next step

is to bound the minimum possible value of the loss estimator. For actions a and

b and outcome i,

f (a, ai)b pa



-

vk2 

=

-



-1 ,

where in the final inequality we used the fact that   1. Next, using the fact that exp(-x)  x2 + 1 - x for x  -1, it follows that for any z  -1,

k
q(z)  qbzb2 ,
b=1

(37.15)

which is the inequality we have used long ago in Chapter 11. Using this,

1 2

k

paq

a=1

f (a, ai) pa



k a=1

b

qb pa

f (a,

ai)2b



k4v2 

=

k2v 

,

where we used that f (a, )   kv and p  /k1 and that q  Pk-1. For the

37.7 Proof of Theorem 37.17

496

other component of the objective,

1 

(p

-

q)

Lei

=

 

(1/k

-

q)

Lei

=

vk2 

(1/k

- q)

Lei



vk2 

.

Combining the previous two displays shows that for any i  [d],

1 

(p

-

q)

Lei

+

1 2

k
paq
a=1

which is the desired result.

f (a, ai) pa

 2vk2 ,

37.7

Proof of Theorem 37.17

Exploiting local observability is not straightforward. To gain some insight let us consider the matching pennies game with c = 1/4:









L = 

0 1

1 0



 =  

1

3

2

1/4 1/4

HT

The figure on the right-hand side is the neighbourhood graph. Notice that the third

action is revealing and also separates the first two actions in the neighbourhood

graph. Clearly, loss differences can be estimated between all pairs of neighbours

in this graph, and hence the game is locally observable. Let's suppose now that

q = (1/2 - /2, 1/2 - /2, ) and p = q. The obvious estimation function f  E vec

is given by

 (0, 1, 1/4) , if a = 3 and  = 1 ;

f (a, ) = 0(1,, 0, 1/4)

,

if a = 3 and  = 2 ; otherwise .

Examining the second term in Eq. (37.12) and using a second order Taylor approximation,

1 2

3
paq

a=1

f (a, ai) pa



1 2

3 b=1

qb p3

Lb2i

=

1 32

+

1- 4

,

which holds for both i = 1 and i = 2. This is bad news. The appearance of p3 = q3 in the denominator means the objective can be arbitrarily large when  is small. Taylor's theorem shows that the approximation is not to blame, provided that  is suitably small. The main issue is that q and p assign most of their mass to two actions that are not neighbours and hence cannot be distinguished without

37.7 Proof of Theorem 37.17

497

playing a third action. Now suppose that p is constructed by transferring mass from the first two actions to the third by:

p = q - min(q1, q2)(e1 + e2) + 2 min(q1, q2)e3 .

The first observation is that this can only decrease the expected loss:

(p - q)

L

=

-

3 4

min(q1,

q2)1



0

.

This takes care of the first term in the objective. Let us assume without loss of

generality that p1 = max(p1, p2, p3), and let



(0, 1, 1/4) ,

if a = 3 and  = 1 ;

f (a, ) = 0(0,, -1, -3/4)

,

if a = 3 and  = 2 ; otherwise .

Using again a Taylor approximation suggests the second term in the objective is now well behaved:

1 2

k
paq

a=1

f (a, ai) pa



1 2

k b=1

qb p3

f

(3,

3i)2b



1 2

q2 p3

+

q3 p3



1 2

1 2

+

1

.

Things are starting to look more promising. By transferring the mass in q towards the revealing action and shifting the loss estimators to be zero on the most played action, we have gained control of the stability term and simultaneously decreased the expected loss of p relative to q.

37.7.1

Duality and the Water Transfer Operator

The water transfer operator, which we will introduce momentarily, provides the generalisation of the specific argument just given. The first step is an application of Sion's minimax theorem (Theorem 28.12) to Eq. (37.12), which shows that

optq ()

=

max
Pd-1

fiEnvf ec

pPk-1

(p - q) 

L

+

1 2

d

i

k

paq

i=1 a=1

f (a, ai) pa

.

(37.16)

By exchanging the max and the inf, we free ourselves from finding a distribution p and estimation function f such that the objective is controlled for all choices of the adversary. Now we only need to find a p and f for each distribution over outcomes   Pd-1.
Fix therefore an arbitrary distribution   Pd-1. Let S be an arbitrary subset of Pareto optimal actions containing no duplicates and for which aS Ca = Pd-1 and let T  E be an in-tree over S. Given an edge e = (a, b)  E, let e : Ne  [0, 1] be the mapping such that c = (1 - e(c)) a + e(c) b for

37.7 Proof of Theorem 37.17

498

7 65

8

9

Root 12

Degenerate

4

actions

11

2 13

10

Figure 37.5 The large nodes are Pareto optimal actions in S. The smaller nodes inside
are their duplicates, which are not part of S. The remaining nodes are degenerate
actions that are linear combinations of Pareto optimal actions. The arrows indicate the in-tree. A vector y  Rk is T -increasing if it is constant on duplicate actions and otherwise increasing in the direction of the arrows. In this case, the constraint is that
y1 = y2 = y3  y4  y5 = y6 = y7  y8  y9  y12 and y10  y11  y12.

all c  Ne, which exists by Lemma 37.8. Note that e(c) = 0 when c is a duplicate of a and e(c) = 1 when it is a duplicate of b. A vector y  Rk is called T -increasing if for all e = (a, b)  T and c, d  Ne with e(d)  e(c), it holds
that yd  yc. A vector y is called T -decreasing if -y is T -increasing. This concept
is illustrated in Fig. 37.5.

Lemma 37.20. Given an in-tree T  E and distribution q  Pk-1 there exists a distribution r  Pk-1 such that

(a) r  q/k;
(b) r is T -increasing; and (c) r - q, y  0 for all T -decreasing vectors y  Rk.

Proof For simplicity, we give the proof for the special case that all actions

are Pareto optimal and there are no duplicates, in which case S = [k].

The proof is generalised in Exercise 37.11. Given an action a  [k], let

ancT (a) = epathT (a)Ne  {a} be the set of ancestors of a, including a and descT (a) = {b : a  ancT (b)} be the set of descendants of a. Define r by

ra

=

bdescT

(a)

qb | ancT

(b)|

.

Let us first confirm that r  Pk-1. That r  0 is obvious and

k
ra
a=1

=

k a=1 bdescT (a)

qb | ancT (b)|

=

k b=1 aancT (b)

qb | ancT (b)|

=

1.

37.7 Proof of Theorem 37.17

499

For Part (a), the definition means that ra  qa/| ancT (a)|  qa/k. That r is T -increasing follows immediately from the definition. (c) follows because

r, y

=

k
ya
a=1 bdescT (a)

qb | ancT (b)|



k a=1 bdescT (a)

ybqb | ancT (b)|

=

q, y

.

The existence of the mapping q  r given by Lemma 37.21 was originally proven using a `water flowing' argument and was called the water transfer operator.

Lemma 37.21. Let S as before. Then, for any   Pd-1, there exists an in-tree T  E over vertices S such that L is T -decreasing.

Proof Again, we outline the argument for games with no degenerate or duplicate
actions, leaving the complete proof for Exercise 37.11. Let a be an action such
that   Ca. First, assume that   ri(Ca). The root of our tree will be a (the reader may find helpful to check Fig. 37.6). Next, for b = a, define
par(b) = argmincNb ec L and then let T = {(b, par(b)) : b = a}. Clearly, V (T ) = [k]. Provided that T really is a tree, the fact that L is T -decreasing is
obvious from the definition of the parent function. That T is a tree follows by
showing that for any (b, d)  T , ed L < eb L, which we will prove now. For this, let   ri(Cb) and c  Nb such that Cc  [, ] = . These exist by Exercise 37.10 (see also Fig. 37.6). We now show that ec L < eb L from which the desired result follows. To show this let

f () = (eb - ec) L((1 - ) + ) .
It suffices to show that f (1) > 0. The following hold: (a) f is linear; (b) f (0) < 0, since   ri(Cb); and (c) there exists an   (0, 1) such that f () = 0, which holds because Cc  [, ] =  and   ri(Ca). Thus f (1) > 0, establishing the result for   ri(Ca). When  is on the boundary of Ca, let ((i)) i=1 be a sequence in ri(Ca) so that limi (i)  . For each i, let T (i)  E be an in-tree such that L(i) is T (i)-decreasing. Since there are only finitely many trees, by selecting a subsequence we conclude that there exists an in-tree T  E such that L(i) is T -decreasing for all i. The result follows by taking the limit.

This concludes the building of the tools needed to control optq() for locally observable games.

Proof of Theorem 37.17 Abbreviate v = vloc and let   Pd-1 be arbitrary. By Lemma 37.21, there exists an in-tree T  E over S such that L is T -decreasing.
Hence, by Lemma 37.20, there exists a T -increasing r  Pk-1 such that r  q/k and (r - q) L  0. Let p = (1 - )r + 1/k with  = vk2 and

f (a, )b =

fe(a, ) ,

epathT (b)

where fe  Eeloc has fe   v. The same argument as in the proof of

37.7 Proof of Theorem 37.17

500

Ca 

Cc

 Cb

Figure 37.6 The core argument used in the proof of Lemma 37.21.

Theorem 37.17 shows that f  E vec. Moving to the objective in Eq. (37.16), we lower-bound the loss estimates:

f (a, )b pa

=

 pa

fe(a, )
epathT (b)



- vk2 

=

-1 .

(37.17)

Fix i  [k]. The stability term is bounded using the properties of p and f as follows:

1 2

k
paq

a=1

f (a, ai) pa



k a=1

b

qb pa

f (a,

ai)2b



2

=

k a=1 b

qb pa



fe(a, ai)

epathT (b)



2



2v2

k a=1

b

qb ra


epathT

I {a
(b)



Ne}



8v2

k a=1

b

qb ra

I

a  epathT (b)Ne



8v2

k a=1

b

qb rb

 8k3v2 .

Here, in the first inequality we used Eq. (37.15) and Eq. (37.17). The second inequality follows by the definition of v = vloc and the choice of fe  Eeloc, and also because pa  ra/2 by the condition on  in the theorem statement. The
third since any action a is in Ne for at most two edges in e  pathT (b) (because V (T )   and it has no duplicates). The fourth inequality is true since r is
T -increasing and the fifth because r  q/k. Finally, by Part (c) of Lemma 37.20

37.8 Proof of the Classification Theorem

501

and the fact that L is T -decreasing,

1 

(p

-

q)

L

=

1

- 

 (r

-

q)

L

+

 

(1/k

-

q)

L  k2v  k3 max(1, v2) .

Combining the previous two displays shows that

(p - q) 

L

+

1 2

d

k

i paq

i=1 a=1

f (a, ai) pa

 9k3 max(1, v2) .

Since the right-hand side is independent of , the result follows from Eq. (37.16).

37.8

Proof of the Classification Theorem

Almost all the results are now available to prove Theorem 37.11. In Section 37.4,

we showed that if G is globally observable and not locally observable, then

Rn (G) = (n2/3). We neighbours, then Rn (G)

=also(pnro).vTedhisthlaastt

if G is result is

locally observable and has complemented by the policy

and analysis in games Rn (G)

Sections 37.5 to = O(n2/3) and

37.7, where for locally

we showed that for observable games

globally Rn (G)

o=bsOer(vabnl)e.

Finally we proved that if G is not globally observable, then Rn (G) = (n). All

that remains is to prove that if G has no neighbouring actions, then Rn (G) = 0.

Theorem 37.22. If G has no neighbouring actions, then Rn (G) = 0.

Proof Since G has no neighbouring actions, there exists an action a such that Ca = Pd-1 and the policy that chooses At = a for all rounds suffers no regret.

37.9

Notes
1 The next three notes are covering some basic definitions and facts in linear algebra. There are probably hundreds of introductory texts on linear algebra. A short and intuitive exposition is by Axler [1997].
2 A non-empty set L  Rn is a linear subspace of Rn if v + w  L for all ,   R and v, w  L. If L and M are linear subspaces of Rn, then L  M = {v + w : L  L, w  M }. The orthogonal complement of linear subspace L is L = {v  Rn : u, v = 0 for all u  L}. The following properties are easily checked: (i) L is a linear subspace, (ii) (L) = L and (iii) (L  M ) = L  M .
3 Let A  Rm×n be a matrix and recall that matrices of this form correspond to linear maps from Rn  Rm where the function A : Rn  Rm is given by matrix multiplication, A(x) = Ax. The image of A is im(A) = {Ax : x  Rn}, and the kernel is ker(A) = {x  Rn : Ax = 0}. Notice that im(A)  Rm and ker(A)  Rn. One can easily check that im(A) and ker(A ) are linear subspaces,

37.9 Notes

502

and an elementary theorem in linear algebra says that im(A)  ker(A ) = Rm for any matrix A  Rm×n. Finally, if u  im(A) and v  ker(A ), then u, v = 0. 4 Given a set A  Rd, the affine hull is the set

j

j

aff(A) =

ixj : j > 0,   Rj, xi  A for all i  [j] and i = 1 .

i=1

i=1

Its dimension is the smallest m such that there exist vectors v1, . . . , vm  Rd such that aff(A) = x + span(v1, . . . , vm) for any x  A. 5 We introduced the stochastic variant of partial monitoring to prove our lower bounds. Of course our upper bounds also apply to this setting, which means the classification theorem also holds in the stochastic case. The interesting question is to understand the problem-dependent regret, which for partial monitoring problem G = (L, ) is

n

Rn(, u) = max E
a[k]

t=1

At - a, Ut

,

where U, U1, . . . , Un is a sequence of independent and identically distributed random vectors with Ut  {e1, . . . , ed} and E[U ] = u  Pd-1. Provided G is not hopeless, one can derive an algorithm for which the regret is logarithmic,
and like in bandits there is a sense of asymptotic optimality. The open research
question is to understand the in-between regime where the horizon is not yet
large enough that the asymptotically optimal logarithmic regret guarantees
become meaningful, but not so small that minimax is acceptable.
6 More generally, a stochastic partial monitoring problem by a probability kernel (P,a :   , a  A) from ( × A, F  G) to ( × R, H  B(R)). The environment chooses   , and the learner chooses (At)tn=1 with At  A and observes (t)tn=1 in a sequential manner, where (t, Xt)  P,At (·). The reward Xt of round t is unobserved. As before, the learner's goal is to maximise the total expected reward or, equivalently, to minimise regret. The special case
of the previous note is has been studied under the name of finite stochastic
partial monitoring. 7 The optimal tuning of the bound for Algorithm 26 depends on opt(), which
may be hard to compute. A simple way to address this problem is to use an
adaptive learning rate:

t = min

1 B

,

log(k)

1+

t-1 s=1

Vs

,

where Vt = max{0, optQt (t)} and B is chosen large enough that 1 is sufficiently small to satisfy the conditions needed in either Theorem 37.16
or Theorem 37.17. An excessively large B only affects the regret in an additive
fashion. The adaptive algorithm only needs to solve the optimisation in Eq. (37.12) and not opt(). Another benefit of the adaptive algorithm is

37.9 Notes

503

that it only depends on the game through the constant B. Furthermore, the bound depends on (Vt)nt=1, rather than opt(), which may sometimes be beneficial. The analysis of the algorithm uses the same techniques as developed in Exercise 28.13 and is given by Lattimore and Szepesva´ri [2019d]. 8 Algorithm 26 can be modified in several ways. One enhancement is to drop the constraint that f  E vec in the optimisation problem and introduce the worst case bias of f as a penalty. Certainly this does not make the bounds worse. A more significant change is to introduce a moment-generating function into the optimisation problem, which leads to high-probability bounds [Lattimore and Szepesva´ri, 2019d]. 9 The optimisation problem in Algorithm 26 is convex and can be solved using standard solvers when k and d are small and  is not too small. When  is small and/or k or d is large, then numerical instability is a real challenge. One way to address this issue is to approximate the exponential in the definition of q with a quadratic and add constraints on p and f that ensure the approximation is reasonable. Since the analysis uses p and f satisfying these conditions, none of the theory changes. What is bought by this approximation is that the resulting optimisation problem becomes a second order cone program, rather than an exponential cone program, and these are better behaved. More details are in our paper: [Lattimore and Szepesv´ari, 2019d]. 10 Partial monitoring has many potential applications. We already mentioned dynamic pricing and spam filtering. In the latter case, acquiring the true label comes at a price, which is a typical component of hard partial monitoring problems. In general, there are many set-ups where the learner can pay extra for high-quality information. For example, in medical diagnosis the doctor can request additional tests before recommending a treatment plan, but these cost time and money. Yet another potential application is quality testing in factory production where the quality control team can choose which items to test (at great cost). 11 There are many possible extensions to the partial monitoring framework. We have only discussed problems where the number of actions/feedbacks/outcomes is potentially infinite, but nothing prevents studying a more general setting. Suppose the learner chooses a sequence of real-valued outcomes i1, . . . , in with it  [0, 1]. In each round, the learner chooses At  [k] and observes At (it), where a : [0, 1]   is a known feedback function. The loss is determined by a collection of known functions La : [0, 1]  [0, 1]. We do not know of any systematic study of this setting. The reader can no doubt imagine generalising this idea to infinite action sets or introducing a linear structure for the loss. 12 A pair of Pareto-optimal actions (a, b) are called weak neighbours if Ca  Cb =  and pairwise observable if there exists a function g satisfying Eq. (37.3) and with g(c, f ) = 0 whenever c / {a, b}. A partial monitoring problem is called a point-locally observable game if all weak neighbours are pairwise observable. All point-locally observable games are locally observable, but the converse is not true. Bart´ok [2013] designed a policy for this type of

37.9 Notes

504

game for which

Rn



1 G

klocn log(n) ,

where G > 0 is a game-dependent constant and kloc is the size of the largest A  [k] of Pareto optimal actions such that aACa = . Using a different policy, Lattimore and Szepesva´ri [2019a] have shown that as the horizon grows, the game-dependence diminishes so that

lim sup
n

Rn n



8(2

+

m)

2kloc log(k) .

13 Linear regret is unavoidable in hopeless games, but that does not mean there is nothing to play for. Rustichini [1999] considered a version of the regret that captures the performance of policies in this harsh setting. Given p  Pd-1 define set I(p)  Pd-1 by
d
I(p) = q  Pd-1 : (pi - qi)I {ai = f } = 0 for all a  [k] and f  [m] .
i=1
This is the set of distributions over the outcomes that are indistinguishable from p by the learner using any actions. Then define

d
f (p) = max min qiLai .
qI(p) a[k] i=1
Rustichini [1999] proved there exist policies such that

lim max E
n i1:n

1 n

n

LAtit - f (u¯n)

t=1

= 0,

where

u¯n

=

1 n

n t=1

eit



Pd-1

is

the

average

outcome

chosen

by

the

adversary.

Intuitively this means the learner does not compete with the best action in

hindsight with respect to the actual outcomes. Instead, the learner competes

with the best action in hindsight with respect to an outcome sequence that is

indistinguishable from the actual outcome sequence. Rustichini did not prove

rates on the convergence of the limit. This has been remedied recently, and we

give some references in the bibliographic remarks.

14 Partial monitoring is still quite poorly understood. With some exceptions, we do not know how the regret should depend on d, k, m or the structure of G. Lower bounds that depend on these quantities are also missing, and the lower bounds proven in Section 37.4 are surely very conservative. We hope this chapter inspires more activity in this area. The setting described in Note 13 is even more wide open, where the dependence on n is still not nailed down.

37.10 Bibliographical Remarks

505

37.10 Bibliographical Remarks
The first work on partial monitoring is by Rustichini [1999], who focussed on finding Hannan consistent policies in the adversarial setting. Rustichini shows how to reduce the problem to Blackwell approachability (see Cesa-Bianchi and Lugosi [2006]) and uses this to deduce the existence of a Hannan consistent strategy. Rustichini also used a refined notion of regret that allows one to distinguish between learners even in the case of hopeless games (see Note 13). The first non-asymptotic result in the setting of this chapter is due to Piccolboni and Schindelhauer [2001], who derive a policy with regret O(n3/4) for globally observable games. Cesa-Bianchi et al. [2006] reduced the dependence to O(n2/3) and proved a wide range of other results for specific classes of problems. The first O(n1/2) bound for non-degenerate locally observable games is due to Foster and Rakhlin [2012]. The classification theorem when d = 2 is due to Bart´ok et al. [2010] (extended version: Antos et al. [2013]). With the exception of degenerate games, the classification of adversarial partial monitoring games is by Bart´ok et al. [2014]. The case of degenerate games was resolved by the present authors [Lattimore and Szepesva´ri, 2019a]. The policies mentioned in Note 12 are due to Bart´ok [2013] and Lattimore and Szepesv´ari [2019a]. We warn the reader that neighbours are defined differently by Foster and Rakhlin [2012] and Barto´k [2013], which can lead to confusion. Additionally, although both papers are largely correct, in both cases the core proofs contain errors that cannot be resolved without changing the policies [Lattimore and Szepesv´ari, 2019a]. Algorithm 26 and its analysis is also by the present authors [Lattimore and Szepesva´ri, 2019d], which is a followup on an earlier information-theoretic analysis [Lattimore and Szepesva´ri, 2019c].
There is a growing literature on the stochastic setting where it is common to study both minimax and asymptotic bounds. In the latter case, one can obtain asymptotically optimal logarithmic regret for games that are not hopeless. We refer the reader to papers by Bart´ok et al. [2012], Vanchinathan et al. [2014] and Komiyama et al. [2015b] as a good starting place. As we mentioned, partial monitoring can model problems that lie between bandits and full information. There are now several papers on this topic, but in more restricted settings and consequentially with more practical algorithms and bounds. One such model is when the learner is playing actions corresponding to vertices on a graph and observes the losses associated with the chosen vertex and its neighbours [Mannor and Shamir, 2011, Alon et al., 2013]. A related result is in the finite-armed Gaussian setting where the learner selects an action At  [k] and observes a Gaussian sample from each arm, but with variances depending on the chosen action. Like partial monitoring, this problem exhibits many challenges and is not yet well understood [Wu et al., 2015]. We mentioned in Note 13 that for hopeless games, the definition of the regret can be refined. A number of authors have studied this setting and proved sublinear regret guarantees. As usual, the price of generality is that the bounds are correspondingly a bit worse [Mannor

37.11 Exercises

506

and Shimkin, 2003, Perchet, 2011, Mannor et al., 2014]. There has been some work on infinite partial monitoring games. Lin et al. [2014] study a stochastic setting with finitely many actions, but infinitely many outcomes and a particular linear structure for the feedback. Chaudhuri and Tewari [2016] also consider a linear setting with global observability and prove O(n2/3 log(n)) regret using an explore-then-commit algorithm. Kirschner et al. [2020] study a version of information-directed sampling in partial monitoring setting with a linear feedback structure and finitely or infinitely many actions.
One can also add context, as usual. The special case of stochastic finite contextual partial monitoring has been considered by Bart´ok and Szepesv´ari [2012]. In this version, the learner is still given the matrices (L, ), but also a set of functions F that map a sequence (xt)t of contexts to outcome distributions, with the assumption that the outcome in round t is generated from f (xt) with f  F unknown to the learner. A special case, apple tasting with context (equivalently, matching pennies with context) is the subject of the paper of Helmbold et al. [2000]. The aforementioned paper by Kirschner et al. [2020] also studies the contextual partial monitoring problem in a linear setting.
37.11 Exercises
37.1 (Perspective) Prove that the perspective as defined in Eq. (37.14) is convex.
37.2 (Affine sets and dimension) Let X  Y  Rd and dim(X ) = dim(Y). Prove that aff(X ) = aff(Y).
37.3 (Modified kernel) Recall that ker (x) = {u : u x = 0 and u 1 = 1}. Show that if ker (x) = ker (y) =  then x and y are proportional.
37.4 (Structure of examples) Calculate the neighbourhood structure, cell decomposition and action classification for each of the examples in this chapter.
37.5 (Apple tasting) Apples arrive sequentially from the farm to a processing facility. Most apples are fine, but occasionally there is a rotten one. The only way to figure out whether an apple is good or rotten is to taste it. For some reason customers do not like bite marks in the apples they buy, which means that tested apples cannot be sold. Good apples yield a unit reward when sold, while the sale of a bad apple costs the company c > 0.
(a) Formulate this problem as a partial monitoring problem: determine L and . (b) What is the minimax regret in this problem? (c) What do you think about this problem? Will actual farmers be excited about
your analysis?
37.6 (Two-action partial monitoring games are trivial, hopeless or

37.11 Exercises

507

easy) Let G = (L, ) be a partial monitoring game with k = 2 actions. Prove that G is either trivial, hopeless or easy.

37.7 (Complete lower bound for hard games) Complete the last step in the proof of Theorem 37.12.

37.8 (Lower bound for easy games) Prove Theorem 37.14.

37.9 (Lower bound for hopeless games) Prove Theorem 37.13.

37.10 Let a and b be non-duplicate Pareto optimal actions and   ri(Ca). Show there exists an   ri(Cb) and neighbour c of b such that Cc  [, ] = .

Hint It may be useful to look at Fig. 37.6 to get some tips. The figure depicts a slightly different situation, but is still useful when it is changed a little.
37.11 Generalise the proofs of Lemma 37.20 and Lemma 37.21 to handle duplicate and degenerate actions.

37.12 Prove Proposition 37.18.

Hint For Part (a), let S  Rkm×d be obtained by stacking (Sc)kc=1, definedas in the proof of Theorem 37.12. Then argue that for globally observable games, d times the reciprocal of the smallest non-zero singular value of S is an upper bound on vglo and then use the fact that S S has integer-valued coefficients. Part (b) follows in a similar fashion. For Part (c), use a graph-theoretic argument.

37.13 Let m = || = 2 and d = 2k - 1 and construct a globally observable game for which there exists a pair of neighbouring actions a, b for which

min f
f Eagblo
where C > 0 is a universal constant.

 C2d/2 ,

37.14 Prove Proposition 37.19.

Hint Find choices of p and f that reduce the algorithm to Exp3 and exponential weights respectively.

37.15 (Lower bound depending on the number of feedbacks) Consider

G = (L, ) given by





L = 1 0 1 0 · · · 1 0

and

0 1 0 1 ··· 0 1





 = 1 2 2 3 3 4 · · · m - 1 m - 1 m  . 1 1 2 2 3 3 ··· m-2 m-1 m-1

37.11 Exercises

508

opt() 4

2

0 0.2 0.4 0.6 0.8 1 c
Figure 37.7 The value of opt() as a function of c in matching pennies (Example 37.3).

(a) Show this game is locally observable.

(b)

Prove Rn (G)

thact(mfor-n1)nm. ,

there

exists

a

universal

constant

c

>

0

such

that

The source for previous exercise is the paper by the authors [Lattimore and Szepesva´ri, 2019a].

37.16 (Divergence decomposition for partial monitoring) Complete the necessary modification of Lemma 15.1 to show that Eq. (37.8) is true.
37.17 (Algorithm for classifying games) Write a program that accepts as input matrices L and  and outputs the classification of the game.
37.18 (Implementation (i)) Implement a solver for the optimisation problem in Eq. (37.12). Consider the matching pennies problem (Example 37.3). Let  = 1/100 and plot opt() as a function of the cost c. Explain your results.
Hint The convex optimisation problem in Eq. (37.12) seems to cause problems for some solvers (see Note 9 for some mitigating strategies). We assume that many libraries can be made to work. Our implementation used the splitting cone solver by O'Donoghue et al. [2016, 2017]. Your plot should resemble Fig. 37.7.
37.19 (Implementation (ii)) In this exercise you will compare empirically or otherwise Algorithm 26 to exponential weights and Exp3 on full information and bandit games. Specifically:
(a) For full information games, exponential weights behaves like Algorithm 26 except that y^t = yt and Pt = Qt. Does the solution to the optimisation

37.11 Exercises

509

problem used by Algorithm 26 lead to the same loss estimators and distribution Pt? (b) For bandits, Exp3 uses y^ta = ytaI {At = a} /Pta. Does Algorithm 26 end up using the same loss estimators? Does Pt = Qt?
Hint You can approach this problem by using your solution to Exercise 37.18 and comparing values empirically. Alternatively, you can theoretically analyse Eq. (37.12) in these special cases. Some of these questions are answered by Lattimore and Szepesv´ari [2019d].

38 Markov Decision Processes

Bandit environments are a sensible model for many simple problems, but they do not model more complex environments where actions have long-term consequences. A brewing company needs to plan ahead when ordering ingredients, and the decisions made today affect their position to brew the right amount of beer in the future. A student learning mathematics benefits not only from the immediate reward of learning an interesting topic but also from their improved job prospects.
A Markov decision process (MDP) is a simple way to incorporate long-term planning into the bandit framework. Like in bandits, the learner chooses actions and receives rewards. But they also observe a state, and the rewards for different actions depend on the state. Furthermore, the actions chosen affect which state will be observed next.

38.1

Problem Set-Up
An MDP is defined by a tuple M = (S, A, P, r, µ). The first two items S and A are sets called the state space and action space, and S = |S| and A = |A| are their sizes, which may be infinite. An MDP is finite if S, A < . The quantity P = (Pa : a  A) is called the transition function with Pa : S × S  [0, 1] so that Pa(s, s ) is the probability that the learner transitions from state s to s when taking action a. The fourth element of the tuple is r = (ra : a  A), which is a collection of reward functions with ra : S  [0, 1]. When the learner takes action a in state s, it receives a deterministic reward of ra(s). The last element is µ  P(S), which is a distribution over the states that determines the starting state. The transition and reward functions are often represented by vectors or matrices. When the state space is finite, we may assume without loss of generality that S = [S]. We write Pa(s)  [0, 1]S as the probability vector with s th coordinate given by Pa(s, s ). In the same way, we let Pa  [0, 1]S×S be the right stochastic matrix with (Pa)s,s = Pa(s, s ). Finally, we view ra as a vector in [0, 1]S in the natural way.
The interaction protocol is similar to bandits. Before the game starts, the initial state S1 is sampled from µ. In each round t, the learner observes the state St  S, chooses an action At  A and receives reward rAt (St). The environment then

38.1 Problem Set-Up

511

samples St+1 from the probability vector PAt (St), and the next round begins (Fig. 38.1).
t = 1 and sample S1  µ

Observe state St

Choose action At  A

Increment t

Receive reward rAt (St)

Update St+1  PAt (St)

Figure 38.1 Interaction protocol for Markov decision processes.

Although the action set is the same in all states, this does not mean that Pa(s) or ra(s) has any relationship to Pa(s ) or ra(s ) for states s = s . In this sense, it might be better to use an entirely different set of actions for each state, which would not change the results we present. And while we are at it, of course one could also allow the number of actions to vary over the state space.

Histories and Policies Before considering the learning problem, we explain how to act in a known MDP. Because there is no learning going on, we call our protagonist the `agent' rather than `learner'. In a stochastic bandit, the optimal policy given knowledge of the bandit is to choose the action with the largest expected reward in every round. In an MDP, the definition of optimality is less clear.
The history Ht = (S1, A1, . . . , St-1, At-1, St) in round t contains the information available before the action for the round is to be chosen. Note that state St is included in Ht. The actions are also included because the agent may randomise. For simplicity the rewards are omitted because the all-knowing agent can recompute them if needed from the state-action pairs.
A policy is a (possibly randomised) map from the set of possible histories to actions. Simple policies include memoryless policies, which choose actions based on only the current state, possibly in a randomised manner. The set of such policies is denoted by M, and its elements are identified with maps  : A × S  [0, 1] with aA (a | s) = 1 for any s  S so that (a | s) is interpreted as the probability that policy  takes action a in state s.

38.1 Problem Set-Up

512

A memoryless policy that does not randomise is called a memoryless deterministic policy. To reduce clutter, such policies are written as S  A maps, and the set of all such policies is denoted by DM. A policy is called a Markov policy if the actions are randomised and depend only on the round index and the previous state. These policies are represented by fixed sequences of memoryless policies. Under a Markov policy, the sequence of states (S1, S2, . . . ) evolve as a Markov chain (see Section 3.2). If the Markov policy is memoryless, this chain is homogeneous.
1, 1
1, 1

1

trap state

high reward state

2 5

,

0

2

4 5

,

1

2 5

,

0

3 5

,

0

3

1 5

,

1

4 5

,

1

2 5

,

0

3 5

,

0

4

1 5

,

1

4 5

,

1

2 5

,

0

3 5

,

0

2 5

,

10

3 5

,

0

3 5

,

10

5

6

1 5

,

1

4 5

,

1

1 5

,

1

4 5

,

12

1 5

,

12

Figure 38.2 A Markov decision process with six states and two actions represented by solid and dashed arrows, respectively. The numbers next to each arrow represent the probability of transition and reward for the action respectively. For example, taking the solid action in state 3 results in a reward of 0, and the probability of moving to state 4 is 3/5, and the probability of moving to state 3 is 2/5. For human interpretability only, the actions are given consistent meaning across the states (blue/solid actions `increment' the state index, black/dashed actions decrement it). In reality there is no sense of similarity between states or actions built into the MDP formalism.

Probability Spaces It will be convenient to allow infinitely long interactions between the learner and the environment. In line with Fig. 38.1, when the agent or learner follows a policy  in MDP M = (S, A, P, r, µ), such a never-ending interaction gives rise to a random process (S1, A1, S2, A2, . . . ) so that for any s, s  S, a  A and t  1,
(a) P(S1 = s) = µ(s); (b) P(St+1 = s | Ht, At) = PAt (St, s ); and (c) P(At = a | Ht) = (a | Ht).
Meticulous readers may wonder whether there exists a probability space (, F, P) holding the infinite sequence of random variables (S1, A1, S2, A2, . . . ) that satisfy (a)­(c). The Ionescu­Tulcea theorem (Theorem 3.3) furnishes us with a positive answer (Exercise 38.1). Item (b) above is known as the Markov property. Of

38.1 Problem Set-Up

513

course the measure P depends on the policy, Markov decision process and the initial distribution. For most of the chapter, these quantities will be fixed and the
dependence is omitted from the notation. In the few places where disambiguation
is necessary, we provide additional notation. In addition to this, to minimise clutter, we allow ourselves to write P(· | S1 = s), which just means the probability distribution that results from the interconnection of  and M , while replacing µ
with an alternative initial state distribution that is a Dirac at s.

Traps and the Diameter of a Markov Decision Process A significant complication in MDPs is the potential for traps. A trap is a subset of the state space from which there is no escape. For example, the MDP in Fig. 38.2 has a trap state. If being in the trap has a suboptimal yield in terms of the reward, the learner should avoid the trap. But since the learner can only discover that an action leads to a trap by trying that action, the problem of learning while competing with a fully informed agent is hopeless (Exercise 38.28).
To avoid this complication, we restrict our attention to MDPs with no traps. An MDP is called strongly connected or communicating if for any pair of states s, s  S, there exists a policy such that when starting from s there is a positive probability of reaching s some time in the future while following the policy. One can also define a real-valued measure of the connectedness of an MDP called the diameter. MDPs with smaller diameter are usually easier to learn because a policy can recover from mistakes more quickly.

Definition 38.1. The diameter of an MDP M is

D(M )

=

max
s=s

min
DM

E

[min{t



1

:

St

=

s}

|

S1

=

s

]

-

1

,

where the expectation is taken with respect to the law of Markov chain (St) t=1 induced by the interaction between  and M .

A number of observations are in order about this definition. First, the order of the maximum and minimum means that for any pair of states a different policy may be used. Second, travel times are always minimised by deterministic memoryless policies, so the restriction to these policies in the minimum is inessential (Exercise 38.3). Finally, the definition only considers distinct states. We also note that when the number of states is finite, it holds that D(M ) <  if and only if M is strongly connected (Exercise 38.4). The diameter of an MDP with S states and A actions cannot be smaller than logA(S) - 3 (Exercise 38.5).

For the remainder of this chapter, unless otherwise specified, all MDPs are assumed to be strongly connected.

38.2 Optimal Policies and the Bellman Optimality Equation

514

38.2

Optimal Policies and the Bellman Optimality Equation

We now define the notion of an optimal policy and outline the proof that there exists a deterministic memoryless optimal policy. Along the way, we define what is called the Bellman optimality equation. Methods that solve this equation are the basis for finding optimal policies in an efficient manner and also play a significant role in learning algorithms. Throughout, we fix a strongly connected MDP M .
The gain of a policy  is the long-term average reward expected from using that policy when starting in state s:

s

=

lim
n

1 n

n

E[rAt (St) | S1 = s] ,

t=1

where E denotes the expectation on the interaction sequence when policy  interacts with MDP M . In general, the limit need not exist, so we also introduce

¯s

=

lim sup
n

1 n

n t=1

E[rAt (St)

|

S1

=

s]

,

which exists for any policy. Of course, whenever s exists we have s = ¯s . The optimal gain is a real value



=

max
sS

sup


¯s

,

where the supremum is taken over all policies. A  policy is an optimal policy if  = 1. For strongly connected MDPs, an optimal policy is guaranteed to
exist. This is far from trivial, however, and we will spend the next little while
outlining the proof.

MDPs that are not strongly connected may not have a constant optimal gain. This makes everything more complicated, and we are lucky not to have to deal with such MDPs here.

Before continuing, we need some new notation. For a memoryless policy , define

P(s, s ) = (a | s)Pa(s, s ) and r(s) = (a | s)ra(s) . (38.1)

aA

aA

We view P as an S × S transition matrix and r as a vector in RS. With this notation, P is the transition matrix of the homogeneous Markov chain S1, S2, . . . when At  (· | St). The gain of a memoryless policy  satisfies



=

lim
n

1 n

n

Pt-1r = Pr ,

t=1

(38.2)

where

P

=

limn

1 n

n t=1

Pt-1

is

called

the

stationary

transition

matrix,

38.2 Optimal Policies and the Bellman Optimality Equation

515

the existence of which you will prove in Exercise 38.7. For each k  N, define

k

v(k) =

Pt-1(r - ) .

t=1

For s  S, v(k)(s) gives the total expected excess reward collected by  when

the process starts at state s and lasts for k time steps. The (differential) value function of a policy is a function v : S  R defined as the Ces`aro sum of the sequence (Pt (r - ))t0,

v

=

lim
n

1 n

n

v(k) = ((I - P + P)-1 - P)r .

k=1

(38.3)

Note, the second equality above is non-trivial (Exercise 38.7). The definition implies that v(s) - v(s ) is the `average' long-term advantage of starting in state s relative to starting in state s when following policy . These quantities
are only defined for memoryless policies where they are also guaranteed to exist (Exercise 38.7). The definition of P implies that PP = P, which in turn implies that Pv = 0. Combining this with Eqs. (38.2) and (38.3) shows that for any memoryless policy ,

 + v = r + Pv .

(38.4)

A value function is a function v : S  R, and its span is given by

span(v) = max v(s) - min v(s) .

sS

sS

As with other quantities, value functions are associated with vectors in RS. A greedy policy with respect to value function v is a deterministic memoryless
policy v given by

v(s) = argmaxaA ra(s) + Pa(s), v .
There may be many policies that are greedy with respect to some value function v due to ties in the maximum. Usually the ties do not matter, but for consistency and for the sake of simplifying matters, we assume that ties are broken in a systematic fashion. In particular, this makes v well defined for any value function.
One way to find the optimal policy is as the greedy policy with respect to a value function that satisfies the Bellman optimality equation, which is



+

v(s)

=

max
aA

(ra(s)

+

Pa(s), v )

for all s  S .

(38.5)

This is a system of S nonlinear equations with unknowns   R and v  RS. The reader will notice that if v : S  R is a solution to Eq. (38.5), then so is v + c1 for any constant c  R, and hence the Bellman optimality equation lacks unique solutions. It is not true that the optimal value function is unique up to translation, even when M is strongly connected (Exercise 38.11). The v-part of a solution pair (, v) of Eq. (38.5) is called an optimal (differential) value function.

38.2 Optimal Policies and the Bellman Optimality Equation

516

Theorem 38.2. The following hold:

(a) There exists a pair (, v) that satisfies the Bellman optimality equation. (b) If (, v) satisfies the Bellman optimality equation, then  =  and v is
optimal.
(c) There exists a deterministic memoryless optimal policy.

Proof sketch The proof of part (a) is too long to include here, but we guide you
through it in Exercise 38.10. For part (b), let (, v) satisfy the Bellman equation and  = v be the greedy policy with respect to v. Then, by Eq. (38.2),



=

lim
n

1 n

n

Pt- 1r

=

lim
n

1 n

n

Pt- 1 (1 + v - P v) = 1 .

t=1

t=1

Next, let  be an arbitrary Markov policy. We show that ¯  1. The result is

then completed using the result of Exercise 38.2, where you will prove that for any

policy , there exists a Markov policy with the same expected rewards. Denote

by t the memoryless policy used at time t = 1, 2, . . . when following the Markov

policy , and for t  1, let P(t) = P1 . . . Pt , while for t = 0, let P(0) = I. Thus,

P(t)(s, s ) is the probability of ending up in state s while following  from state

s

for

t

time

steps.

It

follows

that

¯

=

lim

supn

1 n

n t=1

P(t-1)rt .

Fix

t



1.

Using the fact that  is the greedy policy with respect to v gives

P(t-1)rt = P(t-1)(rt + Pt v - Pt v)  P(t-1)(r + P v - Pt v) = P(t-1)(1 + v - Pt v) = 1 + P(t-1)v - P(t)v .

Taking the average of both sides over t  [n] and then taking the limit shows that ¯  1, finishing the proof. Part (c) follows immediately from the first
two parts.

The theorem shows that there exist solutions to the Bellman optimality equation and that the greedy policy with respect to the resulting value function is an optimal policy. We need one more result about solutions to the Bellman optimality equation, the proof of which you will provide in Exercise 38.13.

Lemma 38.3. Suppose that (, v) satisfies the Bellman optimality equation. Then span(v)  D(M ).

The map T : RS  RS defined by (T v)(s) = maxaA ra(s) + Pa(s), v is called the Bellman operator. The Bellman optimality equation can be
written as 1 + v = T v.

38.3 Finding an Optimal Policy ( )

517

38.3

Finding an Optimal Policy ( )

There are many ways to find an optimal policy, including value iteration, policy iteration and enumeration. These ideas are briefly discussed in Note 12. Here we describe a two-step approach based on linear programming. Consider the following constrained linear optimisation problem:

minimise 
R,vRS
subject to  + v(s)  ra(s) + Pa(s), v for all s, a .

(38.6)

Recall that a constrained optimisation problem is said to be feasible if the set of values that satisfy the constraints are non-empty.

Theorem 38.4. The optimisation problem in Eq. (38.6) is feasible, and if (, v) is a solution, then  =  is the optimal gain.

Solutions (, v) to the optimisation problem in Eq. (38.6) need not satisfy the Bellman optimality equation (Exercise 38.12).

Proof of Theorem 38.4 Theorem 38.2 guarantees the existence of a pair (, v) that satisfies the Bellman optimality equation:



+

v(s)

=

max
aA

ra(s)

+

Pa(s), v

for all s, a .

Hence the pair (, v) satisfies the constraints in Eq. (38.6) and witnesses
feasibility. Next, let (, v) be a solution of Eq. (38.6). Since (, v) satisfies the
constraints,    is immediate. It remains to prove that   . Let  = v be the greedy policy with respect to v and  be greedy with respect to v. By Theorem 38.2,  =  . Furthermore,

Pt r  Pt (r + Pv - P v)  Pt (1 + v - P v) = 1 + Pt v - Pt+ 1v .

Summing

over

t

shows

that

1

=

limn

1 n

n-1 t=0

Pt r



1,

which

completes

the proof.

Having found the optimal gain, the next step is to find a value function that satisfies the Bellman optimality equation. Let s~  S, and consider the following linear program:

minimise v, 1
vRS
subject to  + v(s)  ra(s) + Pa(s), v for all s, a v(s~) = 0 .

(38.7)

The second constraint is crucial in order for the minimum to exist, since otherwise the value function can be arbitrarily small.

38.3 Finding an Optimal Policy ( )

518

Theorem 38.5. There exists a state s~  S such that the solution v of Eq. (38.7) satisfies the Bellman optimality equation.
Proof The result follows by showing that  = v + 1 - T v = 0. The first constraint in Eq. (38.7) ensures that   0. It remains to show that   0. Let  be an optimal policy and  be the greedy policy with respect to v. Then
Pt r  Pt (r + Pv - P v) = Pt (1 + v -  - P v) .
Hence 1 =  1  1 - P  and P   0. Since   0 and P is right stochastic, P  = 0. Choose s~ to be a state such that P (s, s~) > 0 for some s  S, which exists because P is right stochastic. Then 0 = (P )(s)  P (s, s~)(s~) and hence (s~) = 0. It follows that v~ = v -  also satisfies the constraints in Eq. (38.7). Because v is a solution to Eq. (38.7), v~, 1  v, 1 , implying that , 1  0. Since we already showed that   0, it follows that  = 0.
The theorem only demonstrates the existence of a state s~ for which the solution of Eq. (38.7) satisfies the Bellman optimality equation. There is a relatively simple procedure for finding such a state using the solution to Eq. (38.6), but its analysis depends on the basic theory of duality from linear programming, which is beyond the scope of this text. More details are in Note 11 at the end of the chapter. Instead we observe that one can simply solve Eq. (38.7) for all choices of s~ and take the first solution that satisfies the Bellman optimality equation.

38.3.1

Efficient Computation
The linear programs in Eq. (38.6) and Eq. (38.7) can be solved efficiently under assumptions that will be satisfied in subsequent applications.

The algorithm proposed in this subsection is guaranteed to run in polynomial time, which is a standard objective in theoretical computer science. Its practical performance, however, is usually much worse than alternatives that suffer from exponential running time in the worst case. These issues are discussed in Note 12 at the end of the chapter.

The general form of a linear program is an optimisation problem of the form
minimise c, x
xRn
subject to Ax  b ,
where c  Rn and A  Rm×n and b  Rm are parameters of the problem. This general problem can be solved in time that depends polynomially on n and m. When m is very large or infinite, these algorithms may become impractical, but nevertheless one can often still solve the optimisation problem in time polynomial

38.3 Finding an Optimal Policy ( )

519

in n only, provided that the constraints satisfy certain structural properties. Let K  Rn be convex, and consider the optimisation problem

minimise c, x
xRn
subject to x  K .

(38.8)

Algorithms for this problem generally have a slightly different flavour because K may have no corners. Suppose the following holds:

(a) There exists a known R > 0 such that K  {x  Rn : x 2  R}. (b) There exists a separation oracle, which we recall from Chapter 27, is a
computational procedure to evaluate some function  on Rn with (x) = true for x  K, and otherwise (x) = u with y, u > x, u for all y  K
(see Fig. 27.1). (c) There exists a  > 0 and x0  Rd such that {x  Rn : x - x0 2  }  K.

Under these circumstances, the ellipsoid method accepts as input the size of the
bounding sphere R, the separation oracle and an accuracy parameter  > 0. Its output is a point x in time polynomial in n and log(R/()) such that x  K and c, x  c, x + , where x is the minimiser of Eq. (38.8). The reader can find
references to this method at the end of the chapter.
The linear programs in Eq. (38.6) and Eq. (38.7) do not have bounded feasible regions because if v is feasible, then v + c1 is also feasible for any c  R. For strongly connected MDPs with diameter D, however, Lemma 38.3 allows us to add the constraint that v   D. If the rewards are bounded in [0, 1], then we may also add the constraint that 0    1. Together these imply that for (, )
in the feasible region,

(, v)

2 2

= 2 +

v

2 2

1+S

v

2 



1

+

SD2

.

 Then set R = 1 + D2S. When the diameter is unknown, one may use a doubling

procedure. In order to guarantee the feasible region contains a small ball, we

add some slack to the constraints. Let  > 0, and consider the following linear

program:

minimise 
R,vRS
subject to  +  + v(s)  ra(s) + Pa(s), v for all s, a . v(s)  -D for all s v(s)  D for all s   1 +  for all s   - for all s .

(38.9)

Note that for any x in the feasible region of Eq. (38.9), there exists a y that is feasible for Eq. (38.6) with x - y   . Furthermore, the solution to the above linear program is at most  away from the solution to Eq. (38.6). What we have

38.4 Learning in Markov Decision Processes

520

bought by adding this slack is that now the linear program in Eq. (38.9) satisfies the conditions (a) and (c) above. The final step is to give a condition when a separation oracle exists for the convex set determined by the constraints in the above program. Define convex set K by
K = {(, v)  Rd+1 :  +  + v(s)  ra(s) + Pa(s), v for all s, a} . (38.10)

Assuming that

argmaxaA(ra(s) + Pa(s), v )

(38.11)

can be solved efficiently, Algorithm 27 provides a separation oracle for K. For the

specialised case considered later, Eq. (38.11) is trivial to compute efficiently. The

feasible region defined by the constraints in Eq. (38.9) is the intersection of K with

a small number of half-spaces. In Exercise 38.15, you will show how to efficiently

extend a separation oracle for arbitrary convex set K to

n i=1

Hk



K,

where

(Hk)kn=1 are half-spaces. You will show in Exercise 38.14 that approximately

solving Eq. (38.7) works in the same way as above, as well as the correctness of

Algorithm 27.

In Theorem 38.2, we assumed an exact solution of the Bellman optimality equation, which may not be possible in practice. Fortunately, approximate solutions to the Bellman optimality equation with approximately greedy policies yield approximately optimal policies. Details are deferred to Exercise 38.16.

1: function SeparationOracle(, v)

2: For each s  S find as  argmaxa(ra(s) + Pa(s), v )

3: if  +  + v(s)  ras (s) + Pas (s), v for all s  S then

4:

return true

5: else

6:

Find state s with  +  + v(s) < ras (s) + Pas (s), v

7:

return (1, es - Pas (s))

8: end if

9: end function

Algorithm 27: Separation oracle for Eq. (38.6).

38.4

Learning in Markov Decision Processes
The problem of finding an optimal policy in an unknown MDP is no longer just an optimisation problem, and the notion of regret is introduced to measure the price of the uncertainty. For simplicity we assume that only the transition matrix

38.5 Upper Confidence Bounds for Reinforcement Learning

521

is unknown while the reward function is given. This assumption is not especially restrictive as the case where the rewards are also unknown is easily covered using either a reduction or a simple generalisation, as we explain in the notes. The regret of a policy  is the deficit of rewards suffered relative to the expected average reward of an optimal policy:
n
R^n = n - rAt (St) .
t=1
The reader will notice we are comparing the non-random n to the random sum of rewards received by the learner, which was also true in the study of stochastic bandits. The difference is that  is an asymptotic quantity while for stochastic bandits the analogous quantity was nµ. The definition stills makes sense, however, because for MDPs with finite diameter D the optimal expected cumulative reward over n rounds is at least n - D so the difference is negligible (Exercise 38.17). The main result of this chapter is the following:

Theorem 38.6. Let S, A and n be natural numbers and   (0, 1). There exists an efficiently computable policy  that when interacting with any MDP M = (S, A, P, r) with S states, A actions, rewards in [0, 1] and any initial state distribution satisfies with probability at least 1 - ,
R^n < CD(M )S An log(nSA/) ,
where C is a universal constant.

In Exercise 38.18, we ask you to use the assumption that the rewards are bounded to find a choice of   (0, 1) such that

E[R^n]  1 + CD(M )S 2An log(n) .

(38.12)

This result is complemented by the following lower bound:

Theorem 38.7. Let S  3, A  2, D  6 + 2 logA S and n  DSA. Then for any policy  there exists a Markov decision process with S states, A actions and

diameter at most D such that

E[R^n]



 C DSAn

,

where C > 0 is again a universal constant. 
The upper and lower bounds are separated by a factor of at least DS, which
is a considerable gap. Recent work has made progress towards closing this gap as
we explain in the notes.

38.5

Upper Confidence Bounds for Reinforcement Learning
Reinforcement learning is the subfield of machine learning devoted to designing and studying algorithms that learn to maximise long-term reward

38.5 Upper Confidence Bounds for Reinforcement Learning

522

in sequential context. The algorithm that establishes Theorem 38.6 is called UCRL2 because it is the second version of the `upper confidence bounds for reinforcement learning' algorithm. Its pseudocode is shown in Algorithm 28.
At the start of each phase, UCRL2 computes an optimal policy for the statistically plausible MDP with the largest optimal gain. The details of this computation are left to the next section. This policy is then implemented until the number of visits to some state-action pair doubles when a new phase starts and the process begins again. The use of phases is important, not just for computational efficiency. Recalculating the optimistic policy in each round may lead to a dithering behaviour in which the algorithm frequently changes its plan and suffers linear regret (Exercise 38.19).
To complete the specification of the algorithm, we must define confidence sets on the unknown quantity, which in this case is the transition matrix. The confidence sets are centered at the empirical transition probabilities defined by

P^t,a(s, s ) =

t u=1

I

{Su

= s, Au = a, 1  Tt(s, a)

Su+1

=

s

}

,

where taken

Tt(s, a) = in state s.

t u=1

I

{Su

As before,

= s, Au we let

= a} is P^t,a(s)

the number of times be the vector whose

action a was s th entry is

P^t,a(s, s ). Given a state-action pair s, a, define

Ct(s, a) = P  P(S) : P - P^t-1,a(s) 1 

SLt-1(s, a) 1  Tt-1(s, a)

,

(38.13)

where for Tt(s, a) > 0 we set

Lt(s, a) = 2 log

4SATt(s, a)(1 + Tt(s, a)) 

,

and for Tt(s, a) = 0 we set Lt(s, a) = 1. Note that in this case Ct+1(s, a) = P(S). Then define

Ct = {P = (Pa(s))s,a : Pa(s)  Ct(s, a) for all s, a  S × A} .

(38.14)

Clearly Tt(s, a) cannot be larger than the total number of rounds n, so

Lt(s, a)  L = 2 log

4SAn(n + 1) 

.

(38.15)

The algorithm operates in phases k = 1, 2, 3, . . . with the first phase starting in round 1 = 1 and the (k + 1)th phase starting in round k+1 defined inductively by

k+1 = 1 + min {t : Tt(St, At)  2Tk-1(St, At)} ,
which means that the next phase starts once the number of visits to some state-action pair at least doubles.

38.5 Upper Confidence Bounds for Reinforcement Learning

523

1: Input S, A, r,   (0, 1)

2: t = 0

3: for k = 1, 2, . . . do

4: k = t + 1

5: Find k as the greedy policy with respect to vk satisfying Eq. (38.16)

6: do

7:

t  t + 1, observe St and take action At = k(St)

8: while Tt(St, At) < 2Tk-1(St, At) 9: end for

Algorithm 28: UCRL2.

38.5.1

The Extended Markov Decision Process

The confidence set Ct defines a set of plausible transition probability functions at the start of round t. Since the reward function is known already, this corresponds to a set of plausible MDPs. The algorithm plays according to the optimal policy in the plausible MDP with the largest gain. There is some subtlety because the optimal policy is not unique, and what is really needed is to find a policy that is greedy with respect to a value function satisfying the Bellman optimality equation in the plausible MDP with the largest gain. Precisely, at the start of the kth phase, the algorithm must find a value function vk, gain k and MDP Mk = (S, A, Pk, r) with Pk  Ck such that

k

+

vk (s)

=

max
aA

ra(s)

+

Pk,a(s), vk

for all s  S and a  A ,

k

=

max max
sS DM

max
P Ck

s (P ) ,

(38.16)

where s (P ) is the gain of deterministic memoryless policy  starting in state s in the MDP with transition probability function P . The algorithm then plays
according to k defined as the greedy policy with respect to vk. There is quite a lot hidden in these equations. The gain is only guaranteed to be constant when
Mk has a finite diameter, but this may not hold for all plausible MDPs. As it happens, however, solutions to Eq. (38.16) are guaranteed to exist and can be found efficiently. To see why this is true we introduce the extended MDP M~k, which has state space S and state-dependent action space A~s given by

A~s = {(a, P ) : a  A, P  Ck (s, a)} .

The reward function of the extended MDP is r~(a,P )(s) = ra(s), and the transitions are P~a,P (s) = Pa(s). The action space in the extended MDP allows the agent to choose both a  A and a plausible transition vector Pa(s)  Ck (s, a). By the definition of the confidence sets, for any pair of states s, s and action a  A, there always exists a transition vector Pa(s)  Ck (s, a) such that Pa(s, s ) > 0, which means that M~k is strongly connected. Hence solving the Bellman optimality equation for M~k yields a value function vk and constant gain k  R that satisfy

38.6 Proof of Upper Bound

524

Eq. (38.16). A minor detail is that the extended action sets are infinite, while the analysis in previous sections only demonstrated existence of solutions to the Bellman optimality equation for finite MDPs. You should convince yourself that Ct(s, a) is convex and has finitely many extremal points. Restricting the confidence sets to these points makes the extended MDP finite without changing the optimal policy.

38.5.2

Computing the Optimistic Policy ( )
Here we explain how to efficiently solve the Bellman optimality equation for the extended MDP. The results in Section 38.3 show that the Bellman optimality equation for M~k can be solved efficiently provided that for any value function v  RS computing

argmaxaA

ra(s) + max P, v
P Ck (s,a)

(38.17)

can be carried out in an efficient manner. The inner optimisation is another linear

program with S variables and O(S) constraints and can be solved in polynomial

time. This procedure is repeated for each a  A to compute the outcome of

(38.17). In fact the inner optimisation can be solved more straightforwardly by

sorting the entries of v and then allocating P coordinate by coordinate to be as

large as allowed by the constraints in decreasing order of v. The total computation

cost of solving Eq. (38.17) in this way is O(S(A + log S)). Combining this with

Algorithm 27 gives the required separation oracle.

The next problem is to find an R such that the set of feasible solutions to the

linear programs in Eq. (38.6) and Eq. (38.7) are contained inthe set {x : x  R}. As discussed in Section 38.3.1, a suitable value is R = 1 + D2S, where D is an upper bound on the diameter of the MDP. It turns out that D = n works

because for such that P

each pair (s, s )  1

of(1st/atens)

s, s , there so D(M~ k)

exisnts.

an action a and P  Ck (s, a) Combining this with the tools

developed in Section 38.3 shows that the Bellman optimality equation for M~k may

be solved using linear programming in polynomial time. Note that the additional

constraints require a minor adaptation of the separation oracle, which we leave

to the reader.

38.6

Proof of Upper Bound
The proof is developed in three steps. First we decompose the regret into phases and define a failure event where the confidence intervals fail. In the second step, we bound the regret in each phase, and in the third step we sum over the phases. Recall that M = (S, A, P, r) is the true Markov decision process with diameter D = D(M ). The initial state distribution is µ  P(S), which is arbitrary.

38.6 Proof of Upper Bound

525

Step 1: Failure Events and Decomposition
Let K be the (random) number of phases, and for k  [K], let Ek = {k, k + 1, . . . , k+1 - 1} be the set of rounds in the kth phase, where K+1 is defined to be n + 1. Let T(k)(s, a) be the number of times state-action pair s, a is visited in the kth phase:

T(k)(s, a) =

I {St = s, At = a} .

tEk

Define F as the failure event that P / Ck for some k  [K].

Lemma 38.8. P (F )  /2 .

The proof is based on a concentration inequality derived for categorical
distributions and is left for Exercise 38.21. When F does not hold, the true transition kernel is in Ck for all k, which means that   k and

n

K

R^n = ( - rAt (St)) 

(k - rAt (St)) .

t=1

k=1 tEk

R~k

In the next step, we bound R~k under the assumption that F does not hold.

Step 2: Bounding the Regret in Each Phase Assume that F does not occur and fix k  [K]. Recall that vk is a value function satisfying the Bellman optimality equation in the optimistic MDP Mk and k is its gain. Hence

k = rk (s) - vk(s) + Pk,k (s), vk for all s  S .

(38.18)

As noted earlier, solutions to the Bellman optimality equation remain solutions when translated, so we may assume without loss of generality that vk is such that
vk   span(vk)/2, which means that

vk



1 2

span(vk)



D 2

,

(38.19)

where the second inequality follows from Lemma 38.3 and the fact that when F does not hold, the diameter of the extended MDP M~k is at most D and vk also
satisfies the Bellman optimality equation in this MDP. By the definition of the
policy, we have At = k(St) for t  Ek, which implies that

k = rAt (St) - vk(St) + Pk,At (St), vk for all t  Ek .

38.6 Proof of Upper Bound

526

Rearranging and substituting yields

R~k =

(-vk(St) + Pk,At (St), vk )

tEk

=

(-vk(St) + PAt (St), vk ) +

Pk,At (St) - PAt (St), vk

tEk

tEk



(-vk(St) +

PAt (St), vk

)

+

D 2

Pk,At (St) - PAt (St) 1 , (38.20)

tEk

tEk

(A)

(B)

where the inequality follows from H¨older's inequality and Eq. (38.19). Let Et[·] denote the conditional expectation with respect to P conditioned on
(S1, A1, . . . , St-1, At-1, St). To bound (A), we reorder the terms and use the fact that span(vk)  D on the event F c. We get

(A) =

(vk(St+1) - vk(St) + PAt (St), vk - vk(St+1))

tEk

= vk(Sk+1 ) - vk(Sk ) +

( PAt (St), vk - vk(St+1))

tEk

D+

(Et[vk(St+1)] - vk(St+1)) ,

tEk

where the second equality used that max Ek = k+1 - 1 and min Ek = k. We leave this here for now and move on to term (B) in Eq. (38.20). The definition of

the confidence intervals and the assumption that F does not occur shows that



(B)



D

LS 2

(s,a)S ×A

T(k)(s, a)

.

1  Tk-1(s, a)

Combining the bounds (A) and (B) yields



R~k



D

+

tEk

(Et [vk (St+1 )]

-

vk (St+1 ))

+

D

LS 2

(s,a)S ×A

T(k)(s, a)

.

1  Tk-1(s, a)

Step 3: Bounding the Number of Phases and Summing Let Kt be the phase in round t so that t  EKt . By the work in the previous two steps, if F does not occur, then

K

n

R^n  R~k  KD + (Et[vKt (St+1)] - vKt (St+1))

k=1

t=1



+

D

LS 2

K

(s,a)S×A k=1

T(k)(s, a)

.

1  Tk-1(s, a)

38.7 Proof of Lower Bound

527

The first sum is bounded using a version of Hoeffding­Azuma (Exercise 20.7):

n

P F c and

(Et[vKt (St+1)] - vKt (St+1))  D

t=1

n log(2/) 2



 2

.

For the second term, we note that T(k)(s, a)/ 1  Tk-1(s, a) cannot be large too often. A continuous approximation often provides intuition for the correct
form. Recalling the thousands of integrals you did at school, for any differentiable f : [0, )  R,

K f (k) dk = 2 f (K) - 2 f (0) . 0 f (k)

(38.21)

Here we are thinking of f (k) as the continuous approximation of Tk-1(s, a) and its derivative as T(k)(s, a). In Exercise 38.22, we ask you to make this argument rigourous by showing that

K

T(k)(s, a)

  2+1

k=1 1  Tk-1(s, a)

Tn(s, a) .

Then by Cauchy­Schwarz and the fact that s,aS×A Tn(s, a) = n, 
Tn(s, a)  SAn .
sS aA

It remains to bound the number of phases. A new phase starts when the visit

count for some state-action pair doubles. Hence K cannot be more than the

number of times the counters double in total for each of the states. It is easy to

see that 1 + log2 Tn(s, a) gives an upper bound on how many times the counter for this pair may double (the constant 1 is there to account for the counter

changing from zero to one). Thus K  K = s,a 1 + log2 Tn(s, a). Noting that 0  Tn(s, a) and s,a Tn(s, a) = n and relaxing Tn(s, a) to take real values, we find that the value of K is the largest when Tn(s, a) = n/(SA), which shows that

K  SA

1 + log2

n SA

.

Putting everything together gives the desired result.

38.7

Proof of Lower Bound
The lower bound is proven by crafting a difficult MDP that models a bandit with approximately SA arms. This is a cumbersome endeavour, but intuitively straightforward, and the explanations that follow should be made clear in Fig. 38.3. Given S and A, the first step is to construct a tree of minimum depth with at most A children for each node using exactly S - 2 states. The root of the tree is denoted by s and transitions within the tree are deterministic, so in any given node, the learner can simply select which child to transition to. Let L be the

38.7 Proof of Lower Bound

528

number of leaves, and label these states s1, . . . , sL. The last two states are sg and sb (`good' and `bad' respectively). For each i  [L], the learner can take any action a  A and transitions to either the good state or the bad state according to

Pa(si, sg)

=

1 2

+

(a, i)

and

Pa(si, sb)

=

1 2

- (a, i) .

The function  will be chosen so that (a, i) = 0 for all (a, i) pairs except one. For this special state-action pair, we let (a, i) =  for appropriately tuned  > 0. The good state and the bad state have the same transitions for all actions:

Pa(sg, sg) = 1 -  , Pa(sb, sb) = 1 -  ,

Pa(sg, s) =  , Pa(sb, s) =  .

Choosing  = 4/D, which under the assumptions of the theorem is guaranteed to be in (0, 1], ensures that the diameter of the described MDP is at most D, regardless of the value of . The reward function is ra(s) = 1 if s = sg and ra(s) = 0 otherwise.
The connection to finite-armed bandits is straightforward. Each time the learner arrives in state s, it selects which leaf to visit and then chooses an action from that leaf. This corresponds to choosing one of k = LA = (SA) meta actions. The optimal policy is to select the meta action with the largest probability of transitioning to the good state. The choice of  means the learner expects to stay in the good/bad state for approximately D rounds, which also makes the diameter of this MDP about D. This means the learner expects to make about n/D decisions and the rewardsare roughly in [0, D], so we should expect the regret to be (D kn/D) = ( nDSA).

s

, 1

s1

s2

, 0 s3

Good state

sg 1 - , 1

sb 1 - , 0

Bad state

Figure 38.3 Lower-bound construction for A = 2 and S = 8. The resulting MDP is roughly equivalent to a bandit with six actions.

38.7 Proof of Lower Bound

529

One could almost claim victory here and not bother with the proof. As usual, however, there are some technical difficulties, which in this case arise because the number of visits to the decision state s is a random quantity. For this reason we give the proof, leaving as exercises the parts that are both obvious and annoying.
Proof of Theorem 38.7 The proof follows the path suggested in Exercise 15.2. We break things up into two steps. Throughout we fix an arbitrary policy .

Step 1: Notation and Facts about the MDP Let d be the depth of the tree in the MDP construction, L the number of leaves and k = LA. Define the set of state­action pairs for which the state is a leaf of the tree by

L = {(s, a) : a  A and s is a leaf of the tree} .

By definition, this has k elements. Let M0 be the MDP with (s, a) = 0 for all (s, a)  L. Then let Mj be the MDP with (s, a) =  for the jth state-action pair in the above set. Define stopping time  by

 = n  min

t

:

t
I {Su
u=1

=

s}



n D

-

1

,

which is the first round when the number of visits to state s is at least n/D - 1,

or n if s is visited fewer times than n/D. Next, let Tj be the number of visits to

state-action pair j  [k] until stopping time  and T =

k j=1

Tj .

For

0



j



k,

let Pj be the law of T1, . . . , Tk induced by the interaction of  and Mj. And

let Ej[·] be the expectation with respect to Pj. None of the following claims is

surprising, but they are all tiresome to prove to some extent. The claims are

listed in increasing order of difficulty and left to the reader in Exercise 38.24.

Claim 38.9. For all j  [k], the diameter is bounded by D(Mj)  D . Claim 38.10. There exist universal constants 0 < c1 < c2 <  such that
DE0[T]/n  [c1, c2] .

Claim 38.11. Let Rnj be the expected regret of policy  in MDP Mj over n rounds. There exists a universal constant c3 > 0 such that
Rnj  c3D Ej [T - Tj ] .

Step 2: Bounding the Regret Notice that M0 and Mj only differ when state-action pair j is visited. In Exercise 38.30, you are invited to use this fact and the chain rule for relative entropy given in Exercise 14.12 to prove that

D(P0, Pj) = E0[Tj]d(1/2, 1/2 + ) ,

(38.22)

38.8 Notes

530

where d(p, q) is the relative entropy between Bernoulli distributions with means p and q, respectively. Now  will be chosen to satisfy   1/4. It follows from the entropy inequalities in Eq. (14.16) that

D(P0, Pj)  42E0[Tj] .

(38.23)

Using the fact that 0  T - Tj  T  n/D, Exercise 14.4 and Pinsker's inequality (Eq. (14.12)) and (38.23),

Ej

[T

-

Tj ]



E0

[T

-

Tj ]

-

n D

D(P0, Pj) 2



E0

[T

-

Tj ]

-

n D

Summing over j and applying Cauchy­Schwarz yields

2E0[Tj] .

k

Ej [T - Tj] 

k

E0

[T

-

Tj ]

-

n D

k

j=1

j=1

j=1

2E0 [Tj ]



(k

-

1)E0

[T ]

-

n D

2kE0 [T ]

 c1n(k - 1) - n 2c2nk

D

DD



c1n(k - 2D

1)

,

where the last inequality follows by choosing

(38.24)



=

c1(k - 2

1)

D 2c2nk

.

By Eq. (38.24), there exists a j  [k] such that

Ej

[T

-

Tj ]



c1n(k - 2Dk

1)

.

Then, for the last step, apply Claim 38.11 to show that

Rnj



c3DEj [T

- Tj]



c12c3n(k - 1)2 4k

Naive bounding and simplification concludes the proof.

D 2c2nk

.

38.8

Notes
1 MDPs in applications can have millions (or `billions and billions') of states, which should make the reader worried that the bound in Theorem 38.6 could be extremely large. The takeaway should be that learning in large MDPs without additional assumptions is hard, as attested by the lower bound in Theorem 38.7.

38.8 Notes

531

2 The key to choosing the state space is that the state must be observable and sufficiently informative that the Markov property is satisfied. Blowing up the size of the state space may help to increase the fidelity of the approximation (the entire history always works), but will almost always slow down learning.
3 We simplified the definition of MDPs by making the rewards a deterministic function of the current state and the action chosen. A more general definition allows the rewards to evolve in a random fashion, jointly with the next state. In this definition, the mean reward functions are dropped and the transition kernel Pa is replaced with an S  S × R stochastic kernel, call it, P~a. Thus, for every s  S, P~a(s) is a probability measure over S × R. The meaning of this is that when action a is chosen in state s, a random transition, (S, R)  P~a(s) happens to state S, while reward R is received. Note that the mean reward along this transition is ra(s) = xP~a(s, ds , dx).
4 A state s  S is absorbing if Pa(s, s) = 1 for all a  A. An MDP is episodic if there exists an absorbing state that is reached almost surely by any policy. The average reward criterion is meaningless in episodic MDPs because all policies are optimal. In this case the usual objective is to maximise the expected reward until the absorbing state is reached without limits or normalisation, sometimes with discounting. An MDP is finite-horizon if it is episodic and the absorbing state is always reached after some fixed number of rounds. The simplification of the setting eases the analysis and preserves most of the intuition from the general setting.
5 A partially observable MDP (POMDP) is a generalisation where the learner does not observe the underlying state. Instead they receive an observation that is a (possibly random) function of the state. Given a fixed (known) initial state distribution, any POMDP can be mapped to an MDP at the price of enlarging the state space. A simple way to achieve this is to let the new state space be the space of all histories. Alternatively you can use any sufficient statistic for the hidden state as the state. A natural choice is the posterior distribution over the hidden state given the interaction history, which is called the belief space. While the value function over the belief space has some nice structure, in general even computing the optimal policy is hard [Papadimitriou and Tsitsiklis, 1987].
6 We called the all-knowing entity that interacts with the MDP an agent. In operations research the term is decision maker and in control theory it is controller. In control theory the environment would be called the controlled system or the plant (for power-plant, not a biological plant). Acting in an MDP is studied in control theory under stochastic optimal control, while in operations research the area is called multistage decision making under uncertainty or multistage stochastic programming. In the control community the infinite horizon setting with the average cost criterion is perhaps the most common, while in operations research the episodic setting is typical.
7 The definition of the optimal gain that is appropriate for MDPs that are not strongly connected is a vector   RS given by s = sup ¯s. A policy is

38.8 Notes

532

optimal if it achieves the supremum in this definition and such a policy always

exists as long as the MDP is finite. In strongly connected MDPs, the two

definitions coincide. For infinite MDPs, everything becomes more delicate and

a large portion of the literature on MDPs is devoted to this case.

8 In applications where the asymptotic nature of gain optimality is unacceptable,

there are criteria that make finer distinctions between the policies. A memoryless

policy  is bias optimal if it is gain optimal and v  v for all memoryless

policies . Even more sensitive criteria exist. Some keywords to search for are

Blackwell optimality and n-discount optimality.

9 The Ces`aro sum of a real-valued sequence (an)n is the asymptotic average of

its partial sums. Let sn = a0 + · · · + an-1 be the nth partial sum. The Cesa`ro

sum

of

this

sequence

is

A

=

limn

1 n

(s1

+

···

+

sn)

when

this

limit

exists.

The idea is that Cesa`ro summation smoothes out periodicity, which means that

for certain sequences the Ces´aro sum exists while sn does not converge. For

example, the alternating sequence (+1, -1, +1, -1, . . . ) is Ces`aro summable,

and its Ces`aro sum is easily seen to be 1/2, while it is not summable in the

normal sense. If a sequence is summable, then its sum and its Ces`aro sum

coincide. The differential value of a policy is defined as a Cesa`ro sum so that it

is well defined even if the underlying Markov chain has periodic states.

10 For   (0, 1), the -discounted average of sequence (an)n is A = (1 - (eA1x)-is=tsn ),(2=1t0h-ennn=a)1un2s.innA-gnn1=t(e1hslneem-nfa-encn1Atstan)tr.h.yIaSttuairps1gpnu=oomst(eeh1nta-thredshCt)oo2ewsssa`eert noht=has1atutminf|-AA1nn=,=isw1liwme nehnl-l a1vd(eesfinAn1n-edn-,Atn=tA)h1| es==nt O(1/(1 - )), and thus A - A = O(1 - ) as   1, which means that

lim1 A = A. The value lim1 A is called the Abel sum of (an)n. Put

simply, the Abel sum of a sequence is equal to its Cesa`ro sum when the latter

exists. Abel summation is stronger in the sense that there are sequences that

are Abel summable but not Cesa`ro summable. The approach of approximating

Ces`aro sums through -discounted averages, and taking the limit as   1 is

called the vanishing discount approach and is one of the standard ways

to prove that the (average reward) Bellman equation has a solution (see

Exercises 38.9 and 38.10). As an aside, the systematic study of how to define

the `sum' of a divergent series is a relatively modern endeavour. An enjoyable

historical account is given in the first chapter of the book on the topic by

Hardy [1973].

11 Given a solution (, v) to Eq. (38.6), we mentioned a procedure for finding

a state s~  S that is recurrent under some optimal policy. This works as

follows. Let C0 = {(s, a) :  + v(s) = ra(s) + Pa(s), v } and I0 = {s :

(s, a)  C0 for some a  A}. Then define Ck+1 and Ik+1 inductively by the

following algorithm. First find an (s, a)  Ck such that Pa(s, s ) > 0 for some

s  Ik. If no such pair exists, then halt. Otherwise let Ck+1 = Ck \ {(s, a)}

and Ik+1 = {s : (s, a)  Ck+1 for some a  A}. Now use the complementary

slackness conditions of the dual program to Eq. (38.6) to prove that the

38.8 Notes

533

algorithm halts with some non-empty Ik and that these states are recurrent under some optimal policy. For more details, have a look at Exercise 4.15 of the second volume of the book by Bertsekas [2012]. 12 We mentioned enumeration, value iteration and policy iteration as other methods for computing optimal policies. Enumeration just means enumerating all deterministic memoryless policies and selecting the one with the highest gain. This is obviously too expensive. Policy iteration is an iterative process that starts with a policy 0. In each round, the algorithm computes k+1 from k by computing vk and then choosing k+1 to be the greedy policy with respect to vk . This method may not converge to an optimal policy, but by slightly modifying the update process, one can prove convergence. For more details, see chapter 4 of volume 2 of the book by Bertsekas [2012]. Value iteration works by choosing an arbitrary value function v0 and then inductively defining vk+1 = T vk, where (T v)(s) = maxaA ra(s) + Pa(s), v is the Bellman operator. Under certain technical conditions, one can prove that the greedy policy with respect to vk converges to an optimal policy. Note that vk+1 = (k), which can be a problem numerically. A simple idea is to let vk+1 = T vk - k where k = maxsS vk(s). Since the greedy policy is the same for v and v + c1, this does not change the mathematics, but improves the numerical situation. The aforementioned book by Bertsekas is again a good source for more details. Unfortunately, none of these algorithms have known polynomial time guarantees on the computation complexity of finding an optimal policy without stronger assumptions than we would like. In practice, however, both value and policy iteration work quite well, while the ellipsoid method for solving linear programs should be avoided at all costs. Of course there are other methods for solving linear programs, and these can be effective. 13 Theorem 38.6 is vacuous when the diameter is infinite, but you might wonder if the bound continues to hold in certain `nice' cases. Unfortunately, the algorithm is rather brittle. UCRL2 suffers linear regret if there is a single unreachable state with reward larger than the optimal gain (Exercise 38.27). 14 One can modify the concept of regret to allow for MDPs that have traps. We restrict our attention to policies with sublinear regret in strongly connected MDPs, which must try and explore the whole state space and hence almost surely become trapped in a strongly communicating subset of the state space. The regret is redefined by `restarting the clock' at the time when the policy gets trapped. For details, see Exercise 38.29. 15 The assumption that the reward function is known can be relaxed without difficulty. It is left as an exercise to figure out how to modify algorithm and analysis to the case when r is unknown and reward observed in round t is bounded in [0, 1] and has conditional mean rAt (St). See Exercise 38.23. 16 Althoughit has not been done yet in this setting, the path to removing the spurious S from the bound is to avoid the application of Cauchy­Schwarz in Eq. (38.20). Instead one should define confidence intervals directly on P^k - P, vk , where the dependence on the state and action has been omitted.

38.9 Bibliographical Remarks

534

Of course, the algorithm must be changed to use the improved confidence intervals. At first sight, it seems that one could apply Hoeffding's bound directly to the inner product, but there is a subtle problem that has spoiled a number of attempts: vk and P^k are not independent. This non-independence is unfortunately quite pernicious and appears from many angles. We advise extreme caution. Some references for guidance are given in the bibliographic remarks.

38.9

Bibliographical Remarks

The study of sequential decision-making has a long

history, and we recommend the introduction of the

book by Puterman [2009] as a good starting point.

One of the main architects in modern times is Richard

Bellman, who wrote an influential book [Bellman,

1954]. His autobiography is so entertaining that

reading it slowed the writing of this chapter: The

Eye of the Hurricane [Bellman, 1984]. As a curiosity,

Bellman knew about bandit problems after accidentally

encountering a paper by Thompson [1935]. For the

tidbit, see page 260 of the aforementioned biography.

MDPs are studied by multiple research communities,

Richard Bellman

including control, operations research and artificial

intelligence. The two-volume book by Bertsekas [2012] provides a thorough and

formal introduction to the basics. The perspective is quite interdisciplinary,

but with a slight (good) bias towards the control literature. The perspective

of an operations researcher is most precisely conveyed in the comprehensive

book by Puterman [2009]. A very readable shorter introductory book is by Ross

[1983]. Arapostathis et al. [1993] surveyed existing analytical results (existence,

uniqueness of optimal policies, validity of the Bellman optimality equation) for

average-reward MDPs with an emphasis on continuous state and action space

models. The online lecture notes of Kallenberg [2016] are a recent comprehensive

alternative account for the theory of discrete MDPs. There are many texts on

linear/convex optimisation and the ellipsoid method. The introductory book on

linear optimisation by Bertsimas and Tsitsiklis [1997] is a pleasant read, while

the ellipsoid method is explained in detail by Gr¨otschel et al. [2012].

The problem considered in this chapter is part of a broader field called

reinforcement learning (RL), which has recently seen a surge of interest. The

books by Sutton and Barto [2018] and Bertsekas and Tsitsiklis [1996] describe

the foundations. The first book provides an intuitive introduction aimed at

computer scientists, while the second book focuses on the theoretical results of

the fundamental algorithms. A book by one of the present authors focuses on

38.9 Bibliographical Remarks

535

cataloguing the range of learning problems encountered in reinforcement learning

and summarising the basic ideas and algorithms [Szepesva´ri, 2010].

The UCRL algorithm and the upper and lower regret analysis is due to

Auer et al. [2009] and Jaksch et al. [2010]. Our proofs differ in minor ways. A

more significant difference is that these works used value iteration for finding

the optimistic policy and hence cannot provide polynomial time computation

guarantees. In practice this may be preferable to linear programming anyway.

The number of rigourous results for bounding the regret of various algorithms is

limited. One idea is to replace the optimistic approach with Thompson sampling,

which was first adapted to reinforcement learning by Strens [2000] under the

name PSRL (posterior sampling reinforcement learning). Agrawal and Jia [2017]

recently made an attempt to improve the dependence of the regret on the state

space. The proof is not quite correct, however, and at the time of writing the

holes have not yet been patched. Azar et al. [2017] also improve upon the UCRL2

bound, but for algorithm with

firnegitree-thoO~r(izoHn

episodic problems, where they derive an optimistic SAn), which after adapting UCRL to the episodic

setting improves on its regret by a factor of SH. The main innovation is to

use Freedman's Bernstein-style inequality for computing bonuses directly while

computing action values using backwards induction from the end of the episode

rather than keeping confidence estimates for the transition probabilities. An

issue with both of these improvements is that lower-order terms in the bounds

mean they only hold for large n. It remains to be seen if these terms arise from

the analysis or if the algorithms need modification. UCRL2 will fail in MDPs

with infinite diameter, even if the learner starts in a subset of the states that

is strongly connected from which it cannot escape. This limitation was recently

overcome by Fruit et al. [2018], who provide an algorithm with roughly the same

regret as UCRL2, but where the dependence on the diameter and state space are

replaced with those of the sub-MDP in which the learner starts and from which

it is assumed there is no escape.

Tewari and Bartlett [2008] use an optimistic version of linear programming

to obtain finite-time logarithmic bounds with suboptimal instance-dependent

constants. Note this paper mistakenly drops some constants from the confidence

intervals, which after fixing would make the constants even worse and seems to

have other problems, as well [Fruit et al., 2018]. Similar results are also available

for UCRL2 [Auer and Ortner, 2007]. Burnetas and Katehakis [1997a] prove

asymptotic guarantees with optimal constants, but with the crucial assumption

that the support of the next-state distributions Pa(s) are known. Lai and Graves

[1997] also consider asymptotic optimality. However, they consider general state

spaces where the set of transition probabilities is smoothly parameterised with a

known parameterisation but under the weakened goal of competing with the best

of finitely many memoryless policies given to the learner as black boxes.

Finite-time regret for large state and action space MDPs under additional

structural assumptions are also considered by Abbasi-Yadkori and Szepesv´ari

[2011], Abbasi-Yadkori [2012] and Ortner and Ryabko [2012]. Abbasi-Yadkori and

38.10 Exercises

536

Szepesva´ri [2011] and Abbasi-Yadkori [2012] give algorithms with O(n) regret for linearly parameterised MDP problems with quadratic cost (linear quadratic regulation, or LQR), while Ortner and Ryabko [2012] give O(n(2d+1)/(2d+2)) regret bounds under a Lipschitz assumption, where d is the dimensionality of the state space. The algorithms in these works are not guaranteed to be computationally efficient because they rely on optimistic policies. In theory, this could be addressed by Thompson sampling, which is considered by Abeille and Lazaric [2017b], who obtain partial results for the LQR setting. Thompson sampling has also been studied in the Bayesian framework by Osband et al. [2013], Abbasi-Yadkori and Szepesv´ari [2015], Osband and Van Roy [2017] and Theocharous et al. [2017], of which Abbasi-Yadkori and Szepesv´ari [2015] and Theocharous et al. [2017] consider general parametrisations, while the other papers are concerned with finite state-action MDPs. Learning in MDPs has also been studied in the probability approximately correct (PAC) framework introduced by Kearns and Singh [2002], where the objective is to design policies for which the number of badly suboptimal actions is small with high probability. The focus of these papers is on the discounted reward setting rather than average reward. The algorithms are again built on the optimism principle. Algorithms that are known to be PAC-MDP include R-max [Brafman and Tennenholtz, 2003, Kakade, 2003], MBIE [Strehl and Littman, 2005, 2008], delayed Q-learning [Strehl et al., 2006], the optimistic-initialisation-based algorithm of Szita and Lorincz [2009], MorMax by Szita and Szepesv´ari [2010], and an adaptation of UCRL by Lattimore and Hutter [2012], which they call UCRL. The latter work presents optimal results (matching upper and lower bounds) for the case when the transition structure is sparse, while the optimal dependence on the number of state-action pairs is achieved by delayed Q-learning and Mormax [Strehl et al., 2006, Szita and Szepesva´ri, 2010], though the Mormax bound is better in its dependency on the discount factor. The idea to incorporate the uncertainty in the transitions into the action space to solve the optimistic optimisation problem appeared in the analysis of MBIE [Strehl and Littman, 2008]. A hybrid between stochastic and adversarial settings is when the reward sequence is chosen by an adversary, while transitions are stochastic. This problem has been introduced by Even-Dar et al. [2004]. State-of-the-art results for the bandit case are due to Neu et al. [2014], where the reader can also find further pointers to the literature. The case when the rewards and the transitions probability distributions are chosen adversarially is studied by [Abbasi-Yadkori et al., 2013].
38.10 Exercises
38.1 (Existence of probability space) Let M = (S, A, P ) be a finite controlled Markov environment, which is a finite MDP without the reward function. A policy  = (t) t=1 is a sequence of probability kernels where t is from (S × A)t-1 × S to A. Given a policy  and initial state distribution

38.10 Exercises

537

µ  P(S), show there exists a probability space (, F, P) and an infinite sequence of random elements S1, A1, S2, A2, . . . such that for any s  S, a  A and t  N,
(a) P(S1 = s) = µ(s); (b) P(St+1 = s | S1, A1, . . . , St, At) = PAt (St, s); and (c) P(At = a | S1, A1, . . . , St) = t(a | S1, A1, . . . , St-1, At-1, St).
Hint Use Theorem 3.3.
38.2 (Sufficiency of Markov policies) Let M = (S, A, P ) be a finite controlled Markov environment,  be an arbitrary policy and µ  P(S) an arbitrary initial state distribution. Denote by Pµ the probability distribution that results from the interconnection of  and M , while the initial state distribution is µ.

(a) Show there exists a Markov policy  such that
Pµ(St = s, At = a) = Pµ (St = a, At = a)
holds for all t  1 and s, a  S × A. (b) Conclude that for any policy  there exists a Markov policy  such that for
any s  S, ¯s = ¯s .
Hint Define  inductively starting at t = 1. Puterman [theorem 5.5.1 2009] proves this result and credits Strauch [1966].
38.3 (Deterministic policies minimise travel time) Let P be some transition structure over some finite state space S and some finite action space A. Show that the expected travel time between two states s, s of S is minimised by a deterministic policy.
Hint Let  (s, s ) be the shortest expected travel time between some arbitrary pairs of states, which for s = s is defined to be zero. Show that   satisfies the fixed point equation

 (s, s ) =

0, 1 + mina

if s = s ; s Pa(s, s )  (s , s ) , otherwise .

38.4 (Strongly connected  finite diameter) Let M be a finite MDP. Prove that D(M ) <  is equivalent to M being strongly connected.

38.5 (Diameter lower bound) Let M = (S, A, P, r) be any MDP. Show that D(M )  logA(S) - 3.
Hint Denote by d(s, s ) the minimum expected time it takes to reach state s when starting from state s. The definition of d can be extended to arbitrary initial distributions µ0 over states and sets U  S of target states:

38.10 Exercises

538

d(µ0, U ) = s µ0(s) s U d(s, s ). Prove by induction on the size of U that









d(µ0, U )  min  knk 0  nk  Ak, k  0, nk = |U |

(38.25)

k0

k0

and then conclude that the proposition holds by choosing U = S [Jaksch et al., 2010, corollary 15].

38.6 (State visitation probabilities and cumulative reward) Let M = (S, A, P, r) be an MDP and  a memoryless policy and i, j  [S].

(a) Show that ei Pt ej is the probability of arriving in state j from state i in t

rounds using policy .

(b) Show that ei

n t=1

Pt

r

is

the

expected

cumulative

reward

collected

by

policy  over n rounds when starting in state i.

38.7 (Stochastic matrices) Let P be any S × S right stochastic matrix. Show that the following hold:

(a)

An

=

1 n

n-1 t=0

Pt

is

right

stochastic.

(b) (c)

An P

+ =

1 n

(P

n

-

limn

I)
1 n

= AnP

n-1 t=0

P

= P An. t exists and

is

right

stochastic.

(d) P P = P P  = P P  = P .

(e) The matrix H = (I - P + P )-1 is well defined.

(f)

Let

U

=H

- P.

Then

U

= limn

1 n

n i=1

ki-=10(P k - P ).

(g)

Let

r

 RS

and

 = P r.

Then

v

= limn

1 n

n i=1

i-1 k=0

P k(r

-

)

is

well

defined and satisfies (38.3).

(h) With the notation of the previous part, v +  = r + P v.

Hint Note that the first four parts of this exercise are the same as in Chapter 37. For parts (c) and (d), you will likely find it useful that the space of right stochastic matrices is compact. Then show that all cluster points of (An) are the same. For (g), show that v = U r.

The previous exercise shows that the gain and differential value function of any memoryless policy in any MDP are well defined. The matrix H is called the fundamental matrix, and U is called the deviation matrix.

38.8 (Discounted MDPs) Let   (0, 1), and define the operator T : RS  RS by

(T

v)(s)

=

max
aA

ra(s)

+



Pa(s), v

.

(a) Prove that T is a contraction with respect to the supremum norm:

Tv - Tw    v - w  for any v, w  RS .

38.10 Exercises

539

(b) Prove that there exists a v  RS such that Tv = v.
(c) Let  be the greedy policy with respect to v. Show v = r + Pv. (d) Prove that v = (I - P)-1r.
(e) Define the -discounted value function v of a policy  as the function that for any given state s  S gives the total expected discounted reward of the policy when it is started from state s. Let v  RS be defined by v(s) = max v(s), s  S. We call  -discount optimal if v = v. Show that if  is greedy with respect to v from part (b), then  is a -optimal
policy.

Hint For (b), you should use the contraction mapping theorem (or Banach fixed point theorem), which says that if (X , d) is a complete metric space and T : X  X satisfies d(T (x), T (y))  d(x, y) for   [0, 1), then there exists an x  X such that T (x) = x. For (e), use (d) and Exercise 38.2 to show that it suffices to check that v  v for any Markov policy . Verify this by using the fact that T is monotone (f  g implies that Tf  Tg) and showing that v,n  Tn0 holds for any n, where v,n(s) is the total expected discounted reward of the policy when it is started from state s and is followed for n steps.
38.9 (From discounting to average reward) Recall that H = (I-P +P )-1, U = H - P . For   [0, 1), define P = (1 - )(I - P )-1. Show that

(a) lim1- P = P ;

(b)

lim1-

P-P  1-

= U.

Hint For (a) start by manipulating the expressions PP and (P)-1P . For (b) consider H-1(P - P ).

38.10 (Solution to Bellman optimality equation) In this exercise you will prove part (a) of Theorem 38.2.

(a) Prove there exists a deterministic stationary policy  and increasing sequence of discount rates (n) with n < 1 and limn n = 1 such that  is a greedy policy with respect to the fixed point vn of Tn for all n.
(b) For the remainder of the exercise, fix a policy  whose existence is guaranteed by part (a). Show that  = 1 is constant.
(c) Let v = v be the value function and  =  the gain of policy . Show that (, v) satisfies the Bellman optimality equation.

Hint For (a), use the fact that for finite MDPs there are only finitely many memoryless deterministic policies. For (b) and (c), use Exercise 38.9.
38.11 (Counterintuitive solutions to the Bellman equation) Consider the deterministic MDP shown below with two states and two actions. The first action, stay, keeps the state, the same and the second action, Go, moves the learner to the other state while incurring a reward of -1. Show that in this

38.10 Exercises

540

example, solutions (, v) to the Bellman optimality equations (Eq. (38.5)) are exactly the elements of the set
(, v)  R × R2 :  = 0, v(1) - 1  v(2)  v(1) + 1 .

r=0

r=0

r = -1

1

2

r = -1

38.12 (Dangers of linear program relaxation) Give an example of an MDP and a solution (, v) to the linear program in Eq. (38.6) such that v does not satisfy the Bellman optimality equation and the greedy policy with respect to v is not optimal.

38.13 (Bound on span in terms of diameter) Let M be a strongly connected
MDP and (, v) be a solution to the Bellman optimality equation. Show that span(v)  ( - mins,a ra(s))D(M ).

Hint Note that by Theorem 38.2,  = . Fix some states s1 = s2 and a memoryless policy . Show that

v(s2)

-

v(s1)



(

-

min
s,a

ra (s))E [s2

|

S1

=

s1]

.

Note for the sake of curiosity that the above display continues to hold for weakly communicating MDPs.

The proof of Theorem 4 in the paper by Bartlett and Tewari [2009] is
incorrect. The problem is that the statement needs to hold for any solution
v of the Bellman optimality equation. The proof uses an argument that
hinges on the fact that in an aperiodic strongly connected MDP, v is in the set {c1 + limn T n0 - n : c  R}. However, Exercise 38.11 shows that there exist strongly connected MDPs where this does not hold.

38.14 (Separation oracles) Solve the following problems:

(a) Prove that Algorithm 27 provides a separation oracle for convex set K defined in Eq. (38.10).
(b) Assuming that Algorithm 27 can be implemented efficiently, explain how to find an approximate solution to Eq. (38.7).

38.15 (Combining separation oracles) Let K  Rd be a convex set and  be

a separation oracle for K. Suppose that a1, . . . , an is a collection of vectors with

ak  Rd and b1, . . . , bk be a collection of scalars. Let Hk = {x  Rd : ak, x  bk}.

Devise an efficient separation oracle for

n k=1

K



Hk .

38.10 Exercises

541

38.16 (Approximate solutions to Bellman equation) Consider a strongly connected MDP, and suppose that  and v approximately satisfy the Bellman optimality equation in the sense that there exists an  > 0 such that



+

v(s)

-

max
aA

ra

(s)

+

Pa(s), v



for all state-action pairs s, a . (38.26)

(a) Show that    - .
(b) Let ~ be the greedy policy with respect to v. Assume that ~ is  greedy with respect to v in the sense that r~(s)(s) + P~(s)(s), v  maxaA ra(s) + Pa(s), v -  holds for all s  S. Show that ~ is 2 +  optimal: ~   - (2 +  ).
(c) Suppose that  in Eq. (38.7) is replaced with   [,  + ]. Show that the linear program remains feasible and the solution (, v) satisfies Eq. (38.26) with   |S|2.

38.17 (Average-optimal is nearly finite-time optimal) Let M be a strongly connected MDP with rewards in [0, 1], diameter D <  and optimal gain . Let vn (s) be the maximum total expected reward in n steps when the process starts in state s. Prove that vn (s)  n + D.
38.18 (High probability  expected regret) Prove that (38.12) follows from Theorem 38.6.

38.19 (Necessity of phases) The purpose of this exercise is to show that without phases, UCRL2 may suffer linear regret. For convenience, we consider the modified version of UCRL2 in Exercise 38.23 that does not know the reward. Now suppose we further modify this algorithm to re-solve the optimistic MDP in every round (k = k for all k). We make use of the following deterministic MDP with two actions A = {stay, go} represented by dashed and solid arrows respectively.

1/2

1/2

0

1

2

0

Figure 38.4 Transitions and rewards are deterministic. Numbers indicate the rewards.

(a) Find all memoryless optimal policies for the MDP in Fig. 38.4. (b) Prove that the version of UCRL2 given in Exercise 38.23 modified to re-solve
the optimistic MDP in every round suffers linear regret on this MDP.

38.10 Exercises

542

Hint Since UCRL2 and the environment are both deterministic you can examine the behaviour of the algorithm on the MDP. You should aim to prove that eventually the algorithm will alternate between actions stay and go.
38.20 (Extended MDP is strongly connected) Let M~k be the extended MDP defined in Section 38.5.1 and Ck be the confidence set defined in Eq. (38.13). Prove that P  Ck implies that M~k is strongly connected.
38.21 (Confidence sets) Prove Lemma 38.8.

Hint Use the result of Exercise 5.17 and apply a union bound over all stateaction pairs and the number of samples. Use the Markov property to argue that the independence assumption in Exercise 5.17 is not problematic.

38.22 Let (ak) and (Ak) be non-negative numbers so that for any k  0, ak+1  Ak = 1  (a1 + · · · + ak). Prove that for any m  1,

m

ak

  2+1

k=1 Ak-1

Am .

Hint The statement is trivial if

m-1 k=1

ak



1.

If

this

does

not

hold,

use

induction based on m = n, n + 1, . . . , where n is the first integer such that

n-1 k=1

ak

>

1.

38.23 (Unknown rewards) In this exercise, you will modify the algorithm to handle the situation where r is unknown and rewards are stochastic. More precisely, assume there exists a function ra(s)  [0, 1] for all a  A and s  S. Then, in each round, the learner observes St, chooses an action At and receives a reward Xt  [0, 1] with

E[Xt | At, St] = rAt (St) .

In order to accommodate the unknown reward function, we modify UCRL2 in the following way. First, define the empirical reward at the start of the kth phase by

r^k,a(s)

=

k -1 u=1

I {Su 1

= s, Au = a} Xu  Tk-1(s, a)

.

Then, let r~t,a(s) be an upper confidence bound given by

L r~k,a(s) = r^t,a(s) + 2(1  Tk-1(s, a)) ,
where L is as in the proof of Theorem 38.6. The modified algorithm operates exactly like Algorithm 28, but replaces the unknown ra(s) with r~k,a(s) when solving the extended MDP. Prove that with probability at least 1 - 3/2, the

38.10 Exercises

543

modified policy in the modified setting has regret at most

R^n  CD(M )S

nA log

nSA 

,

where C > 0 is a universal constant.

38.24 (Lower bound) In this exercise, you will prove the claims to complete the proof of the lower bound.

(a) Prove Claim 38.9. (b) Prove Claim 38.10. (c) Prove Claim 38.11.

38.25 (Contextual bandits as MDPs) Consider the MDP M = (S, A, P, r), where Pa(s) = p for some fixed categorical distribution p for any (s, a)  S × A, where minsS p(s) > 0. Assume that the rewards for action a in state s are sampled from a distribution supported on [0, 1] (see Note 3). An MDP like this defines nothing but a contextual bandit.

(a) Derive the optimal policy and the average optimal reward. (b) Show an optimal value function that solves the Bellman optimality equation. (c) Prove that the diameter of this MDP is D = maxs 1/p(s). (d) Consider the algorithm that puts one instance of an appropriate version
of UCB into every state (the same idea was explored in the context of adversarial bandits in Section18.1). Prove that the expected regret of your algorithm will be at most O( SAn). (e) Does the scaling behaviour of the upper bound in Theorem 38.6 match the actual scaling behaviour of the expected regret of UCRL2 in this example? Why or why not? (f) Design and run an experiment to confirm your claim.

38.26 (Implementation) This is a thinking and coding exercise to illustrate the difficulty of learning in MDPs. The RiverSwim environment is originally due to Strehl and Littman [2008]. The environment has two actions A = {left, right} and S = [S] with S  2. In all states s > 1, action left deterministically leads to state s - 1 and provides no reward. In state 1, action left leaves the state unchanged and yields a reward of 0.05. The action right tends to make the agent move right but not deterministically (the learner is swimming against a current). With probability 0.3, the state is incremented, with a probability 0.6, the state is left unchanged, while with probability of 0.1 the state is decremented. This action incurs a reward of zero in all states except in state S, where it receives a reward of 1. The situation when S = 5 is illustrated in Fig. 38.5.

(a) Show that the optimal policy always takes action right and calculate the optimal average reward  as a function of S.

38.10 Exercises

544

1, 0.05

1, 0 0.3, 0

1, 0 0.3, 0

1, 0 0.3, 0

1, 0 0.3, 0

1 0.1, 0 2 0.1, 0 3 0.1, 0 4 0.1, 1 5

0.7, 0

0.6, 0

0.6, 0 current

0.6, 0

0.9, 1

Figure 38.5 The RiverSwim MDP when S = 5. Solid arrows correspond to action left and dashed ones to action right. The right-hand bank is slippery, so the learner sometimes falls back into the river.

(b) Implement the MDP and test the optimal policy when started from state 1. Plot the total reward as a function of time and compare it with the plot of t  t. Run multiple simulations to produce error bars. How fast do you think the total reward concentrates around t? Experiment with different values of S.
(c) The -greedy strategy can also be implemented in MDPs as follows: based on the data previously collected, estimate the transition probabilities and rewards using empirical means. Find the optimal policy  of the resulting MDP, and if the current state is s, use the action (s) with probability 1 -  and choose one of the two actions uniformly at random with the remaining probability. To ensure the empirical MDP has a well-defined optimal policy, mix the empirical estimate of the next state distributions Pa(s) with the uniform distribution with a small mixture coefficient. Implement this strategy and plot the trajectories it exhibits for various MDP sizes. Explain what you see.
(d) Implement UCRL2 and produce the same plots. Can you explain what you see?
(e) Run simulations in RiverSwim instances of various sizes to compare the regret of UCRL2 and -greedy. What do you conclude?
38.27 (UCRL2 and unreachable states) Show that UCRL2 suffers linear regret if there is a single unreachable state with reward larger than the optimal gain.
Hint Think about the optimistic MDP and the optimistic transitions to the unreachable state. The article by Fruit et al. [2018] provides a policy that mitigates the problem.
38.28 (MDPs with traps (i)) Fix state space S, action space A and reward function r. Let  be a policy with sublinear regret in all strongly connected

38.10 Exercises

545

MDPs (S, A, r, P ). Now suppose that (S, A, r, P ) is an MDP that is not strongly
connected such that for all s  S, there exists a state s that is reachable from s under some policy and where s < maxu u. Finally, assume that S1 = maxu u almost surely. Prove that  has linear regret on this MDP.

38.29 (MDPs with traps (ii)) This exercise develops the ideas mentioned in Note 14. First, we need some definitions: fix S and A and define 0 as the set of policies (learner strategies) for MDPs with state space S and action space A that achieve sublinear regret in any strongly connected MDP with state space S and action space A. Now consider an arbitrary finite MDP M = (S, A, P, r). A state s  S is reachable from state s  S if there is a policy that when started in s reaches state s with positive probability after one or more steps. A set of states C  S is a strongly connected component (SCC) if every state s  U is reachable from every other state s  C, including s = s . A set C  S is maximal if we cannot add more states to C and still maintain the SCC property. A SCC C is called a maximal end component if there does not exist another SCC C with C  C . Show the following:

(a) There exists at least one MEC and two MECs C1 and C2, are either equal or disjoint.
(b) Let C1, . . . , Ck be all the distinct MECs of an MDP. The MDP structure defines a connectivity over C1, . . . , Ck as follows: for i = j, we say that Ci is connected to Cj if from some state in Ci, it is possible to reach some state of Cj with positive probability under some policy. Show that this connectivity structure defines a directed graph, which must be acyclic.
(c) Let C1, . . . , Cm with m  k be the sinks (the nodes with no out edges) of this graph. Show that if M is strongly connected, then m = 1 and C1 = S.
(d) Show that for any i  [m] and for any policy   0, it holds that  will reach Ci in finite time with positive probability if the initial state distribution assigns positive mass to the non-trap states S \ i[m]Ci.
(e) Show that for i  m, for any s  Ci and any action a  A, Pa(s, s ) = 0 for any s  S \ Ci, i.e., Ci is closed.
(f) Show that the restriction of M to Ci defined as

Mi = (Ci, A, (Pa(s))sCi,aA, (ra(s))sCi,aA)

is an MDP. (g) Show that Mi is strongly connected. (h) Let  be the time when the learner enters one of C1, . . . , Cm and let I  [m]
be the index of the class that is entered at time  . That is, S  CI . Show that if M is strongly connected, then  = 1 with probability one. (i) We redefine the regret as follows:

 +n-1

Rn = E

rAt (St) - n(MI ) .

t=

38.10 Exercises

546

Show that if M is strongly connected, then Rn = Rn. (j) Can you design a policy with Rn = O(E[D(MI )|CI |] An log(n))? Will
UCRL2 already satisfy this?
The logic of the regret definition in part (i) is that by part (d), reasonable policies cannot control which trap they fall into in an MDP that has more than one traps. As such, policies should not be penalised for what trap they fall into. However, once a policy falls into some trap, we expect it to start to behave near optimally. What this definition is still lacking is that it is insensitive to how fast a policy gets trapped. The last part is quite subtle [Fruit et al., 2018].
38.30 (Chain rule for relative entropy) Prove the claim in Eq. (38.22).
Hint Make use of the result in Exercise 14.12.

Bibliography
Y. Abbasi-Yadkori. Forced-exploration based algorithms for playing in bandits with large action sets. PhD thesis, University of Alberta, 2009a. [246]
Y. Abbasi-Yadkori. Forced-exploration based algorithms for playing in bandits with large action sets. Master's thesis, University of Alberta, Department of Computing Science, 2009b. [94]
Y. Abbasi-Yadkori. Online Learning for Linearly Parametrized Control Problems. PhD thesis, University of Alberta, 2012. [246, 535, 536]
Y. Abbasi-Yadkori and Cs. Szepesva´ri. Regret bounds for the adaptive control of linear quadratic systems. In Proceedings of the 24th Conference on Learning Theory, pages 1­26, Budapest, Hungary, 2011. JMLR.org. [535]
Y. Abbasi-Yadkori and Cs. Szepesv´ari. Bayesian optimal control of smoothly parameterized systems. In Proceedings of the 31st Conference on Uncertainty in Artificial Intelligence, pages 2­11, Arlington, VA, United States, 2015. AUAI Press. [536]
Y. Abbasi-Yadkori, A. Antos, and Cs. Szepesv´ari. Forced-exploration based algorithms for playing in stochastic linear bandits. In COLT Workshop on On-line Learning with Limited Feedback, 2009. [94, 246]
Y. Abbasi-Yadkori, D. P´al, and Cs. Szepesv´ari. Improved algorithms for linear stochastic bandits. In Advances in Neural Information Processing Systems, pages 2312­2320. Curran Associates, Inc., 2011. [245]
Y. Abbasi-Yadkori, D. P´al, and Cs. Szepesv´ari. Online-to-confidence-set conversions and application to sparse stochastic bandits. In Proceedings of the 15th International Conference on Artificial Intelligence and Statistics, pages 1­9, La Palma, Canary Islands, 2012. JMLR.org. [285]
Y. Abbasi-Yadkori, P. L. Bartlett, V. Kanade, Y. Seldin, and Cs. Szepesv´ari. Online learning in Markov decision processes with adversarially chosen transition probability distributions. In Advances in Neural Information Processing Systems, pages 2508­2516, USA, 2013. Curran Associates Inc. [536]
Y. Abbasi-Yadkori, P. Bartlett, V. Gabillon, A. Malek, and M. Valko. Best of both worlds: Stochastic & adversarial best-arm identification. In Proceedings of the 31st Conference on Learning Theory, 2018. [415]
N. Abe and P. M. Long. Associative reinforcement learning using linear probabilistic concepts. In Proceedings of the 16th International Conference

BIBLIOGRAPHY

548

on Machine Learning, pages 3­11, San Francisco, CA, USA, 1999. Morgan Kaufmann Publishers Inc. [245] M. Abeille and A. Lazaric. Linear Thompson sampling revisited. In Proceedings of the 20th International Conference on Artificial Intelligence and Statistics, pages 176­184, Fort Lauderdale, FL, USA, 2017a. JMLR.org. [472] M. Abeille and A. Lazaric. Thompson sampling for linear-quadratic control problems. In Proceedings of the 20th International Conference on Artificial Intelligence and Statistics, pages 1246­1254, Fort Lauderdale, FL, USA, 2017b. JMLR.org. [536] J. D. Abernethy and A. Rakhlin. Beating the adaptive bandit with high probability. In Proceedings of the 22nd Conference on Learning Theory, 2009. [171, 342] J. D. Abernethy, E. Hazan, and A. Rakhlin. Competing in the dark: An efficient algorithm for bandit linear optimization. In Proceedings of the 21st Conference on Learning Theory, pages 263­274. Omnipress, 2008. [342] J. D. Abernethy, E. Hazan, and A. Rakhlin. Interior-point methods for fullinformation and bandit online learning. IEEE Transactions on Information Theory, 58(7):4164­4175, 2012. [170, 339] J. D. Abernethy, C. Lee, A. Sinha, and A. Tewari. Online linear optimization via smoothing. In Proceedings of the 27th Conference on Learning Theory, pages 807­823, Barcelona, Spain, 2014. JMLR.org. [372] J. D. Abernethy, C. Lee, and A. Tewari. Fighting bandits with a new kind of smoothness. In Advances in Neural Information Processing Systems, pages 2197­2205. Curran Associates, Inc., 2015. [342, 372] M. Abramowitz and I. A. Stegun. Handbook of mathematical functions: with formulas, graphs, and mathematical tables, volume 55. Courier Corporation, 1964. [183, 473] M. Achab, S. Cl´emen¸con, A. Garivier, A. Sabourin, and C. Vernade. Max karmed bandit: On the extremehunter algorithm and beyond. In Joint European Conference on Machine Learning and Knowledge Discovery in Databases, pages 389­404. Springer, 2017. [415] L. Adelman. Choice theory. In Saul I. Gass and Michael C. Fu, editors, Encyclopedia of Operations Research and Management Science, pages 164­ 168. Springer US, Boston, MA, 2013. [67] A. Agarwal, D. P. Foster, D. J. Hsu, S. M. Kakade, and A. Rakhlin. Stochastic convex optimization with bandit feedback. In Advances in Neural Information Processing Systems, pages 1035­1043. Curran Associates, Inc., 2011. [358] A. Agarwal, D. P. Foster, D. Hsu, S. M. Kakade, and A. Rakhlin. Stochastic convex optimization with bandit feedback. SIAM Journal on Optimization, 23 (1):213­240, 2013. [414] A. Agarwal, D. Hsu, S. Kale, J. Langford, L. Li, and R. Schapire. Taming the monster: A fast and simple algorithm for contextual bandits. In Proceedings of the 31st International Conference on Machine Learning, pages 1638­1646, Bejing, China, 2014. JMLR.org. [230, 231, 232]

BIBLIOGRAPHY

549

A. Agarwal, S. Bird, M. Cozowicz, L. Hoang, J. Langford, S. Lee, J. Li, D. Melamed, G. Oshri, and O. Ribas. Making contextual decisions with low technical debt. arXiv:1606.03966, 2016. [17]
R. Agrawal. Sample mean based index policies with O(log n) regret for the multiarmed bandit problem. Advances in Applied Probability, pages 1054­1078, 1995. [110, 120]
S. Agrawal and N. R. Devanur. Bandits with concave rewards and convex knapsacks. In Proceedings of the 15th ACM conference on Economics and computation, pages 989­1006. ACM, 2014. [358]
S. Agrawal and N. R. Devanur. Linear contextual bandits with knapsacks. In Advances in Neural Information Processing Systems, pages 3458­3467. Curran Associates Inc., 2016. [359]
S. Agrawal and N. Goyal. Analysis of Thompson sampling for the multi-armed bandit problem. In Proceedings of the 25th Conference on Learning Theory, 2012. [472]
S. Agrawal and N. Goyal. Further optimal regret bounds for Thompson sampling. In Proceedings of the 16th International Conference on Artificial Intelligence and Statistics, pages 99­107, Scottsdale, Arizona, USA, 2013a. JMLR.org. [470, 472]
S. Agrawal and N. Goyal. Thompson sampling for contextual bandits with linear payoffs. In Proceedings of the 30th International Conference on Machine Learning, pages 127­135, Atlanta, GA, USA, 2013b. JMLR.org. [472]
S. Agrawal and R. Jia. Optimistic posterior sampling for reinforcement learning: worst-case regret bounds. In Advances in Neural Information Processing Systems, pages 1184­1194. Curran Associates, Inc., 2017. [535]
S. Agrawal, V. Avadhanula, V. Goyal, and A. Zeevi. Thompson sampling for the MNL-bandit. In Proceedings of the 2017 Conference on Learning Theory, pages 76­78, Amsterdam, Netherlands, 2017. JMLR.org. [472]
N. Ailon, Z. Karnin, and T. Joachims. Reducing dueling bandits to cardinal bandits. In Proceedings of the 31st International Conference on Machine Learning, pages II­856­II­864. JMLR.org, 2014. [358]
J. Aldrich. "but you have to remember P. J. Daniell of Sheffield". Electronic Journal for History of Probability and Statistics, 3(2), 2007. [53]
C. Allenberg, P. Auer, L. Gyo¨rfi, and G. Ottucsa´k. Hannan consistency in on-line learning in case of unbounded losses under partial monitoring. In Proceedings of the 17th International Conference on Algorithmic Learning Theory, pages 229­243, Berlin, Heidelberg, 2006. Springer-Verlag. [156, 170, 339]
N. Alon, Y. Matias, and M. Szegedy. The space complexity of approximating the frequency moments. In Proceedings of the 28th annual ACM symposium on theory of computing, pages 20­29. ACM, 1996. [115]
N. Alon, N. Cesa-Bianchi, C. Gentile, and Y. Mansour. From bandits to experts: A tale of domination and independence. In Advances in Neural Information Processing Systems, pages 1610­1618. Curran Associates, Inc., 2013. [359, 505]

BIBLIOGRAPHY

550

N. Alon, N. Cesa-Bianchi, O. Dekel, and T. Koren. Online learning with feedback graphs: Beyond bandits. In Proceedings of the 28th Conference on Learning Theory, pages 23­35, Paris, France, 2015. JMLR.org. [359]
V. Anantharam, P. Varaiya, and J. Walrand. Asymptotically efficient allocation rules for the multiarmed bandit problem with multiple plays-part i: Iid rewards. IEEE Transactions on Automatic Control, 32(11):968­976, 1987. [246]
J. R. Anderson, J. L. Dillon, and J. E. Hardaker. Agricultural decision analysis. Monographs: Applied Economics. Iowa State University Press, 1977. [2]
F. J. Anscombe. Sequential medical trials. Journal of the American Statistical Association, 58(302):365­383, 1963. [94]
A. Antos, G. Bart´ok, D. P´al, and Cs. Szepesv´ari. Toward a classification of finite partial-monitoring games. Theoretical Computer Science, 473:77­99, 2013. [505]
A. Arapostathis, V. S. Borkar, E. Fernandez-Gaucherand, M. K. Ghosh, and S. I. Marcus. Discrete-time controlled Markov processes with average cost criterion: a survey. SIAM Journal of Control and Optimization, 31(2):282­344, 1993. [534]
R. Arora, O. Dekel, and A. Tewari. Online bandit learning against an adaptive adversary: From regret to policy regret. In Proceedings of the 29th International Conference on Machine Learning, Madison, WI, USA, 2012. Omnipress. [158]
B. Ashwinkumar, J. Langford, and A. Slivkins. Resourceful contextual bandits. In Proceedings of the 27th Conference on Learning Theory, pages 1109­1134, Barcelona, Spain, 2014. JMLR.org. [358]
J.-V. Audibert and S. Bubeck. Regret bounds and minimax policies under partial monitoring. Journal of Machine Learning Research, 11:2785­2836, 2010a. [157]
J.-Y. Audibert and S. Bubeck. Minimax policies for adversarial and stochastic bandits. In Proceedings of the 22nd Conference on Learning Theory, pages 217­226, 2009. [128, 157, 346]
J.-Y. Audibert and S. Bubeck. Best arm identification in multi-armed bandits. In Proceedings of the 23rd Conference on Learning Theory, 2010b. [384, 413]
J.-Y. Audibert, R. Munos, and Cs. Szepesv´ari. Tuning bandit algorithms in stochastic environments. In Proceedings of the 18th International Conference on Algorithmic Learning Theory, pages 150­165, Berlin, Heidelberg, 2007. Springer Berlin Heidelberg. [69, 85, 110, 114, 211]
J.-Y. Audibert, R. Munos, and Cs. Szepesva´ri. Exploration-exploitation tradeoff using variance estimates in multi-armed bandits. Theoretical Computer Science, 410(19):1876­1902, 2009. [69]
J.-Y. Audibert, S. Bubeck, and G. Lugosi. Regret in online combinatorial optimization. Mathematics of Operations Research, 39(1):31­45, 2013. [342]
P. Auer. Using confidence bounds for exploitation-exploration trade-offs. Journal of Machine Learning Research, 3:397­422, 2002. [245, 273]
P. Auer and C. Chiang. An algorithm with nearly optimal pseudo-regret for both stochastic and adversarial bandits. In Proceedings of the 29th Annual

BIBLIOGRAPHY

551

Conference on Learning Theory, pages 116­120, New York, NY, USA, 2016. JMLR.org. [157] P. Auer and R. Ortner. Logarithmic online regret bounds for undiscounted reinforcement learning. In Advances in Neural Information Processing Systems, pages 49­56. MIT Press, 2007. [535] P. Auer and R. Ortner. UCB revisited: Improved regret bounds for the stochastic multi-armed bandit problem. Periodica Mathematica Hungarica, 61(1-2):55­65, 2010. [98, 128] P. Auer, N. Cesa-Bianchi, Y. Freund, and R. E. Schapire. Gambling in a rigged casino: The adversarial multi-armed bandit problem. In Foundations of Computer Science, 1995. Proceedings., 36th Annual Symposium on, pages 322­331. IEEE, 1995. [97, 146, 159, 201] P. Auer, N. Cesa-Bianchi, and P. Fischer. Finite-time analysis of the multiarmed bandit problem. Machine Learning, 47:235­256, 2002a. [95, 110] P. Auer, N. Cesa-Bianchi, Y. Freund, and R. E. Schapire. The nonstochastic multiarmed bandit problem. SIAM Journal on Computing, 32(1):48­77, 2002b. [171, 202, 231, 384] P. Auer, R. Ortner, and Cs. Szepesv´ari. Improved rates for the stochastic continuum-armed bandit problem. In International Conference on Computational Learning Theory, pages 454­468. Springer, 2007. [357] P. Auer, T. Jaksch, and R. Ortner. Near-optimal regret bounds for reinforcement learning. In Advances in Neural Information Processing Systems, pages 89­96, 2009. [535] P. Auer, P. Gajane, and R. Ortner. Adaptively tracking the best arm with an unknown number of distribution changes. In European Workshop on Reinforcement Learning 14, 2018. [384] P. Auer, P. Gajane, and R. Ortner. Adaptively tracking the best bandit arm with an unknown number of distribution changes. In Proceedings of the 32nd Conference on Learning Theory, 2019. [382, 384] B. Awerbuch and R. Kleinberg. Adaptive routing with end-to-end feedback: Distributed learning and geometric approaches. In Proceedings of the 36th annual ACM symposium on theory of computing, pages 45­53. ACM, 2004. [372] S. J. Axler. Linear algebra done right, volume 2. Springer, 1997. [501] M. G. Azar, I. Osband, and R. Munos. Minimax regret bounds for reinforcement learning. In Proceedings of the 34th International Conference on Machine Learning, pages 263­272, Sydney, Australia, 06­11 Aug 2017. JMLR.org. [535] A. Badanidiyuru, R. Kleinberg, and A. Slivkins. Bandits with knapsacks. In Foundations of Computer Science (FOCS), 2013 IEEE 54th Annual Symposium on, pages 207­216. IEEE, 2013. [358] P. L. Bartlett and A. Tewari. Regal: A regularization based algorithm for reinforcement learning in weakly communicating MDPs. In Proceedings of the 25th Conference on Uncertainty in Artificial Intelligence, pages 35­42, Arlington, VA, United States, 2009. AUAI Press. [540]

BIBLIOGRAPHY

552

G. Barto´k. A near-optimal algorithm for finite partial-monitoring games against adversarial opponents. In Proceedings of the 26th Conference on Learning Theory, pages 696­710. JMLR.org, 2013. [503, 505]
G. Bart´ok and Cs. Szepesv´ari. Partial monitoring with side information. In Proceedings of the 23rd International Conference on Algorithmic Learning Theory, pages 305­319, 2012. [506]
G. Bart´ok, D. P´al, and Cs. Szepesv´ari. Toward a classification of finite partialmonitoring games. In Proceedings of the 21st International Conference on Algorithmic Learning Theory, pages 224­238. Springer, 2010. [505]
G. Bart´ok, N. Zolghadr, and Cs. Szepesv´ari. An adaptive algorithm for finite stochastic partial monitoring. In Proceedings of the 29th International Conference on Machine Learning, pages 1779­1786, USA, 2012. Omnipress. [505]
G. Bart´ok, D. P. Foster, D. P´al, A. Rakhlin, and Cs. Szepesv´ari. Partial monitoring--classification, regret bounds, and algorithms. Mathematics of Operations Research, 39(4):967­997, 2014. [505]
H. Bastani and M. Bayati. Online decision making with high-dimensional covariates. Operations Research, 68(1):276­294, 2020. [284]
J. A. Bather and H. Chernoff. Sequential decisions in the control of a spaceship. In Fifth Berkeley Symposium on Mathematical Statistics and Probability, volume 3, pages 181­207, 1967. [17]
T. Bayes. LII. An essay towards solving a problem in the doctrine of chances. by the late Rev. Mr. Bayes, FRS communicated by Mr. Price, in a letter to John Canton, AMFR S. Philosophical transactions of the Royal Society of London, 53:370­418, 1763. [434]
R. Bellman. The theory of dynamic programming. Technical report, RAND CORP SANTA MONICA CA, 1954. [534]
R. E. Bellman. Eye of the Hurricane. World Scientific, 1984. [534] D. Berend and A. Kontorovich. On the concentration of the missing mass.
Electronic Communications in Probability, 18(3):1­7, 2013. [84] J. O. Berger. Statistical Decision Theory and Bayesian Analysis. Springer Science
& Business Media, 1985. [431] D. Bernoulli. Exposition of a new theory on the measurement of risk.
Econometrica: Journal of the Econometric Society, pages 23­36, 1954. [67] A. C. Berry. The accuracy of the Gaussian approximation to the sum of
independent variates. Transactions of the American mathematical society, 49(1):122­136, 1941. [78] D. Berry and B. Fristedt. Bandit problems : sequential allocation of experiments. Chapman and Hall, London ; New York, 1985. [17, 453, 455] D. A. Berry, R. W. Chen, A. Zame, D. C. Heath, and L. A. Shepp. Bandit problems with infinitely many arms. The Annals of Statistics, 25(5):2103­2116, 1997. [357] D. Bertsekas and J. N. Tsitsiklis. Neuro-Dynamic Programming. Athena Scientific, 1st edition, 1996. [534]

BIBLIOGRAPHY

553

D. P. Bertsekas. Dynamic Programming and Optimal Control, volume 1-2. Athena Scientific, Belmont, MA, 4 edition, 2012. [533, 534]
D. P. Bertsekas. Convex optimization algorithms. Athena Scientific Belmont, 2015. [374]
D. Bertsimas and J. N. Tsitsiklis. Introduction to linear optimization, volume 6. Athena Scientific Belmont, MA, 1997. [534]
O. Besbes, Y. Gur, and A. Zeevi. Stochastic multi-armed-bandit problem with non-stationary rewards. In Advances in Neural Information Processing Systems, pages 199­207. Curran Associates, Inc., 2014. [384]
L. Besson and E. Kaufmann. What doubling tricks can and can't do for multiarmed bandits. arXiv:1803.06971, 2018. [97]
A. Beygelzimer, J. Langford, L. Li, L. Reyzin, and R. E. Schapire. An optimal high probability algorithm for the contextual bandit problem. arXiv:1002.4058, 2010. [171]
A. Beygelzimer, J. Langford, L. Li, L. Reyzin, and R. Schapire. Contextual bandit algorithms with supervised learning guarantees. In Proceedings of the 14th International Conference on Artificial Intelligence and Statistics, pages 19­26, Fort Lauderdale, FL, USA, 2011. JMLR.org. [232, 235]
P. Billingsley. Probability and measure. John Wiley & Sons, 2008. [41, 53] D. Blackwell. Controlled random walks. In Proceedings of the International
Congress of Mathematicians, volume 3, pages 336­338, 1954. [146] V. I. Bogachev. Measure theory, volume 2. Springer Science & Business Media,
2007. [42, 315] T. Bonald and A. Proutiere. Two-target algorithms for infinite-armed bandits
with bernoulli rewards. In Advances in Neural Information Processing Systems, pages 2184­2192, 2013. [357] L. Bottou, J. Peters, J. Quin~onero-Candela, D. X. Charles, D. M. Chickering, E. Portugaly, D. Ray, P. Simard, and E. Snelson. Counterfactual reasoning and learning systems: The example of computational advertising. The Journal of Machine Learning Research, 14(1):3207­3260, 2013. [171] S. Boucheron, G. Lugosi, and P. Massart. Concentration inequalities: A nonasymptotic theory of independence. OUP Oxford, 2013. [80, 340] D. Bouneffouf and I. Rish. A survey on practical applications of multi-armed and contextual bandits. arXiv:1904.10040, 2019. [17] G. E. P. Box. Science and statistics. Journal of the American Statistical Association, 71(356):791­799, 1976. [145] G. E. P. Box. Robustness in the strategy of scientific model building. Robustness in statistics, 1:201­236, 1979. [145] S. Boyd and L. Vandenberghe. Convex optimization. Cambridge University Press, 2004. [312] R. N. Bradt, S. M. Johnson, and S. Karlin. On sequential designs for maximizing the sum of n observations. The Annals of Mathematical Statistics, pages 1060­1074, 1956. [455]

BIBLIOGRAPHY

554

R. Brafman and M. Tennenholtz. R-MAX ­ a general polynomial time algorithm

for near-optimal reinforcement learning. Journal of Machine Learning Research,

3:213­231, 2003. [536]

J. Bretagnolle and C. Huber. Estimation des densit´es: risque minimax. Zeitschrift

fu¨r Wahrscheinlichkeitstheorie und verwandte Gebiete, 47(2):119­137, 1979.

[193]

S. Bubeck and N. Cesa-Bianchi. Regret analysis of stochastic and nonstochastic

multi-armed bandit problems. Foundations and Trends in Machine Learning,

5(1):1­122, 2012. [17, 110, 157, 342, 372]

S. Bubeck and R. Eldan. The entropic barrier: a simple and optimal universal

self-concordant barrier. In Proceedings of the 28th Conference on Learning

Theory, pages 279­279, Paris, France, 2015. JMLR.org. [322]

S. Bubeck and R. Eldan. Multi-scale exploration of convex functions and bandit

convex optimization. In Proceedings of the 29th Conference on Learning Theory,

pages 583­589, New York, NY, USA, 2016. JMLR.org. [358, 471, 472]

S. Bubeck and C. Liu. Prior-free and prior-dependent regret bounds for Thompson

sampling. In Advances in Neural Information Processing Systems, pages 638­

646. Curran Associates, Inc., 2013. [473]

S. Bubeck and A. Slivkins. The best of both worlds: Stochastic and adversarial

bandits. In Proceedings of the 25th Conference on Learning Theory, pages

42.1­42.23, 2012. [157]

S. Bubeck, R. Munos, and G. Stoltz. Pure exploration in multi-armed bandits

problems. In International conference on Algorithmic learning theory, pages

23­37. Springer, 2009. [413]

S. Bubeck, R. Munos, G. Stoltz, and Cs. Szepesva´ri. X-armed bandits. Journal

of Machine Learning Research, 12:1655­1695, 2011. [357]

S. Bubeck, N. Cesa-Bianchi, and S. Kakade. Towards minimax policies for online

linear optimization with bandit feedback. In Proceedings of the 25th Conference

on Learning Theory, pages 41­1. Microtome, 2012. [273, 322, 342]

S. Bubeck, N. Cesa-Bianchi, and G. Lugosi. Bandits with heavy tail. IEEE

Transactions on Information Theory, 59(11):7711­7717, 2013a. [115]

S. Bubeck, V. Perchet, and P. Rigollet. Bounded regret in stochastic multi-armed

bandits. In Proceedings of the 26th Annual Conference on Learning Theory,

pages 122­134, Princeton, NJ, USA, 2013b. JMLR.org. [201]



S. Bubeck, O. Dekel, T. Koren, and Y. Peres. Bandit convex optimization: T

regret in one dimension. In Proceedings of the 28th Conference on Learning

Theory, pages 266­278, Paris, France, 2015a. JMLR.org. [358, 471, 472]

S. Bubeck, R. Eldan, and J. Lehec. Finite-time analysis of projected Langevin

Monte Carlo. In Advances in Neural Information Processing Systems, pages

1243­1251. Curran Associates, Inc., 2015b. [322, 339]

S. Bubeck, Y.T. Lee, and R. Eldan. Kernel-based methods for bandit convex

optimization. In Proceedings of the 49th Annual ACM SIGACT Symposium on

Theory of Computing, STOC 2017, pages 72­85, New York, NY, USA, 2017.

ACM. ISBN 978-1-4503-4528-6. [358]

BIBLIOGRAPHY

555

S. Bubeck, M. Cohen, and Y. Li. Sparsity, variance and curvature in multi-armed bandits. In Proceedings of the 29th International Conference on Algorithmic Learning Theory, pages 111­127. JMLR.org, 07­09 Apr 2018. [170, 338, 342]
A. N. Burnetas and M. N. Katehakis. Optimal adaptive policies for sequential allocation problems. Advances in Applied Mathematics, 17(2):122­142, 1996. [120, 140, 208, 209]
A. N. Burnetas and M. N. Katehakis. Optimal adaptive policies for Markov decision processes. Mathematics of Operations Research, 22(1):222­255, 1997a. [535]
A. N. Burnetas and M. N. Katehakis. On the finite horizon one-armed bandit problem. Stochastic Analysis and Applications, 16(1):845­859, 1997b. [454]
A. N. Burnetas and M. N. Katehakis. Asymptotic Bayes analysis for the finite-horizon one-armed-bandit problem. Probability in the Engineering and Informational Sciences, 17(1):53­82, 2003. [455]
R. R. Bush and F. Mosteller. A stochastic model with applications to learning. The Annals of Mathematical Statistics, pages 559­585, 1953. [16]
O. Capp´e, A. Garivier, O. Maillard, R. Munos, and G. Stoltz. Kullback­Leibler upper confidence bounds for optimal sequential allocation. The Annals of Statistics, 41(3):1516­1541, 2013. [120, 140, 141, 209]
A. Carpentier and A. Locatelli. Tight (lower) bounds for the fixed budget best arm identification bandit problem. In Proceedings of the 29th Conference on Learning Theory, pages 590­604, New York, NY, USA, 2016. JMLR.org. [413]
A. Carpentier and R. Munos. Bandit theory meets compressed sensing for high dimensional stochastic linear bandit. In Proceedings of the 15th International Conference on Artificial Intelligence and Statistics, pages 190­198, La Palma, Canary Islands, 2012. JMLR.org. [285, 354]
A. Carpentier and M. Valko. Extreme bandits. In Advances in Neural Information Processing Systems, pages 1089­1097. Curran Associates, Inc., 2014. [415]
A. Carpentier and M. Valko. Simple regret for infinitely many armed bandits. In Proceedings of the 32nd International Conference on Machine Learning, pages 1133­1141, Lille, France, 2015. PMLR. [357]
O. Catoni. Challenging the empirical mean and empirical variance: a deviation study. Annales de l'Institut Henri Poincar´e, Probabilit´es et Statistiques, 48(4): 1148­1185, 2012. [115]
N. Cesa-Bianchi and G. Lugosi. Prediction, learning, and games. Cambridge University Press, 2006. [17, 157, 342, 384, 432, 505]
N. Cesa-Bianchi and G. Lugosi. Combinatorial bandits. Journal of Computer and System Sciences, 78(5):1404­1422, 2012. [372]
N. Cesa-Bianchi, G. Lugosi, and G. Stoltz. Regret minimization under partial monitoring. Mathematics of Operations Research, 31:562­580, 2006. [505]
N. Cesa-Bianchi, C. Gentile, Y. Mansour, and A. Minora. Delay and cooperation in nonstochastic bandits. In Proceedings of the 29th Conference on Learning Theory, pages 605­622, New York, NY, USA, 2016. JMLR.org. [359]

BIBLIOGRAPHY

556

N. Cesa-Bianchi, C. Gentile, G. Lugosi, and G. Neu. Boltzmann exploration done right. In Advances in Neural Information Processing Systems, pages 6284­6293. Curran Associates, Inc., 2017. [95]
J. Chakravorty and A. Mahajan. Multi-armed bandits, Gittins index, and its calculation. Methods and Applications of Statistics in Clinical Trials: Planning, Analysis, and Inferential Methods, 2:416­435, 2013. [455]
J. Chakravorty and A. Mahajan. Multi-armed bandits, Gittins index, and its calculation. Methods and Applications of Statistics in Clinical Trials: Planning, Analysis, and Inferential Methods, 2:416­435, 2014. [455]
H. P. Chan and T. L. Lai. Sequential generalized likelihood ratios and adaptive treatment allocation for optimal sequential selection. Sequential Analysis, 25: 179­201, 2006. [414]
J. T. Chang and D. Pollard. Conditioning as disintegration. Statistica Neerlandica, 51(3):287­317, 1997. [434]
O. Chapelle and L. Li. An empirical evaluation of Thompson sampling. In Advances in Neural Information Processing Systems, pages 2249­2257. Curran Associates, Inc., 2011. [472]
S. Chaudhuri and A. Tewari. Phased exploration with greedy exploitation in stochastic combinatorial partial monitoring games. In Advances in Neural Information Processing Systems, pages 2433­2441, 2016. [506]
C-H. Chen, J. Lin, E. Yu¨cesan, and S. E. Chick. Simulation budget allocation for further enhancing the efficiency of ordinal optimization. Discrete Event Dynamic Systems, 10(3):251­270, 2000. [415]
S. Chen, T. Lin, I. King, M. R. Lyu, and W. Chen. Combinatorial pure exploration of multi-armed bandits. In Advances in Neural Information Processing Systems, pages 379­387. Curran Associates, Inc., 2014. [413]
W. Chen, Y. Wang, and Y. Yuan. Combinatorial multi-armed bandit: General framework and applications. In Proceedings of the 30th International Conference on Machine Learning, pages 151­159, Atlanta, Georgia, USA, 17­19 Jun 2013. PMLR. [372]
W. Chen, W. Hu, F. Li, J. Li, Y. Liu, and P. Lu. Combinatorial multi-armed bandit with general reward functions. In Advances in Neural Information Processing Systems, pages 1659­1667. Curran Associates, Inc., 2016a. [372]
W. Chen, Y. Wang, Y. Yuan, and Q. Wang. Combinatorial multi-armed bandit and its extension to probabilistically triggered arms. Journal of Machine Learning Research, 17(50):1­33, 2016b. URL http://jmlr.org/papers/v17/ 14-298.html. [372]
Y. Chen, C-W. Lee, H. Luo, and C-Y. Wei. A new algorithm for non-stationary contextual bandits: Efficient, optimal, and parameter-free. arXiv:1902.00980, 2019. [382, 384]
Y. R. Chen and M. N. Katehakis. Linear programming for finite state multi-armed bandit problems. Mathematics of Operations Research, 11(1):180­183, 1986. [455]

BIBLIOGRAPHY

557

H. Chernoff. Sequential design of experiments. The Annals of Mathematical Statistics, 30(3):755­770, 1959. [17, 413]
H. Chernoff. A career in statistics. Past, Present, and Future of Statistical Science, page 29, 2014. [140]
W. Cheung, D. Simchi-Levi, and R. Zhu. Learning to optimize under nonstationarity. In Proceedings of the 22nd International Conference on Artificial Intelligence and Statistics, pages 1079­1087. PMLR, 16­18 Apr 2019. [384]
W. Chu, L. Li, L. Reyzin, and R. Schapire. Contextual bandits with linear payoff functions. In Proceedings of the 14th International Conference on Artificial Intelligence and Statistics, pages 208­214, Fort Lauderdale, FL, USA, 2011. JMLR.org. [273]
A. Chuklin, I. Markov, and M. de Rijke. Click Models for Web Search. Morgan & Claypool Publishers, 2015. [398]
V. A. Cicirello and S. F. Smith. The max k-armed bandit: A new model of exploration applied to search heuristic selection. In AAAI, pages 1355­1361, 2005. [415]
A. Cohen and T. Hazan. Following the perturbed leader for online structured learning. In Proceedings of the 32nd International Conference on Machine Learning, pages 1034­1042, Lille, France, 07­09 Jul 2015. JMLR.org. [372, 374]
A. Cohen, T. Hazan, and T. Koren. Tight bounds for bandit combinatorial optimization. In Proceedings of the 2017 Conference on Learning Theory, pages 629­642, Amsterdam, Netherlands, 2017. JMLR.org. [370]
R. Combes, S. Magureanu, A. Proutiere, and C. Laroche. Learning to rank: Regret lower bounds and efficient algorithms. In Proceedings of the 2015 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems, pages 231­244. ACM, 2015a. ISBN 978-1-4503-3486-0. [398]
R. Combes, M. Shahi, A. Proutiere, and M. Lelarge. Combinatorial bandits revisited. In Advances in Neural Information Processing Systems, pages 2116­ 2124. Curran Associates, Inc., 2015b. [372]
R. Combes, S. Magureanu, and A. Prouti`ere. Minimal exploration in structured stochastic bandits. In Advances in Neural Information Processing Systems, pages 1761­1769, 2017. [245, 248, 300, 357]
A. R. Conn, K. Scheinberg, and L. N. Vicente. Introduction to Derivative-Free Optimization. SIAM, 2009. [414]
T. M. Cover. Universal portfolios. Mathematical Finance, 1(1):1­29, 1991. [322] T. M. Cover and J. A. Thomas. Elements of information theory. John Wiley &
Sons, 2012. [193] W. Cowan and M. N. Katehakis. An asymptotically optimal policy for uniform
bandits of unknown support. arXiv:1505.01918, 2015. [209] W. Cowan, J. Honda, and M. N. Katehakis. Normal bandits of unknown means
and variances. Journal of Machine Learning Research, 18(154):1­28, 2018. [209]

BIBLIOGRAPHY

558

K. Crammer and C. Gentile. Multiclass classification with bandit feedback using adaptive regularization. Machine learning, 90(3):347­383, 2013. [285]
N. Craswell, O. Zoeter, M. Taylor, and B. Ramsey. An experimental comparison of click position-bias models. In Proceedings of the 2008 International Conference on Web Search and Data Mining, pages 87­94. ACM, 2008. [398]
V. Dani and T. P. Hayes. Robbing the bandit: Less regret in online geometric optimization against an adaptive adversary. In 17th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 937­943, 2006. [372]
V. Dani, T. P. Hayes, and S. M. Kakade. Stochastic linear optimization under bandit feedback. In Proceedings of the 21st Conference on Learning Theory, pages 355­366, 2008. [245, 293]
V. H. de la Pen~a, T.L. Lai, and Q. Shao. Self-normalized processes: Limit theory and Statistical Applications. Springer Science & Business Media, 2008. [80, 86, 260]
R. Degenne and W. M. Koolen. Pure exploration with multiple correct answers. In Advances in Neural Information Processing Systems, pages 14591­14600. Curran Associates, Inc., 2019. [413]
R. Degenne and V. Perchet. Anytime optimal algorithms in stochastic multiarmed bandits. In Proceedings of the 33rd International Conference on Machine Learning, pages 1587­1595, New York, NY, USA, 20­22 Jun 2016. JMLR.org. [128]
R. Degenne, W. M. Koolen, and P. M´enard. Non-asymptotic pure exploration by solving games. In Advances in Neural Information Processing Systems, pages 14492­14501. Curran Associates, Inc., 2019. [413]
O. Dekel, C. Gentile, and K. Sridharan. Robust selective sampling from single and multiple teachers. In Proceedings of the 23rd Conference on Learning Theory, pages 346­358, 2010. [285]
O. Dekel, C. Gentile, and K. Sridharan. Selective sampling and active learning from single and multiple teachers. Journal of Machine Learning Research, 13: 2655­2697, 2012. [285]
A. Dembo and O. Zeitouni. Large deviations techniques and applications, volume 38. Springer Science & Business Media, 2009. [83]
E. V. Denardo, H. Park, and U. G. Rothblum. Risk-sensitive and risk-neutral multiarmed bandits. Mathematics of Operations Research, 32(2):374­394, 2007. [68]
T. Desautels, A. Krause, and J. W. Burdick. Parallelizing exploration-exploitation tradeoffs in gaussian process bandit optimization. Journal of Machine Learning Research, 15:4053­4103, 2014. [359]
R. L. Dobrushin. Eine allgemeine formulierung des fundamentalsatzes von shannon in der informationstheorie. Usp. Mat. Nauk, 14(6(90)):3­104, 1959. [193]
S. Dong and B. Van Roy. An information-theoretic analysis for Thompson sampling with many actions. In Advances in Neural Information Processing Systems, Red Hook, NY, USA, 2018. Curran Associates Inc. [470]
J. L. Doob. Stochastic processes. Wiley, 1953. [54]

BIBLIOGRAPHY

559

M. Dud´ik, D. Hsu, S. Kale, N. Karampatziakis, J. Langford, L. Reyzin, and T. Zhang. Efficient optimal learning for contextual bandits. In Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence, pages 169­178. AUAI Press, 2011. [232]
M. Dud´ik, K. Hofmann, R. E. Schapire, A. Slivkins, and M. Zoghi. Contextual dueling bandits. In Proceedings of the 28th Conference on Learning Theory, pages 563­587, Paris, France, 2015. JMLR.org. [358]
R. M. Dudley. Uniform central limit theorems, volume 142. Cambridge University Press, 2014. [80, 340]
C. G. Esseen. On the Liapounoff limit of error in the theory of probability. Almqvist & Wiksell, 1942. [78]
E. Even-Dar, S. Mannor, and Y. Mansour. PAC bounds for multi-armed bandit and Markov decision processes. In Computational Learning Theory, pages 255­270. Springer, 2002. [413, 418]
E. Even-Dar, S. M. Kakade, and Y. Mansour. Experts in a Markov decision process. In Advances in Neural Information Processing Systems, pages 401­408, Cambridge, MA, USA, 2004. MIT Press. [536]
E. Even-Dar, S. Mannor, and Y. Mansour. Action elimination and stopping conditions for the multi-armed bandit and reinforcement learning problems. Journal of Machine Learning Research, 7:1079­1105, 2006. [413]
V. V. Fedorov. Theory of optimal experiments. Academic Press, New York, 1972. [269]
S. Filippi, O. Capp´e, A. Garivier, and Cs. Szepesv´ari. Parametric bandits: The generalized linear case. In Advances in Neural Information Processing Systems, pages 586­594. Curran Associates, Inc., 2010. [245, 246]
D. Fink. A compendium of conjugate priors, 1997. [434] D. Foster and A. Rakhlin. No internal regret via neighborhood watch. In
Proceedings of the 15th International Conference on Artificial Intelligence and Statistics, pages 382­390, La Palma, Canary Islands, 2012. JMLR.org. [505] D. J. Foster and A. Rakhlin. Beyond UCB: Optimal and efficient contextual bandits with regression oracles. arXiv:2002.04926, 2020. [293] M. Frank and P. Wolfe. An algorithm for quadratic programming. Naval Research Logistics Quarterly, 3(1-2):95­110, 1956. [269] S. Frederick, G. Loewenstein, and T. O'donoghue. Time discounting and time preference: A critical review. Journal of Economic Literature, 40(2):351­401, 2002. [453] E. Frostig and G. Weiss. Four proofs of Gittins' multiarmed bandit theorem. Applied Probability Trust, 70, 1999. [455] R. Fruit, M. Pirotta, and A. Lazaric. Near optimal exploration-exploitation in non-communicating markov decision processes. In Advances in Neural Information Processing Systems, pages 2997­3007, 2018. [535, 544, 546] Y. Gai, B. Krishnamachari, and R. Jain. Combinatorial network optimization with unknown variables: Multi-armed bandits with linear rewards and individual

BIBLIOGRAPHY

560

observations. IEEE/ACM Transactions on Networking, 20(5):1466­1478, 2012. [372] P. Gajane, R. Ortner, and P. Auer. A sliding-window algorithm for Markov decision processes with arbitrarily changing rewards and transitions. arXiv:1805.10066, 2018. [384] A. Garivier. Informational confidence bounds for self-normalized averages and applications. arXiv:1309.3376, 2013. [111, 127] A. Garivier and O. Capp´e. The KL-UCB algorithm for bounded stochastic bandits and beyond. In Proceedings of the 24th Conference on Learning Theory, 2011. [139, 140] A. Garivier and E. Kaufmann. Optimal best arm identification with fixed confidence. In Proceedings of the 29th Conference on Learning Theory, pages 998­1027, New York, NY, USA, 2016. JMLR.org. [413] A. Garivier and E. Moulines. On upper-confidence bound policies for switching bandit problems. In Proceedings of the 22nd International Conference on Algorithmic Learning Theory, pages 174­188, Berlin, Heidelberg, 2011. Springer Berlin Heidelberg. [384] A. Garivier, E. Kaufmann, and W. M. Koolen. Maximin action identification: A new bandit framework for games. In Proceedings of the 29th Conference on Learning Theory, pages 1028­1050, New York, NY, USA, 2016a. JMLR.org. [413] A. Garivier, T. Lattimore, and E. Kaufmann. On explore-then-commit strategies. In Advances in Neural Information Processing Systems, pages 784­792. Curran Associates, Inc., 2016b. [94, 119, 209] A. Garivier, P. M´enard, and G. Stoltz. Explore first, exploit next: The true shape of regret in bandit problems. Mathematics of Operations Research, 44 (2):377­399, 2019. [209] A. Gelman, J. B. Carlin, H. S. Stern, D. B. Dunson, A. Vehtari, and D. B. Rubin. Bayesian data analysis, volume 2. CRC Press Boca Raton, FL, 2014. [434] C. Gentile and F. Orabona. On multilabel classification and ranking with partial feedback. In Advances in Neural Information Processing Systems, pages 1151­ 1159. Curran Associates, Inc., 2012. [285] C. Gentile and F. Orabona. On multilabel classification and ranking with bandit feedback. Journal of Machine Learning Research, 15(1):2451­2487, 2014. [285] S. Gerchinovitz. Sparsity regret bounds for individual sequences in online linear regression. Journal of Machine Learning Research, 14(Mar):729­769, 2013. [285] S. Gerchinovitz and T. Lattimore. Refined lower bounds for adversarial bandits. In Advances in Neural Information Processing Systems, pages 1198­1206. Curran Associates, Inc., 2016. [201, 218] S. Ghosal and A. van der Vaart. Fundamentals of nonparametric Bayesian inference, volume 44. Cambridge University Press, 2017. [433, 434] A. Ghosh, S. R. Chowdhury, and A. Gopalan. Misspecified linear bandits. In 31st AAAI Conference on Artificial Intelligence, 2017. [273]

BIBLIOGRAPHY

561

J. Gittins. Bandit processes and dynamic allocation indices. Journal of the Royal Statistical Society. Series B (Methodological), 41(2):148­177, 1979. [383, 455]
J. Gittins, K. Glazebrook, and R. Weber. Multi-armed bandit allocation indices. John Wiley & Sons, 2011. [17, 383, 455]
D. Glowacka. Bandit algorithms in information retrieval. Foundations and TrendsÂ in Information Retrieval, 13:299­424, 01 2019. [399]
P. Glynn and S. Juneja. Ordinal optimization ­ empirical large deviations rate estimators, and stochastic multi-armed bandits. arXiv:1507.04564, 2015. [415]
D. Goldsman. Ranking and selection in simulation. In 15th conference on Winter Simulation, pages 387­394, 1983. [415]
A. Gopalan and S. Mannor. Thompson sampling for learning parameterized Markov decision processes. In Proceedings of the 28th Conference on Learning Theory, pages 861­898, Paris, France, 2015. JMLR.org. [472]
G. J. Gordon. Regret bounds for prediction problems. In Proceedings of the 12th Conference on Learning Theory, pages 29­40, 1999. [341, 342]
T. Graepel, J. Q. Candela, T. Borchert, and R. Herbrich. Web-scale Bayesian click-through rate prediction for sponsored search advertising in microsoft's bing search engine. In Proceedings of the 27th International Conference on Machine Learning, pages 13­20, USA, 2010. Omnipress. [472]
O. Granmo. Solving two-armed bernoulli bandit problems using a Bayesian learning automaton. International Journal of Intelligent Computing and Cybernetics, 3(2):207­234, 2010. [472]
R. M. Gray. Entropy and information theory. Springer Science & Business Media, 2011. [193]
K. Greenewald, A. Tewari, S. Murphy, and P. Klasnja. Action centered contextual bandits. In Advances in Neural Information Processing Systems, pages 5977­ 5985. Curran Associates, Inc., 2017. [17]
M. Gro¨tschel, L. Lova´sz, and A. Schrijver. Geometric algorithms and combinatorial optimization, volume 2. Springer Science & Business Media, 2012. [269, 371, 534]
F. Guo, C. Liu, and Y. M. Wang. Efficient multiple-click models in web search. In Proceedings of the 2nd ACM International Conference on Web Search and Data Mining, pages 124­131. ACM, 2009. [399]
A. Gyo¨rgy and Cs. Szepesva´ri. Shifting regret, mirror descent, and matrices. In Proceedings of the 33rd International Conference on Machine Learning, pages 2943­2951, New York, NY, USA, 20­22 Jun 2016. JMLR.org. [384]
A. Gy¨orgy, T. Linder, G. Lugosi, and G. Ottucs´ak. The on-line shortest path problem under partial monitoring. Journal of Machine Learning Research, 8 (Oct):2369­2403, 2007. [372, 373]
A. Gyo¨rgy, D. Pa´l, and Cs. Szepesva´ri. Online learning: Algorithms for Big Data. 2019. [384]
P. R. Halmos. Measure Theory. Graduate Texts in Mathematics. Springer New York, 1976. [53]

BIBLIOGRAPHY

562

N. Hamidi and M. Bayati. A general framework to analyze stochastic linear bandit. arXiv:2002.05152, 2020. [470]
M. Hanawal, V. Saligrama, M. Valko, and R. Munos. Cheap bandits. In Proceedings of the 32nd International Conference on Machine Learning, pages 2133­2142, Lille, France, 07­09 Jul 2015. JMLR.org. [359]
J. Hannan. Approximation to Bayes risk in repeated play. Contributions to the Theory of Games, 3:97­139, 1957. [146, 342, 372]
B. Hao, T. Lattimore, and Cs. Szepesv´ari. Adaptive exploration in linear contextual bandit. In Proceedings of the 23rd International Conference on Artificial Intelligence and Statistics, 2020. [245, 300]
G. H. Hardy. Divergent Series. Oxford University Press, 1973. [532] E. Hazan. Introduction to online convex optimization. Foundations and Trends®
in Optimization, 2(3-4):157­325, 2016. [341, 342] E. Hazan and S. Kale. A simple multi-armed bandit algorithm with optimal
variation-bounded regret. In Proceedings of the 24th Conference on Learning Theory, pages 817­820. JMLR.org, 2011. [170] E. Hazan, Z. Karnin, and R. Meka. Volumetric spanners: an efficient exploration basis for learning. Journal of Machine Learning Research, 17(119):1­34, 2016. [269, 322] D. P. Helmbold, N. Littlestone, and P. M. Long. Apple tasting. Information and Computation, 161(2):85­139, 2000. [506] M. Herbster and M. K. Warmuth. Tracking the best expert. Machine Learning, 32(2):151­178, 1998. [383] M. Herbster and M. K. Warmuth. Tracking the best linear predictor. Journal of Machine Learning Research, 1(Sep):281­309, 2001. [384] Y-C. Ho, R. S. Sreenivas, and P. Vakili. Ordinal optimization of DEDS. Discrete Event Dynamic Systems, 1992. [415] J. Honda and A. Takemura. An asymptotically optimal bandit algorithm for bounded support models. In Proceedings of the 23rd Conference on Learning Theory, pages 67­79, 2010. [120, 128, 139, 140, 208, 209] J. Honda and A. Takemura. An asymptotically optimal policy for finite support models in the multiarmed bandit problem. Machine Learning, 85(3):361­391, 2011. [120] J. Honda and A. Takemura. Optimality of Thompson sampling for Gaussian bandits depends on priors. In Proceedings of the 17th International Conference on Artificial Intelligence and Statistics, pages 375­383, Reykjavik, Iceland, 2014. JMLR.org. [472] J. Honda and A. Takemura. Non-asymptotic analysis of a new bandit algorithm for semi-bounded rewards. Journal of Machine Learning Research, 16:3721­3756, 2015. [140, 208, 209] X. Hu, Prashanth L.A., A. Gy¨orgy, and Cs. Szepesv´ari. (Bandit) convex optimization with biased noisy gradient oracles. In AISTATS, pages 819­ 828, 2016. [358, 414]

BIBLIOGRAPHY

563

R. Huang, M. M. Ajallooeian, Cs. Szepesva´ri, and M. Mu¨ller. Structured best arm identification with fixed confidence. In Proceedings of the 28th International Conference on Algorithmic Learning Theory, pages 593­616, Kyoto, Japan, 2017a. JMLR.org. [413]
R. Huang, T. Lattimore, A. Gy¨orgy, and Cs. Szepesv´ari. Following the leader and fast rates in online linear prediction: Curved constraint sets and other regularities. Journal of Machine Learning Research, 18:1­31, 2017b. [340]
W. Huang, J. Ok, L. Li, and W. Chen. Combinatorial pure exploration with continuous and separable reward functions and its applications. In IJCAI, pages 2291­2297, 2018. [413]
M. Hutter. Universal artificial intelligence: Sequential decisions based on algorithmic probability. Springer Science & Business Media, 2004. [432]
M. Hutter and J. Poland. Adaptive online prediction by following the perturbed leader. Journal of Machine Learning Research, 6:639­660, 2005. [372]
E. L. Ionides. Truncated importance sampling. Journal of Computational and Graphical Statistics, 17(2):295­311, 2008. [171]
V. I. Ivanenko and V. A. Labkovsky. On regularities of mass random phenomena. arXiv:1204.4440, 2013. [146]
T. Jaksch, P. Auer, and R. Ortner. Near-optimal regret bounds for reinforcement learning. Journal of Machine Learning Research, 99:1563­1600, August 2010. ISSN 1532-4435. [535, 538]
K. Jamieson and R. Nowak. Best-arm identification algorithms for multi-armed bandits in the fixed confidence setting. In Information Sciences and Systems (CISS), 2014 48th Annual Conference on, pages 1­6. IEEE, 2014. [413]
K. Jamieson and A. Talwalkar. Non-stochastic best arm identification and hyperparameter optimization. In Proceedings of the 19th International Conference on Artificial Intelligence and Statistics, pages 240­248, 2016. [415]
K. Jamieson, S. Katariya, A. Deshpande, and R. Nowak. Sparse dueling bandits. In Proceedings of the 18th International Conference on Artificial Intelligence and Statistics, pages 416­424, San Diego, CA, USA, 2015. JMLR.org. [358]
E. T. Jaynes. Probability theory: the logic of science. Cambridge University Press, 2003. [433, 434]
A. Jefferson, L. Bortolotti, and B. Kuzmanovic. What is unrealistic optimism? Consciousness and Cognition, 50:3­11, 2017. [110]
P. Joulani, A. Gyo¨rgy, and Cs. Szepesva´ri. Online learning under delayed feedback. In Proceedings of the 30th International Conference on Machine Learning, pages 1453­1461, Atlanta, GA, USA, 2013. JMLR.org. [359]
P. Joulani, A. Gyo¨rgy, and Cs. Szepesva´ri. A modular analysis of adaptive (non)convex optimization: Optimism, composite objectives, and variational bounds. In Proceedings of the 28th International Conference on Algorithmic Learning Theory, pages 681­720, Kyoto University, Kyoto, Japan, 2017. JMLR.org. [338]
K. Jun, A. Bhargava, R. Nowak, and R. Willett. Scalable generalized linear bandits: Online computation and hashing. In Advances in Neural Information Processing Systems, pages 99­109. Curran Associates, Inc., 2017. [246]

BIBLIOGRAPHY

564

L. P. Kaelbling. Learning in embedded systems. MIT Press, 1993. [110]
D. Kahneman and A. Tversky. Prospect theory: An analysis of decision under risk. Econometrica, 47(2):263­91, 1979. [67]
S. Kakade. On The Sample Complexity Of Reinforcement Learning. PhD thesis, University College London, 2003. [536]
S. M. Kakade, S. Shalev-Shwartz, and A. Tewari. Efficient bandit algorithms for online multiclass prediction. In Proceedings of the 25th International Conference on Machine Learning, pages 440­447, 2008. [232]
A. Kalai and S. Vempala. Geometric algorithms for online optimization. Technical Report MIT-LCS-TR-861, MIT, 2002. [342, 372]
A. Kalai and S. Vempala. Efficient algorithms for online decision problems. Journal of Computer and System Sciences, 71(3):291­307, 2005. [372]
L. Kallenberg. A note on M.N. Katehakis' and Y.-R. Chen's computation of the Gittins index. Mathematics of Operations Research, 11(1):184­186, 1986. [455]
L. Kallenberg. Markov decision processes: Lecture notes, 2016. [534]
O. Kallenberg. Foundations of modern probability. Springer-Verlag, 2002. [41, 42, 52, 53, 54, 194, 262, 435]
Z. Karnin, T. Koren, and O. Somekh. Almost optimal exploration in multi-armed bandits. In Proceedings of the 30th International Conference on Machine Learning, pages 1238­1246, Atlanta, GA, USA, 2013. JMLR.org. [413]
N. El Karoui and I. Karatzas. Dynamic allocation problems in continuous time. The Annals of Applied Probability, pages 255­286, 1994. [455]
S. Katariya, B. Kveton, Cs. Szepesva´ri, and Z. Wen. DCM bandits: Learning to rank with multiple clicks. In Proceedings of the 33rd International Conference on Machine Learning, pages 1215­1224, 2016. [399]
S. Katariya, B. Kveton, Cs. Szepesv´ari, C. Vernade, and Z. Wen. Bernoulli rank-1 bandits for click feedback. In Proceedings of the 26th International Joint Conference on Artificial Intelligence, 2017a. [399]
S. Katariya, B. Kveton, Cs. Szepesva´ri, C. Vernade, and Z. Wen. Stochastic rank1 bandits. In Proceedings of the 20th International Conference on Artificial Intelligence and Statistics, 2017b. [399]
M. N. Katehakis and H. Robbins. Sequential choice from several populations. Proceedings of the National Academy of Sciences of the United States of America, 92(19):8584, 1995. [110, 119, 120]
V. Ya Katkovnik and Yu Kulchitsky. Convergence of a class of random search algorithms. Automation Remote Control, 8:1321­1326, 1972. [414]
E. Kaufmann. On Bayesian index policies for sequential resource allocation. The Annals of Statistics, 46(2):842­865, 04 2018. [120, 128, 470, 472]
E. Kaufmann, O. Capp´e, and A. Garivier. On Bayesian upper confidence bounds for bandit problems. In Proceedings of the 15th International Conference on Artificial Intelligence and Statistics, pages 592­600, La Palma, Canary Islands, 2012a. JMLR.org. [470, 472]

BIBLIOGRAPHY

565

E. Kaufmann, N. Korda, and R. Munos. Thompson sampling: An asymptotically optimal finite-time analysis. In Proceedings of the 23rd International Conference on Algorithmic Learning Theory, volume 7568 of Lecture Notes in Computer Science, pages 199­213. Springer Berlin Heidelberg, 2012b. ISBN 978-3-64234105-2. [120, 469, 472]
J. Kawale, H. H. Bui, B. Kveton, L. Tran-Thanh, and S. Chawla. Efficient Thompson sampling for online matrix-factorization recommendation. In Advances in Neural Information Processing Systems, pages 1297­1305. Curran Associates, Inc., 2015. [472]
A. Kazerouni, M. Ghavamzadeh, Y. Abbasi, and B. Van Roy. Conservative contextual linear bandits. In Advances in Neural Information Processing Systems, pages 3910­3919. Curran Associates, Inc., 2017. [359]
M. Kearns and L. Saul. Large deviation methods for approximate probabilistic inference. In Proceedings of the 14th Conference on Uncertainty in Artificial Intelligence, page 311â319. Morgan Kaufmann Publishers Inc., 1998. [84]
M. Kearns and S. Singh. Near-optimal reinforcement learning in polynomial time. Machine Learning, 49(2-3):209­232, 2002. [536]
M. J. Kearns and U. V. Vazirani. An introduction to computational learning theory. MIT Press, 1994. [232]
J. Kiefer and J. Wolfowitz. The equivalence of two extremum problems. Canadian Journal of Mathematics, 12(5):363­365, 1960. [269]
G-S. Kim and M. C. Paik. Doubly-robust lasso bandit. In Advances in Neural Information Processing Systems, pages 5877­5887. Curran Associates, Inc., 2019. [284]
M. J. Kim. Thompson sampling for stochastic control: The finite parameter case. IEEE Transactions on Automatic Control, 62(12):6415­6422, 2017. [472]
J. Kirschner and A. Krause. Information directed sampling and bandits with heteroscedastic noise. In Proceedings of the 31st Conference On Learning Theory, pages 358­384. PMLR, 06­09 Jul 2018. [87, 245]
J. Kirschner, T. Lattimore, and A. Krause. Information directed sampling for linear partial monitoring. arXiv:2002.11182, 2020. [506]
R. Kleinberg. Nearly tight bounds for the continuum-armed bandit problem. In Advances in Neural Information Processing Systems, pages 697­704. MIT Press, 2005. [357]
R. Kleinberg, A. Slivkins, and E. Upfal. Multi-armed bandits in metric spaces. In Proceedings of the 40th Annual ACM Symposium on Theory of Computing, pages 681­690. ACM, 2008. [357]
T. Koc´ak, G. Neu, M. Valko, and R. Munos. Efficient learning by implicit exploration in bandit problems with side observations. In Advances in Neural Information Processing Systems, pages 613­621. Curran Associates, Inc., 2014. [170, 171, 359]
T. Koc´ak, M. Valko, R. Munos, and S. Agrawal. Spectral Thompson sampling. In AAAI, pages 1911­1917, 2014. [472]

BIBLIOGRAPHY

566

L. Kocsis and Cs. Szepesv´ari. Discounted UCB. In 2nd PASCAL Challenges Workshop, pages 784­791, 2006. [17, 384]
H. Komiya. Elementary proof for Sion's minimax theorem. Kodai Mathematical Journal, 11(1):5­7, 1988. [341]
J. Komiyama, J. Honda, H. Kashima, and H. Nakagawa. Regret lower bound and optimal algorithm in dueling bandit problem. In Proceedings of the 28th Conference on Learning Theory, pages 1141­1154, Paris, France, 2015a. JMLR.org. [358]
J. Komiyama, J. Honda, and H. Nakagawa. Regret lower bound and optimal algorithm in finite stochastic partial monitoring. In Advances in Neural Information Processing Systems, pages 1792­1800. Curran Associates, Inc., 2015b. [505]
W. M. Koolen, M. K. Warmuth, and J. Kivinen. Hedging structured concepts. In Proceedings of the 23rd Conference on Learning Theory, pages 93­105. Omnipress, 2010. [372]
N. Korda, E. Kaufmann, and R. Munos. Thompson sampling for 1-dimensional exponential family bandits. In Advances in Neural Information Processing Systems, pages 1448­1456. Curran Associates, Inc., 2013. [120, 141, 469, 472]
J. Kujala and T. Elomaa. On following the perturbed leader in the bandit setting. In Proceedings of the 16th International Conference on Algorithmic Learning Theory, pages 371­385, 2005. [372]
J. Kujala and T. Elomaa. Following the perturbed leader to gamble at multi-armed bandits. In Proceedings of the 18th International Conference on Algorithmic Learning Theory, pages 166­180. Springer, 2007. [372]
S. R. Kulkarni and G. Lugosi. Finite-time lower bounds for the two-armed bandit problem. IEEE Transactions on Automatic Control, 45(4):711­714, 2000. [209]
B. Kveton, Cs. Szepesva´ri, Z. Wen, and A. Ashkan. Cascading bandits: Learning to rank in the cascade model. In Proceedings of the 32nd International Conference on Machine Learning, pages 767­776. JMLR.org, 2015a. [398]
B. Kveton, Z. Wen, A. Ashkan, and Cs. Szepesv´ari. Tight regret bounds for stochastic combinatorial semi-bandits. In Proceedings of the 18th International Conference on Artificial Intelligence and Statistics, pages 535­543, San Diego, CA, USA, 2015b. JMLR.org. [372]
B. Kveton, Z. Wen, Z. Ashkan, and Cs. Szepesv´ari. Combinatorial cascading bandits. In Advances in Neural Information Processing Systems, pages 1450­ 1458. Curran Associates Inc., 2015c. [399]
B. Kveton, Cs. Szepesv´ari, S. Vaswani, Z. Wen, T. Lattimore, and M. Ghavamzadeh. Garbage in, reward out: Bootstrapping exploration in multi-armed bandits. In Proceedings of the 36th International Conference on Machine Learning, pages 3601­3610, Long Beach, California, USA, 09­15 Jun 2019. PMLR. [472]
P. Lagree, C. Vernade, and O. Capp´e. Multiple-play bandits in the positionbased model. In Advances in Neural Information Processing Systems, pages 1597­1605. Curran Associates Inc., 2016. [399]

BIBLIOGRAPHY

567

T. L. Lai. Adaptive treatment allocation and the multi-armed bandit problem. The Annals of Statistics, pages 1091­1114, 1987. [110, 119, 128, 140, 454, 455]
T. L. Lai. Martingales in sequential analysis and time series, 1945­1985. Electronic Journal for history of probability and statistics, 5(1), 2009. [260]
T. L. Lai and T. Graves. Asymptotically efficient adaptive choice of control laws in controlled Markov chains. SIAM Journal on Control and Optimization, 35 (3):715­743, 1997. [535]
T. L. Lai and H. Robbins. Asymptotically efficient adaptive allocation rules. Advances in applied mathematics, 6(1):4­22, 1985. [68, 110, 119, 140, 209, 264]
J. Langford and T. Zhang. The epoch-greedy algorithm for multi-armed bandits with side information. In Advances in Neural Information Processing Systems, pages 817­824. Curran Associates, Inc., 2008. [94, 234]
P. Laplace. Pierre-Simon Laplace Philosophical Essay on Probabilities: Translated from the fifth French edition of 1825 With Notes by the Translator, volume 13. Springer Science & Business Media, 2012. [42]
T. Lattimore. The Pareto regret frontier for bandits. In Advances in Neural Information Processing Systems, pages 208­216. Curran Associates, Inc., 2015a. [157, 293]
T. Lattimore. Optimally confident UCB: Improved regret for finite-armed bandits. arXiv:1507.07880, 2015b. [128]
T. Lattimore. Regret analysis of the finite-horizon Gittins index strategy for multi-armed bandits. In Proceedings of the 29th Annual Conference on Learning Theory, pages 1214­1245, New York, NY, USA, 2016a. JMLR.org. [119, 455]
T. Lattimore. Regret analysis of the anytime optimally confident ucb algorithm. arXiv:1603.08661, 2016b. [128]
T. Lattimore. Regret analysis of the finite-horizon Gittins index strategy for multi-armed bandits. In Proceedings of the 29th Conference on Learning Theory, pages 1214­1245, 2016c. [454]
T. Lattimore. A scale free algorithm for stochastic bandits with bounded kurtosis. In Advances in Neural Information Processing Systems, pages 1584­1593. Curran Associates, Inc., 2017. [115, 208, 209]
T. Lattimore. Refining the confidence level for optimistic bandit strategies. Journal of Machine Learning Research, 2018. [98, 128, 130, 209]
T. Lattimore and M. Hutter. PAC bounds for discounted MDPs. In Proceedings of the 23th International Conference on Algorithmic Learning Theory, volume 7568 of Lecture Notes in Computer Science, pages 320­334. Springer Berlin / Heidelberg, 2012. [536]
T. Lattimore and R. Munos. Bounded regret for finite-armed structured bandits. In Advances in Neural Information Processing Systems, pages 550­558. Curran Associates, Inc., 2014. [246]
T. Lattimore and Cs. Szepesva´ri. The end of optimism? An asymptotic analysis of finite-armed linear bandits. In Proceedings of the 20th International Conference on Artificial Intelligence and Statistics, pages 728­737, Fort Lauderdale, FL, USA, 2017. JMLR.org. [245, 300]

BIBLIOGRAPHY

568

T. Lattimore and Cs. Szepesv´ari. Cleaning up the neighbourhood: A full classification for adversarial partial monitoring. In Proceedings of the 30th International Conference on Algorithmic Learning Theory, 2019a. [504, 505, 508]
T. Lattimore and Cs. Szepesva´ri. Learning with good feature representations in bandits and in RL with a generative model. arXiv:1911.07676, 2019b. [273, 293]
T. Lattimore and Cs. Szepesva´ri. An information-theoretic approach to minimax regret in partial monitoring. In Proceedings of the 32nd Conference on Learning Theory, pages 2111­2139, Phoenix, USA, 2019c. PMLR. [471, 472, 474, 505]
T. Lattimore and Cs. Szepesv´ari. Exploration by optimisation in partial monitoring. arXiv:1907.05772, 2019d. [503, 505, 509]
T. Lattimore, K. Crammer, and Cs. Szepesva´ri. Linear multi-resource allocation with semi-bandit feedback. In Advances in Neural Information Processing Systems, pages 964­972. Curran Associates, Inc., 2015. [285]
T. Lattimore, B. Kveton, S. Li, and Cs. Szepesva´ri. Toprank: A practical algorithm for online stochastic ranking. In Advances in Neural Information Processing Systems, pages 3949­3958. Curran Associates, Inc., 2018. [264, 374, 398]
B. Laurent and P. Massart. Adaptive estimation of a quadratic functional by model selection. Annals of Statistics, pages 1302­1338, 2000. [80]
A. Lazaric and R. Munos. Hybrid stochastic-adversarial on-line learning. In Proceedings of the 22nd Conference on Learning Theory, 2009. [232]
T. Le, Cs. Szepesv´ari, and R. Zheng. Sequential learning for multi-channel wireless network monitoring with channel switching costs. IEEE Transactions on Signal Processing, 62(22):5919­5929, 2014. [17]
L Le Cam. Convergence of estimates under dimensionality restrictions. The Annals of Statistics, 1(1):38­53, 1973. [201]
Y. T. Lee, A. Sidford, and S. S. Vempala. Efficient convex optimization with membership oracles. In Proceedings of the 31st Conference On Learning Theory, pages 1292­1294. JMLR.org, 06­09 Jul 2018. [371]
E. L. Lehmann and G. Casella. Theory of point estimation. Springer Science & Business Media, 2006. [434]
H. Lei, A. Tewari, and S. A. Murphy. An actor-critic contextual bandit algorithm for personalized mobile health interventions. arXiv:1706.09090, 2017. [17]
J. Leike, T. Lattimore, L. Orseau, and M. Hutter. Thompson sampling is asymptotically optimal in general environments. In Proceedings of the 32nd Conference on Uncertainty in Artificial Intelligence, pages 417­426. AUAI Press, 2016. [472]
H. R. Lerche. Boundary crossing of Brownian motion: Its relation to the law of the iterated logarithm and to sequential analysis. Springer, 1986. [130]
D. A. Levin and Y. Peres. Markov chains and mixing times, volume 107. American Mathematical Soc., 2017. [53]
L. A. Levin. On the notion of a random sequence. Soviet Mathematics Doklady, 14(5):1413­1416, 1973. [146]

BIBLIOGRAPHY

569

L. Li, K. Jamieson, G. DeSalvo, A. Rostamizadeh, and A. Talwalkar. Hyperband: A novel bandit-based approach to hyperparameter optimization. Journal of Machine Learning Research, 18(185):1­52, 2018. [415]
S. Li, B. Wang, S. Zhang, and W. Chen. Contextual combinatorial cascading bandits. In Proceedings of the 33rd International Conference on Machine Learning, pages 1245­1253, 2016. [399]
S. Li, T. Lattimore, and Cs. Szepesva´ri. Online learning to rank with features. In Proceedings of the 36th International Conference on Machine Learning, pages 3856­3865, Long Beach, California, USA, 09­15 Jun 2019a. PMLR. [397]
Y. Li, Y. Wang, and Y. Zhou. Nearly minimax-optimal regret for linearly parameterized bandits. In Proceedings of the 32nd Conference on Learning Theory, pages 2173­2174, Phoenix, USA, 2019b. JMLR.org. [244]
T. Liang, H. Narayanan, and A. Rakhlin. On zeroth-order stochastic convex optimization via random walks. arXiv:1402.2667, 2014. [414]
T. Lin, B. Abrahao, R. Kleinberg, J. Lui, and W. Chen. Combinatorial partial monitoring game with linear feedback and its applications. In Proceedings of the 31st International Conference on Machine Learning, pages 901­909, Bejing, China, 22­24 Jun 2014. PMLR. [506]
T. Lin, J. Li, and W. Chen. Stochastic online greedy learning with semi-bandit feedbacks. In Advances in Neural Information Processing Systems, pages 352­360. Curran Associates, Inc., 2015. [372]
N. Littlestone and M. K. Warmuth. The weighted majority algorithm. Information and Computation, 108(2):212­261, 1994. [146, 159]
L. Lov´asz and S. Vempala. The geometry of logconcave functions and sampling algorithms. Random Structures & Algorithms, 30(3):307­358, 2007. [322]
H. Luo, C-Y. Wei, A. Agarwal, and J. Langford. Efficient contextual bandits in non-stationary worlds. In Proceedings of the 31st Conference On Learning Theory, pages 1739­1776. JMLR.org, 06­09 Jul 2018. [384]
D. MacKay. Information theory, inference and learning algorithms. Cambridge University Press, 2003. [193]
S. Magureanu, R. Combes, and A. Prouti`ere. Lipschitz bandits: Regret lower bound and optimal algorithms. In Proceedings of the 27th Conference on Learning Theory, pages 975­999, 2014. [248, 357]
O. Maillard. Robust risk-averse stochastic multi-armed bandits. In Proceedings of the 24th International Conference on Algorithmic Learning Theory, pages 218­233. Springer, Berlin, Heidelberg, 2013. [68]
O. Maillard, R. Munos, and G. Stoltz. Finite-time analysis of multi-armed bandits problems with Kullback-Leibler divergences. In Proceedings of the 24th Conference on Learning Theory, 2011. [140]
S. Mannor and O. Shamir. From bandits to experts: On the value of sideobservations. In Advances in Neural Information Processing Systems, pages 684­692. Curran Associates, Inc., 2011. [359, 505]
S. Mannor and N. Shimkin. On-line learning with imperfect monitoring. In Learning Theory and Kernel Machines, pages 552­566. Springer, 2003. [505]

BIBLIOGRAPHY

570

S. Mannor and J. N. Tsitsiklis. The sample complexity of exploration in the multi-armed bandit problem. Journal of Machine Learning Research, 5:623­648, December 2004. [413]
S. Mannor, V. Perchet, and G. Stoltz. Set-valued approachability and online learning with partial monitoring. The Journal of Machine Learning Research, 15(1):3247­3295, 2014. [506]
H. Markowitz. Portfolio selection. The Journal of Finance, 7(1):77­91, 1952. [67]
M. E. Maron and J. L. Kuhns. On relevance, probabilistic indexing and information retrieval. Journal of the ACM, 7(3):216­244, 1960. [400]
P. Martin-Lo¨f. The definition of random sequences. Information and Control, 9 (6):602­619, 1966. [146]
A. Maurer and M. Pontil. Empirical Bernstein bounds and sample variance penalization. arXiv:0907.3740, 2009. [85, 114]
B. C. May, N. Korda, A. Lee, and D. S. Leslie. Optimistic Bayesian sampling in contextual-bandit problems. The Journal of Machine Learning Research, 13 (1):2069­2106, 2012. [472]
C. McDiarmid. Concentration. In Probabilistic methods for algorithmic discrete mathematics, pages 195­248. Springer, 1998. [80, 86, 262]
H. B. McMahan and A. Blum. Online geometric optimization in the bandit setting against an adaptive adversary. In Proceedings of the 17th Conference on Learning Theory, volume 3120, pages 109­123. Springer, 2004. [372]
H. B. McMahan and M. J. Streeter. Tighter bounds for multi-armed bandits with expert advice. In Proceedings of the 22nd Conference on Learning Theory, 2009. [231]
P. M´enard and A. Garivier. A minimax and asymptotically optimal algorithm for stochastic bandits. In Proceedings of the 28th International Conference on Algorithmic Learning Theory, pages 223­237, Kyoto University, Kyoto, Japan, 15­17 Oct 2017. JMLR.org. [120, 128, 140]
S. P. Meyn and R. L. Tweedie. Markov chains and stochastic stability. Springer Science & Business Media, 2012. [52, 53]
V. Mnih, Cs. Szepesv´ari, and J.-Y. Audibert. Empirical Bernstein stopping. In Proceedings of the 25th International Conference on Machine Learning, pages 672­679, New York, NY, USA, 2008. ACM. [85, 114]
S. Mukherjee, KP. Naveen, N. Sudarsanam, and B. Ravindran. EfficientUCBV: An almost optimal algorithm using variance estimates. In 32nd AAAI Conference on Artificial Intelligence, 2018. [128]
J. A. Nelder and R. W. M. Wedderburn. Generalized linear models. Journal of the Royal Statistical Society. Series A (General), 135(3):370­384, 1972. [246]
A. S. Nemirovsky. Efficient methods for large-scale convex optimization problems. Ekonomika i Matematicheskie Metody, 15, 1979. [342]
A. S. Nemirovsky and D. B. Yudin. Problem Complexity and Method Efficiency in Optimization. Wiley, 1983. [342, 414]

BIBLIOGRAPHY

571

G. Neu. Explore no more: Improved high-probability regret bounds for nonstochastic bandits. In Advances in Neural Information Processing Systems, pages 3168­3176. Curran Associates, Inc., 2015a. [170, 171, 232, 372]
G. Neu. First-order regret bounds for combinatorial semi-bandits. In Proceedings of the 28th Conference on Learning Theory, pages 1360­1375, Paris, France, 2015b. JMLR.org. [170, 339]
G. Neu, A. Gy¨orgy, Cs. Szepesv´ari, and A. Antos. Online Markov decision processes under bandit feedback. IEEE Transactions on Automatic Control, 59(3):676­691, December 2014. [536]
J. Von Neumann and O. Morgenstern. Theory of Games and Economic Behavior. Princeton University Press, Princeton, 1944. [67]
J. Nin~o-Mora. Computing a classic index for finite-horizon bandits. INFORMS Journal on Computing, 23(2):254­267, 2011. [455]
B. O'Donoghue, E. Chu, N. Parikh, and S. Boyd. Conic optimization via operator splitting and homogeneous self-dual embedding. Journal of Optimization Theory and Applications, 169(3):1042­1068, 2016. [508]
B. O'Donoghue, E. Chu, N. Parikh, and S. Boyd. SCS: Splitting conic solver, version 2.1.1. https://github.com/cvxgrp/scs, November 2017. [508]
J. Ok, A. Proutiere, and D. Tranos. Exploration in structured reinforcement learning. In Advances in Neural Information Processing Systems, Red Hook, NY, USA, 2018. Curran Associates Inc. [245, 300]
P. A. Ortega and D. A. Braun. A minimum relative entropy principle for learning and acting. Journal of Artificial Intelligence Research, pages 475­511, 2010. [472]
R. Ortner and D. Ryabko. Online regret bounds for undiscounted continuous reinforcement learning. In Advances in Neural Information Processing Systems, pages 1763­1771, USA, 2012. Curran Associates Inc. [535, 536]
R. Ortner, D. Ryabko, P. Auer, and R. Munos. Regret bounds for restless Markov bandits. In Proceedings of the 23rd International Conference on Algorithmic Learning Theory, pages 214­228, Berlin, Heidelberg, 2012. Springer Berlin Heidelberg. [383]
I. Osband and B. Van Roy. Why is posterior sampling better than optimism for reinforcement learning? In Proceedings of the 34th International Conference on Machine Learning, pages 2701­2710, Sydney, Australia, 06­11 Aug 2017. JMLR.org. [536]
I. Osband, D. Russo, and B. Van Roy. (more) efficient reinforcement learning via posterior sampling. In Advances in Neural Information Processing Systems, pages 3003­3011. Curran Associates, Inc., 2013. [472, 536]
E. Ostrovsky and L. Sirota. Exact value for subgaussian norm of centered indicator random variable. arXiv:1405.6749, 2014. [84]
D. G. Pandelis and D. Teneketzis. On the optimality of the gittins index rule for multi-armed bandits with multiple plays. Mathematical Methods of Operations Research, 50(3):449­461, 1999. [453]

BIBLIOGRAPHY

572

C. H. Papadimitriou and J. N. Tsitsiklis. The complexity of Markov decision processes. Mathematics of Operations Research, 12(3):441­450, 1987. [531]
C. H. Papadimitriou and S. Vempala. On the approximability of the traveling salesman problem. Combinatorica, 26(1):101­120, 2006. [372]
V. Perchet. Approachability of convex sets in games with partial monitoring. Journal of Optimization Theory and Applications, 149(3):665­677, 2011. [506]
V. Perchet and P. Rigollet. The multi-armed bandit problem with covariates. The Annals of Statistics, 41(2):693­721, 04 2013. [248]
G. Peskir and A. Shiryaev. Optimal stopping and free-boundary problems. Springer, 2006. [54, 454, 456]
A. Piccolboni and C. Schindelhauer. Discrete prediction games with arbitrary feedback and loss. In Computational Learning Theory, pages 208­223. Springer, 2001. [505]
C. Pike-Burke, S. Agrawal, Cs. Szepesv´ari, and S. Gru¨new¨alder. Bandits with delayed, aggregated anonymous feedback. In Proceedings of the 35th International Conference on Machine Learning, volume 80, pages 4102­4110. JMLR.org, 10­15 Jul 2018. [359]
J. Poland. FPL analysis for adaptive bandits. In O. B. Lupanov, O. M. Kasim-Zade, A. V. Chaskin, and K. Steinho¨fel, editors, Stochastic Algorithms: Foundations and Applications, pages 58­69, Berlin, Heidelberg, 2005. Springer Berlin Heidelberg. [372]
D. Pollard. A user's guide to measure theoretic probability, volume 8. Cambridge University Press, 2002. [41]
E. L. Presman and I. N. Sonin. Sequential control with incomplete information. The Bayesian approach to multi-armed bandit problems. Academic Press, 1990. [17, 455]
M. Puterman. Markov decision processes: discrete stochastic dynamic programming, volume 414. Wiley, 2009. [534, 537]
C. Qin, D. Klabjan, and D. Russo. Improving the expected improvement algorithm. In Advances in Neural Information Processing Systems, pages 5381­5391. Curran Associates, Inc., 2017. [413]
F. Radlinski, R. Kleinberg, and T. Joachims. Learning diverse rankings with multi-armed bandits. In Proceedings of the 25th International Conference on Machine Learning, pages 784­791. ACM, 2008. [398, 399]
A. N. Rafferty, H. Ying, and J. J. Williams. Bandit assignment for educational experiments: Benefits to students versus statistical power. In Artificial Intelligence in Education, pages 286­290. Springer, 2018. [17]
A. Rakhlin and K. Sridharan. BISTRO: An efficient relaxation-based method for contextual bandits. In Proceedings of the 33rd International Conference on Machine Learning, pages 1977­1985, 2016. [232]
A. Rakhlin and K. Sridharan. On equivalence of martingale tail bounds and deterministic regret inequalities. In Proceedings of the 30th Conference on Learning Theory, pages 1704­1722, Amsterdam, Netherlands, 2017. JMLR.org. [285]

BIBLIOGRAPHY

573

A. Rakhlin, O. Shamir, and K. Sridharan. Making gradient descent optimal for strongly convex stochastic optimization. In Proceedings of the 29th International Conference on Machine Learning, 2012. [414]
L. M. Rios and N. V. Sahinidis. Derivative-free optimization: a review of algorithms and comparison of software implementations. Journal of Global Optimization, 56(3):1247­1293, Jul 2013. [414]
H. Robbins. Some aspects of the sequential design of experiments. Bulletin of the American Mathematical Society, 58(5):527­535, 1952. [17, 68, 94]
H. Robbins and D. Siegmund. Boundary crossing probabilities for the wiener process and sample sums. The Annals of Mathematical Statistics, pages 1410­ 1429, 1970. [260]
H. Robbins and D. Siegmund. A class of stopping rules for testing parametric hypotheses. In Proceedings of the Sixth Berkeley Symposium on Mathematical Statistics and Probability, pages 37­41. University of California Press, 1972. [264]
H. Robbins, D. Sigmund, and Y. Chow. Great expectations: the theory of optimal stopping. Houghton-Nifflin, 7:631­640, 1971. [454]
S. Robertson. The probability ranking principle in IR. Journal of Documentation, 33(4):294­304, 1977. [399, 400]
R. T. Rockafellar. Convex analysis. Princeton university press, 2015. [312, 374] R. T. Rockafellar and S. Uryasev. Optimization of conditional value-at-risk.
Journal of Risk, 2:21­42, 2000. [67] C. A. Rogers. Packing and covering. Cambridge University Press, 1964. [260] S. M. Ross. Introduction to Stochastic Dynamic Programming. Academic Press,
New York, 1983. [534] P. Rusmevichientong and J. N. Tsitsiklis. Linearly parameterized bandits.
Mathematics of Operations Research, 35(2):395­411, 2010. [94, 245, 246, 293] D. Russo. Simple Bayesian algorithms for best arm identification. In Proceedings
of the 29th Annual Conference on Learning Theory, pages 1417­1418, New York, NY, USA, 2016. JMLR.org. [413] D. Russo and B. Van Roy. Eluder dimension and the sample complexity of optimistic exploration. In Advances in Neural Information Processing Systems, pages 2256­2264. Curran Associates, Inc., 2013. [246] D. Russo and B. Van Roy. Learning to optimize via information-directed sampling. In Advances in Neural Information Processing Systems, pages 1583­1591. Curran Associates, Inc., 2014a. [245, 471, 472] D. Russo and B. Van Roy. Learning to optimize via posterior sampling. Mathematics of Operations Research, 39(4):1221­1243, 2014b. [472] D. Russo and B. Van Roy. An information-theoretic analysis of Thompson sampling. Journal of Machine Learning Research, 17(1):2442­2471, 2016. ISSN 1532-4435. [372, 470, 472] D. J. Russo, B. Van Roy, A. Kazerouni, I. Osband, and Z. Wen. A tutorial on Thompson sampling. Foundations and Trends in Machine Learning, 11(1): 1­96, 2018. [472]

BIBLIOGRAPHY

574

A. Rustichini. Minimizing regret: The general case. Games and Economic Behavior, 29(1):224­243, 1999. [504, 505]
A. Salomon, J. Audibert, and I. Alaoui. Lower bounds and selectivity of weakconsistent policies in stochastic multi-armed bandit problem. Journal of Machine Learning Research, 14(Jan):187­207, 2013. [209]
P. Samuelson. A note on measurement of utility. The Review of Economic Studies, 4(2):pp. 155­161, 1937. [453]
A. Sani, A. Lazaric, and R. Munos. Risk-aversion in multi-armed bandits. In Advances in Neural Information Processing Systems, pages 3275­3283. Curran Associates, Inc., 2012. [68]
Y. Seldin and G. Lugosi. An improved parametrization and analysis of the EXP3++ algorithm for stochastic and adversarial bandits. In Proceedings of the 2017 Conference on Learning Theory, pages 1743­1759, Amsterdam, Netherlands, 2017. JMLR.org. [157]
Y. Seldin and A. Slivkins. One practical algorithm for both stochastic and adversarial bandits. In Proceedings of the 31st International Conference on Machine Learning, pages 1287­1295, Bejing, China, 2014. JMLR.org. [157]
S. Shalev-Shwartz. Online learning: Theory, algorithms, and applications. PhD thesis, The Hebrew University of Jerusalem, 2007. [342]
S. Shalev-Shwartz. Online learning and online convex optimization. Foundations and Trends in Machine Learning, 4(2):107­194, 2012. [341, 342]
S. Shalev-Shwartz and S. Ben-David. Understanding Machine Learning: From Theory to Algorithms. Cambridge University Press, 2014. [231, 232, 235]
S. Shalev-Shwartz and Y. Singer. A primal-dual perspective of online learning algorithms. Machine Learning, 69(2-3):115­142, 2007. [342]
O. Shamir. On the complexity of bandit and derivative-free stochastic convex optimization. In Proceedings of the 26th Conference on Learning Theory, pages 3­24. JMLR.org, 2013. [358, 414]
O. Shamir. On the complexity of bandit linear optimization. In Proceedings of the 28th Conference on Learning Theory, pages 1523­1551, Paris, France, 2015. JMLR.org. [293, 354]
T. Sharot. The optimism bias. Current Biology, 21(23):R941­R945, 2011a. [109, 110]
T. Sharot. The optimism bias: A tour of the irrationally positive brain. Pantheon/Random House, 2011b. [110]
D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. Van Den Driessche, J. Schrittwieser, I. Antonoglou, V. Panneershelvam, and M. Lanctot. Mastering the game of go with deep neural networks and tree search. Nature, 529(7587): 484­489, 2016. [17]
S. D. Silvey and B. Sibson. Discussion of Dr. Wynn's and of Dr. Laycock's papers. Journal of Royal Statistical Society (B), 34:174­175, 1972. [269]
M. Sion. On general minimax theorems. Pacific Journal of mathematics, 8(1): 171­176, 1958. [341]

BIBLIOGRAPHY

575

A. Slivkins. Contextual bandits with similarity information. Journal of Machine Learning Research, 15(1):2533­2568, 2014. [357]
A. Slivkins. Introduction to multi-armed bandits. Foundations and Trends in Machine Learning, 12(1-2):1­286, 2019. ISSN 1935-8237. [17, 357]
A. Slivkins and E. Upfal. Adapting to a changing environment: the Brownian restless bandits. In Proceedings of the 21st Conference on Learning Theory, pages 343­354, 2008. [384]
M. Soare, A. Lazaric, and R. Munos. Best-arm identification in linear bandits. In Advances in Neural Information Processing Systems, pages 828­836. Curran Associates, Inc., 2014. [300, 413]
I. M. Sonin. A generalized Gittins index for a Markov chain and its recursive calculation. Statistics and Probability Letters, 78(12):1526­1533, 2008. [455]
N. Srebro, K. Sridharan, and A. Tewari. On the universality of online mirror descent. In Advances in neural information processing systems, pages 2645­2653, 2011. [339]
K. Sridharan and A. Tewari. Convex games in banach spaces. In Proceedings of the 23rd Conference on Learning Theory, pages 1­13. Omnipress, 2010. [342]
N. Srinivas, A. Krause, S. Kakade, and M. Seeger. Gaussian process optimization in the bandit setting: No regret and experimental design. In Proceedings of the 27th International Conference on Machine Learning, page 1015â1022, Madison, WI, USA, 2010. Omnipress. [246]
G. Stoltz. Incomplete information and internal regret in prediction of individual sequences. PhD thesis, Universit´e Paris Sud-Paris XI, 2005. [159]
H. Strasser. Mathematical theory of statistics: statistical experiments and asymptotic decision theory, volume 7. Walter de Gruyter, 2011. [433]
R. E. Strauch. Negative dynamic programming. The Annals of Mathematical Statistics, 37(4):871­890, 08 1966. [537]
M. J. Streeter and S. F. Smith. A simple distribution-free approach to the max k-armed bandit problem. In International Conference on Principles and Practice of Constraint Programming, pages 560­574. Springer, 2006a. [415]
M. J Streeter and S. F. Smith. An asymptotically optimal algorithm for the max k-armed bandit problem. In Proceedings of the National Conference on Artificial Intelligence, pages 135­142, 2006b. [415]
A. Strehl and M. Littman. A theoretical analysis of model-based interval estimation. In Proceedings of the 22nd International Conference on Machine learning, pages 856­863, New York, NY, USA, 2005. ACM. [536]
A. Strehl and M. Littman. An analysis of model-based interval estimation for Markov decision processes. Journal of Computer and System Sciences, 74(8): 1309­1331, 2008. [536, 543]
A. Strehl, L. Li, E. Wiewiora, J. Langford, and M. Littman. PAC model-free reinforcement learning. In Proceedings of the 23rd international conference on Machine learning, pages 881­888, New York, NY, USA, 2006. ACM. [536]

BIBLIOGRAPHY

576

M. J. A. Strens. A Bayesian framework for reinforcement learning. In Proceedings of the 17th International Conference on Machine Learning, pages 943­950, San Francisco, CA, USA, 2000. Morgan Kaufmann Publishers Inc. [535]
Y. Sui, A. Gotovos, J. Burdick, and A. Krause. Safe exploration for optimization with gaussian processes. In Proceedings of the 32nd International Conference on Machine Learning, pages 997­1005, Lille, France, 07­09 Jul 2015. JMLR.org. [359]
Q. Sun, W. Zhou, and J. Fan. Adaptive huber regression: Optimality and phase transition. arXiv:1706.06991, 2017. [115]
R. Sutton and A. Barto. Reinforcement Learning: An Introduction. MIT Press, 1998. [95, 453]
R. Sutton and A. Barto. Reinforcement Learning: An Introduction. MIT Press, second edition, 2018. [534]
J.M. Swart. Large deviation theory, January 2017. URL http://staff.utia. cas.cz/swart/lecture_notes/LDP8.pdf. [83]
V. Syrgkanis, A. Krishnamurthy, and R. Schapire. Efficient algorithms for adversarial contextual learning. In Proceedings of the 33rd International Conference on Machine Learning, pages 2159­2168, New York, NY, USA, 2016. JMLR.org. [232]
Cs. Szepesv´ari. Algorithms for Reinforcement Learning. Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool Publishers, 2010. [535]
I. Szita and A. Lorincz. Optimistic initialization and greediness lead to polynomial time learning in factored MDPs. In Proceedings of the 26th International Conference on Machine Learning, pages 1001­1008, New York, USA, 2009. ACM. [536]
I. Szita and Cs. Szepesv´ari. Model-based reinforcement learning with nearly tight exploration complexity bounds. In Proceedings of the 27th International Conference on Machine Learning, pages 1031­1038, USA, 2010. Omnipress. [536]
E. Takimoto and M. K. Warmuth. Path kernels and multiplicative updates. Journal of Machine Learning Research, 4:773­818, 2003. [373]
M. Talagrand. The missing factor in Hoeffding's inequalities. Annales de l'IHP Probabilit´es et Statistiques, 31(4):689­702, 1995. [79]
G. Taraldsen. Optimal learning from the Doob-Dynkin lemma. arXiv:1801.00974, 2018. [38]
J. Teevan, S. T. Dumais, and E. Horvitz. Characterizing the value of personalizing search. In Proceedings of the 30th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval, pages 757­758, New York, NY, USA, 2007. ACM. [399]
A. Tewari and P. L. Bartlett. Optimistic linear programming gives logarithmic regret for irreducible MDPs. In Advances in Neural Information Processing Systems, pages 1505­1512. Curran Associates, Inc., 2008. [535]

BIBLIOGRAPHY

577

A. Tewari and S. A. Murphy. From ads to interventions: Contextual bandits in mobile health. In Mobile Health, pages 495­517. Springer, 2017. [231]
G. Theocharous, Z. Wen, Y. Abbasi-Yadkori, and N. Vlassis. Posterior sampling for large scale reinforcement learning. arXiv:1711.07979, 2017. [536]
W. Thompson. On the likelihood that one unknown probability exceeds another in view of the evidence of two samples. Biometrika, 25(3/4):285­294, 1933. [16, 68, 95, 458, 469, 472]
W. R. Thompson. On the theory of apportionment. American Journal of Mathematics, 57(2):450­456, 1935. [534]
M. J. Todd. Minimum-volume ellipsoids: Theory and algorithms. SIAM, 2016. [269, 270]
J. R. R. Tolkien. The Hobbit. Ballantine Books, 1937. [458] L. Tran-Thanh, A. Chapman, E. Munoz de Cote, A. Rogers, and N. R. Jennings.
Epsilon­first policies for budget­limited multi-armed bandits. In Proceedings of the 24th AAAI Conference on Artificial Intelligence, AAAI, pages 1211­1216, 2010. [359] L. Tran-Thanh, A. Chapman, A. Rogers, and N. R. Jennings. Knapsack based optimal policies for budget-limited multi-armed bandits. In Proceedings of the 26th AAAI Conference on Artificial Intelligence, AAAI'12, pages 1134­1140. AAAI Press, 2012. [358] J. A. Tropp. An introduction to matrix concentration inequalities. Foundations and Trends® in Machine Learning, 8(1-2):1­230, 2015. [80] J. N. Tsitsiklis. A short proof of the Gittins index theorem. The Annals of Applied Probability, pages 194­199, 1994. [455] A. B. Tsybakov. Introduction to nonparametric estimation. Springer Science & Business Media, 2008. [192, 193] C. Ionescu Tulcea. Mesures dans les espaces produits. Atti Accademia Nazionale Lincei Rend, 7:208­211, 1949­50. [54] E. Uchibe and K. Doya. Competitive-cooperative-concurrent reinforcement learning with importance sampling. In Proceedings of the International Conference on Simulation of Adaptive Behavior: From Animals and Animats, pages 287­296, 2004. [171] M. Valko. Bandits on graphs and structures, 2016. [250, 359] M. Valko, A. Carpentier, and R. Munos. Stochastic simultaneous optimistic optimization. In Proceedings of the 30th International Conference on Machine Learning, pages 19­27, Atlanta, GA, USA, 2013a. JMLR.org. [413, 414] M. Valko, N. Korda, R. Munos, I. Flaounas, and N. Cristianini. Finite-time analysis of kernelised contextual bandits. In Proceedings of the 29th Conference on Uncertainty in Artificial Intelligence, pages 654­663, Arlington, VA, USA, 2013b. AUAI Press. [246] M. Valko, R. Munos, B. Kveton, and T. Koca´k. Spectral bandits for smooth graph functions. In Proceedings of the 31st International Conference on Machine Learning, pages 46­54, Bejing, China, 2014. JMLR.org. [246, 250, 273]

BIBLIOGRAPHY

578

S. van de Geer. Empirical Processes in M-estimation, volume 6. Cambridge University Press, 2000. [80, 260, 340]
D. van der Hoeven, T. van Erven, and W. Kotlowski. The many faces of exponential weights in online learning. In Proceedings of the 31st Conference on Learning Theory, pages 2067­2092, 2018. [322]
A. W. van der Vaart and J. A. Wellner. Weak Convergence and Empirical Processes. Springer, New York, 1996. [340]
H. P. Vanchinathan, G. Bart´ok, and A. Krause. Efficient partial monitoring with prior information. In Advances in Neural Information Processing Systems, pages 1691­1699. Curran Associates, Inc., 2014. [505]
V. Vapnik. Statistical learning theory. 1998, volume 3. Wiley, New York, 1998. [235]
P. Varaiya, J. Walrand, and C. Buyukkoc. Extensions of the multiarmed bandit problem: The discounted case. IEEE Transactions on Automatic Control, 30 (5):426­439, 1985. [455]
C. Vernade, O. Capp´e, and V. Perchet. Stochastic bandit models for delayed conversions. In Proceedings of the 33rd Conference on Uncertainty in Artificial Intelligence. AUAI Press, 2017. [359]
C. Vernade, A. Carpentier, G. Zappella, B. Ermis, and M. Brueckner. Contextual bandits under delayed feedback. arXiv:1807.02089, 2018. [359]
S. Villar, J. Bowden, and J. Wason. Multi-armed bandit models for the optimal design of clinical trials: benefits and challenges. Statistical science: a review journal of the Institute of Mathematical Statistics, 30(2):199­215, 2015. [17]
W. Vogel. An asymptotic minimax theorem for the two armed bandit problem. The Annals of Mathematical Statistics, 31(2):444­451, 1960. [201]
J. von Neumann. Zur theorie der gesellschaftsspiele. Mathematische annalen, 100 (1):295­320, 1928. [341]
V. G. Vovk. Aggregating strategies. Proceedings of Computational Learning Theory, 1990. [146, 159]
S. Wang and W. Chen. Thompson sampling for combinatorial semi-bandits. In Proceedings of the 35th International Conference on Machine Learning, pages 5114­5122, Stockholmsma¨ssan, Stockholm Sweden, 10­15 Jul 2018. JMLR.org. [372, 472]
Y. Wang, J-Y. Audibert, and R. Munos. Algorithms for infinitely many-armed bandits. In Advances in Neural Information Processing Systems, pages 1729­ 1736, 2009. [357]
M. K. Warmuth and A. Jagota. Continuous and discrete-time nonlinear gradient descent: Relative loss bounds and convergence. In Electronic Proceedings of the 5th International Symposium on Artificial Intelligence and Mathematics, 1997. [341]
P. L Wawrzynski and A. Pacut. Truncated importance sampling for reinforcement learning with experience replay. In Proceedings of the International Multiconference on Computer Science and Information Technology, pages 305­ 315, 2007. [171]

BIBLIOGRAPHY

579

R. Weber. On the Gittins index for multiarmed bandits. The Annals of Applied Probability, 2(4):1024­1033, 1992. [455]
R. Weber and G. Weiss. On an index policy for restless bandits. Journal of Applied Probability, 27(3):637­648, 1990. [455]
C-Y. Wei and H. Luo. More adaptive algorithms for adversarial bandits. In Proceedings of the 31st Conference On Learning Theory, pages 1263­1291. JMLR.org, 06­09 Jul 2018. [339, 342, 346]
M. J. Weinberger and E. Ordentlich. On delayed prediction of individual sequences. In Information Theory, 2002. Proceedings. 2002 IEEE International Symposium on, page 148. IEEE, 2002. [359]
Z. Wen, B. Kveton, and A. Ashkan. Efficient learning in large-scale combinatorial semi-bandits. In Proceedings of the 32nd International Conference on Machine Learning, volume 37, pages 1113­1122, Lille, France, 2015. JMLR.org. [372]
P. Whittle. Multi-armed bandits and the Gittins index. Journal of the Royal Statistical Society (B), pages 143­149, 1980. [455]
P. Whittle. Restless bandits: Activity allocation in a changing world. Journal of applied probability, 25(A):287­298, 1988. [383, 455]
D. Williams. Probability with martingales. Cambridge University Press, 1991. [41]
H. Wu and X. Liu. Double Thompson sampling for dueling bandits. In Advances in Neural Information Processing Systems, pages 649­657. Curran Associates, Inc., 2016. [358]
Y. Wu, A. Gy¨orgy, and Cs. Szepesv´ari. Online learning with gaussian payoffs and side observations. In Advances in Neural Information Processing Systems, pages 1360­1368. Curran Associates Inc., 2015. [505]
Y. Wu, R. Shariff, T. Lattimore, and Cs. Szepesv´ari. Conservative bandits. In Proceedings of the 33rd International Conference on Machine Learning, pages 1254­1262, New York, NY, USA, 20­22 Jun 2016. JMLR.org. [359]
H. P. Wynn. The sequential generation of D-optimum experimental designs. The Annals of Mathematical Statistics, pages 1655­1664, 1970. [269]
Y. Xia, H. Li, T. Qin, N. Yu, and T.-Y. Liu. Thompson sampling for budgeted multi-armed bandits. In Proceedings of the 24th International Conference on Artificial Intelligence, IJCAI, pages 3960­3966. AAAI Press, 2015. [358]
Y. Yao. Some results on the Gittins index for a normal reward process. In Time Series and Related Topics, pages 284­294. Institute of Mathematical Statistics, 2006. [455]
B. Yu. Assouad, Fano, and Le Cam. In D. Pollard, E. Torgersen, and G. L. Yang, editors, Festschrift for Lucien Le Cam: Research Papers in Probability and Statistics, pages 423­435. Springer, 1997. [201, 202]
Y. Yue and T. Joachims. Interactively optimizing information retrieval systems as a dueling bandits problem. In Proceedings of the 26th International Conference on Machine Learning, pages 1201­1208. ACM, 2009. [358]

BIBLIOGRAPHY

580

Y. Yue and T. Joachims. Beat the mean bandit. In Proceedings of the 28th International Conference on Machine Learning, pages 241­248, New York, NY, USA, June 2011. ACM. [358]
Y. Yue, J. Broder, R. Kleinberg, and T. Joachims. The k-armed dueling bandits problem. In Proceedings of the 22nd Conference on Learning Theory, 2009. [358]
J. Zimmert and T. Lattimore. Connections between mirror descent, thompson sampling and the information ratio. In Advances in Neural Information Processing Systems, pages 11973­11982. Curran Associates, Inc., 2019. [471]
J. Zimmert and Y. Seldin. An optimal algorithm for stochastic and adversarial bandits. In AISTATS, pages 467­475, 2019. [157, 346, 358]
J. Zimmert, H. Luo, and C-Y. Wei. Beating stochastic and adversarial semibandits optimally and simultaneously. In Proceedings of the 36th International Conference on Machine Learning, pages 7683­7692, Long Beach, California, USA, 09­15 Jun 2019. JMLR.org. [346]
M. Zinkevich. Online convex programming and generalized infinitesimal gradient ascent. In Proceedings of the 20th International Conference on Machine Learning, pages 928­935. AAAI Press, 2003. [341]
M. Zoghi, S. Whiteson, R. Munos, and M. Rijke. Relative upper confidence bound for the k-armed dueling bandit problem. In Proceedings of the 31st International Conference on Machine Learning, pages 10­18, Bejing, China, 2014. JMLR.org. [358]
M. Zoghi, Z. Karnin, S. Whiteson, and M. Rijke. Copeland dueling bandits. In Advances in Neural Information Processing Systems, pages 307­315. Curran Associates, Inc., 2015. [358]
M. Zoghi, T. Tunys, M. Ghavamzadeh, B. Kveton, Cs. Szepesv´ari, and Z. Wen. Online learning to rank in stochastic click models. In Proceedings of the 34th International Conference on Machine Learning, JMLR.org, pages 4199­4208, 2017. [398]
S. Zong, H. Ni, K. Sung, R. N. Ke, Z. Wen, and B. Kveton. Cascading bandits for large-scale recommendation problems. In Proceedings of the 32nd Conference on Uncertainty in Artificial Intelligence, 2016. [397, 398]

Index

-algebra, 21 restriction of, 42
a.s., 35 Abel sum, 532 absolutely continuous, 39 action space, 510 adapted, 27 AdaUCB, 128, 463 admissible, 419 affine hull, 481 almost surely, 35 anytime, 94
Exp3, 344 Exp3-IX, 170 Exp4, 229 MOSS, 128 UCB, 116 arithmetic coding, 186 Assouad's method, 202 asymptotic optimality k-armed lower bounds, 205­206 k-armed upper bounds, 116, 128, 136 best arm identification, 403­409 linear bandits, 294­298 partial monitoring, 505 ranking, 398 Thompson sampling, 469
Bachelier­L´evy formula, 130 bandits with expert advice, 226 Bayes rule, 28 Bayesian bandit environment, 428 Bayesian optimal policy, 430
1-armed bandit, 442 discounted bandit, 448

Bayesian regret, 61, 430 Bayesian upper confidence bound algo-
rithm, 470 Bellman optimality equation, 515 Bennett's inequality, 85 Bernoulli
bandit, 58, 70, 71, 120, 132­142, 158, 162, 174, 201, 202, 425, 428, 429, 434, 437, 438, 443, 448, 454, 456, 458, 472
distribution, 58, 75, 81, 84, 188 random variable, 34, 54, 367 Bernstein's inequality, 85, 85, 535 empirical, 110, 113 beta distribution, 425 bias-variance trade-off, 222 bidual, 305, 374 bits, 187 Borel -algebra, 22 Borel function, see Borel measurable
function Borel measurable function, 23 Borel space, 46 boundary, 312 Bregman divergence, 306­308, 326,
435 Bretagnolle-Huber inequality, 189, 199,
207, 215, 287, 405 Brownian motion, 129, 384
canonical bandit model, 196 k-armed stochastic, 63 Bayesian, 436 contextual, 70 infinite-armed stochastic, 66

INDEX

582

Carath´eodory's extension theorem, 25 cardinal optimisation, 415 cascade model, 388 categorical distribution, 86, 486, 525 Catoni's estimator, 115 cell decomposition, 481 Ces`aro sum, 515, 532 chain rule of probability measures, 53 change of measure, 39 Chernoff bound, 133, 397 chi-squared distance, 192, 202 chi-squared distribution, 80, 240 click model, 387 closed function, 374 closed set, 312 complement, 21 concave, 306 conditional expectation, 33 conditional independence, 37 conditional probability, 28 conjugate pair, 425 conjugate prior, 424, 425 consistent policy, 205, 294 contextual bandit, 70, 222, 381
adversarial linear, 352 stochastic, 230, 233, 236­238 stochastic linear, 238­243, 352 contextual partial monitoring, 506 controlled Markov environment, 536 convex hull, 304 convex optimisation, 325 core set, 266 counting measure, 40 covering, 253, 261 Cram´er transform, 82, 83 Cram´er­Chernoff method, 76­78, 167,
255, 256 cumulant generating function, 76, 141 cumulative distribution function, 33
D-optimal design, 266 data processing inequality, 194, 488 degenerate action, 481 density, 39

derivative-free stochastic optimisation, 413
descriptive theory, 67 deviation matrix, 538 diameter
of convex set, 332 of MDP, 513 differential value function, 515 discount factor, 382 discounting, 382, 446, 453 disintegration theorem, 53, 433, 434 distribution, 21 domain, 304 dominated action, 481 dominating measure, 40 doubling trick, 94, 96, 158, 285, 339 dual norm, 333 dynamic programming, 453
easy partial monitoring game, 481 effective dimension, 249 elimination algorithm, 94, 95, 97, 122,
209, 271, 276 elliptical potential lemma, 241 empirical risk minimisation, 231 entropy, 185, 186, 193 events, 19 exchangeable, 235 Exp3, 151, 223, 317, 319, 325, 343, 362,
376, 378, 480 Exp3-IX, 165, 213, 362, 384 Exp3.P, 172, 232, 384 Exp3.S, 384 Exp4, 227, 247, 377 expectation, 30 explore-then-commit, 90, 108, 230, 246 exponential family, 120, 140, 209, 210,
406, 426, 426, 469 exponential weighting, 151, 365
algorithm, 157 continuous, 319­321 extended real line, 304
feasible, 517 feature map, 237

INDEX

583

feature space, 238 feature vector, 238 feedback matrix, 478 Fenchel dual, 83, 255, 305 filtered probability space, 28 filtration, 27 finite additivity, 21 first-order bound, 170, 339, 345 first-order optimality condition, 310 Fisher information, 200 fixed design, 252 fixed share, 383 follow the leader, 326, 340 follow-the-perturbed-leader, 162, 230,
365, 461 follow-the-regularised-leader, 326, 353,
354 changing potentials, 344 Frank­Wolfe algorithm, 268, 270 Fubini's theorem, 40 full information, 157, 383 fundamental matrix, 538
G-optimal design, 266 gain, 514 game theory, 182 Gaussian tail lower bound, 473 generalised linear bandit, 248 generalised linear model, 245 Gittins index, 383, 445 globally observable, 484 gradient descent, 327 graph Laplacian, 250
Hahn decomposition, 31 hard partial monitoring game, 481 Hardy­Littlewood, 449, 456, 457 heavy tailed, 76 Hedge, 156 Hellinger distance, 192 Hoeffding's inequality, 79, 135, 397 Hoeffding's lemma, 79, 83, 134, 157,
262 Hoeffding­Azuma, 262, 527 hopeless partial monitoring game, 481

Huffman coding, 186 hypothesis space, 422
image, 501 implicitly normalised forecaster, 346 importance-weighted estimator, 149,
150, 170, 230, 336 independent events, 29 index, 445 index policy, 445 indicator function, 23 information-directed sampling, 245,
471, 474, 506 instance-dependent bound, 231 integrable, 31 interior, 312 Ionescu­Tulcea theorem, 48, 66, 429,
512 isomorphic measurable spaces, 46
Jensen's inequality, 306 John's ellipsoid, 322
Kearns-Saul inequality, 84 kernel, 501 kernel trick, 243 Kiefer­Wolfowitz, 266, 273, 319, 322,
335, 353 Kraft's inequality, 190 Kullback­Leibler divergence, 185
Laplace's method, 256 large deviation theory, 82 law, 22 law of the iterated logarithm, 111, 123,
263 law of total expectations, 36 Le Cam's inequality, 190 Le Cam's method, 201 learning rate, 151
adaptive, 339, 345 time-varying, 229, 327, 344, 345 least-squares, 252 Lebesgue integral, 30 Lebesgue measure, 32 Legendre function, 308­310, 326, 365 light tailed, 76

INDEX

584

likelihood ratio, 264 linear subspace, 501 link function, 245 Lipschitz bandit, 247 locally observable, 484 log partition function, 426 log-concave, 320 logistic function, 426 loss matrix, 478
margin, 248 Markov chain, 48­49, 512 Markov kernel, 48 Markov policy, 512 Markov process, 52 Markov property, 531 Markov reward process, 445 martingale, 49 maximal end component, 545 maximal inequality, 51, 123, 258 measurable map, 22 measurable set, 21 measurable space, 21 measure, 21 median-of-means, 114 memoryless deterministic policy, 512 memoryless policy, 512 metric entropy, 261 minimax, 122 minimax optimal, 179 mirror descent, 157, 326, 365, 378 misspecified linear bandit, 273, 291,
353, 354 model, 422 MOSS, 120, 122 multi-class classification with bandit
feedback, 232 multi-task bandit, 290, 362, 374
nats, 187 negative correlation, 168 neighbouring actions, 482 non-anticipating sequence, 344 non-oblivious, 157, 339 non-parametric, 58

non-singular exponential family, 426 non-stationary bandit, 68 nonstationary, 158 null set, 35
oblivious, 333, 339 oblivious adversary, 157 one-armed bandit, 10, 71, 120
Bayesian, 441­445 online gradient descent, 327 online learning, 17, 281, 325 online linear optimisation, 325 online-to-confidence set conversion, 280 open set, 312 operator, 41 optimal experimental design, 266, 411 optimal value function, 515 optimisation oracle, 230, 370 optimism bias, 109 optional stopping theorem, 50 ordinal optimisation, 415 orthogonal complement, 501 outcome space, 19
packing, 261 parameter noise, 350 parametric, 58 Pareto optimal, 183, 419 Pareto optimal action, 481 partial monitoring, 13 partially observable Markov decision
process, 531 peeling device, 123 permutation, 386 Pinsker's inequality, 133, 140, 191, 193,
332 point-locally observable, 503 Poisson distribution, 81 policy, 64 policy iteration, 533 policy schema, 432 position-based model, 388 posterior, 421 potential function, 326 predictable, 27

INDEX

585

predictable variation, 85, 86 prediction with expert advice, 157 preimage, 20 prescriptive theory, 67 prior, 419, 422 prior variance, 425 probability distribution, 21 probability kernel, 48, 422 probability measure, 21 probability space, 21 product -algebra, 25 product kernel, 48 product measure, 40, 65 projective, 47 push-forward, 22
quadratic variation, 170
Rademacher variable, 82 Radon­Nikodym derivative, 39 random
element, 22 variable, 22 vector, 22 random table model, 65, 149 random variable, 19 ranked bandit model, 397 ranking and selection, 414 rate function, 83 reactive adversary, 157 reduction, 349, 402 regret, 10 adversarial, 147 non-stationary, 377 policy, 157 pseudo, 68 pseudo, random, 214 random, 68 stochastic, 60 tracking, 377 regret decomposition lemma, 62 regular exponential family, 426 regular version, 52, 194, 195 regularised risk minimisation, 342 regulariser, 326

reinforcement learning, 13, 95, 453, 521 relative entropy, 187­190, 308, 435 restless bandit, 383, 455 retirement policy, 71 reward-stack model, 65, 449 ridge regression, 252 right stochastic matrix, 510
semi-bandit, 360, 363­370, 398, 400 semibandit, 472 separation oracle, 320, 519 sequential halving, 410 Sherman-Morrison formula, 251 signal variance, 425 signal-to-noise ratio, 351 signed measure, 21 similarity function, 225 simple function, 31 Sion's minimax theorem, 341, 347, 432,
471 sliding window, 382 smoothness, 238 source coding theorem, 186 span, 515 spectral bandit, 249 state space, 510 static experts, 230 stationary transition matrix, 515, 538 stochastic optimisation, 411 stochastic process, 47 stopping rule, 50 stopping time, 50 strictly convex, 305 strongly connected component, 545 sub--algebra, 21 submartingale, 49, 123 suboptimality gap, 62 sufficient statistic, 433, 442, 448, 531
of exponential family, 426 supermartingale, 49, 260 supervised learning, 225 support, 41 support function, 366, 373 supporting hyperplane, 310

theorem, 313, 436
tail probability, 33 Thompson sampling, 68, 120, 458
for reinforcement learning, 535 total variation distance, 192, 192 tower rule, 36 track-and-stop algorithm, 408 transductive learning, 232 transition matrix, 514 trivial event, 43 trivial partial monitoring game, 481
UCB-V, 114 uniform exploration algorithm, 401 union bound, 77 universal constant, 4 unnormalised negentropy, 308, 309,
314, 328, 343, 363, 378, 468 unstructured bandits, 205
value function, 440 vanishing discount approach, 532 Varaiya's algorithm, 454 VC dimension, 234 von Neumann-Morgenstern theorem, 67
Wald­Bellman equation, 440 weak neighbour, 503 weak* topology, 41 worst-case regret, 179
zeroth-order stochastic optimisation, 413

INDEX

586

